/*
 * DO NOT EDIT THIS FILE. Generated by checkmk.
 * Edit the original source file "test/in" instead.
 */

#include <check.h>
#include <stdio.h>

#include "../s21_decimal.h"
#include "debug_helper.h"

// set_sign
// Функция set_sign поставить знак плюс
START_TEST(set_sign_positive) {
  big_decimal value = {0};
  Bset_sign(&value, plus);

  ck_assert(((value.bits[3] >> 31) & 1) == plus);

  // Функция set_sign поставить знак минус
}
END_TEST

START_TEST(set_sign_negative) {
  big_decimal value = {0};
  Bset_sign(&value, minus);

  ck_assert(((value.bits[6] >> 31) & 1) == minus);

  // get_sign
  //  Функция get_sign проверить знак плюс
}
END_TEST

START_TEST(get_sign_positive) {
  big_decimal value = {0};
  Bset_sign(&value, plus);

  ck_assert(Bget_sign(value) == plus);

  // Функция get_sign проверить знак плюс
}
END_TEST

START_TEST(get_sign_negative) {
  big_decimal value = {0};
  Bset_sign(&value, minus);

  ck_assert(Bget_sign(value) == minus);

  // set_bit
  //  Функция set_bit поменять бит 0 на бит 0 индекс 0
}
END_TEST

START_TEST(set_bit_zero_false) {
  big_decimal value = (big_decimal){{0}};
  Bset_bit(&value, 0, false);

  ck_assert(Bget_bit(value, 0) == false);

  // Функция set_bit поменять бит 0 на бит 1 индекс 0
}
END_TEST

START_TEST(set_bit_zero_true) {
  big_decimal value = (big_decimal){{0}};
  Bset_bit(&value, 0, true);

  ck_assert(Bget_bit(value, 0) == true);

  // Функция set_bit поменять бит 1 на бит 0 индекс 0
}
END_TEST

START_TEST(set_bit_one_false) {
  big_decimal value = (big_decimal){{1}};
  Bset_bit(&value, 0, false);

  ck_assert(Bget_bit(value, 0) == false);

  // Функция set_bit поменять бит 1 на бит 1 индекс 0
}
END_TEST

START_TEST(set_bit_one_true) {
  big_decimal value = (big_decimal){{1}};
  Bset_bit(&value, 0, true);

  ck_assert(Bget_bit(value, 0) == true);

  // Функция set_bit поменять бит 0 на бит 0 индекс 16
}
END_TEST

START_TEST(set_bit_middle_false) {
  big_decimal value = (big_decimal){{0}};
  Bset_bit(&value, 16, false);

  ck_assert(Bget_bit(value, 16) == false);

  // Функция set_bit поменять бит 0 на бит 1 индекс 16
}
END_TEST

START_TEST(set_bit_middle_true) {
  big_decimal value = (big_decimal){{0}};
  Bset_bit(&value, 16, true);

  ck_assert(Bget_bit(value, 16) == true);

  // Функция set_bit поменять бит 1 на бит 0 индекс 16
}
END_TEST

START_TEST(set_bit_middle_false_one) {
  big_decimal value = (big_decimal){{1}};
  Bset_bit(&value, 16, false);

  ck_assert(Bget_bit(value, 16) == false);

  // Функция set_bit поменять бит 1 на бит 1 индекс 16
}
END_TEST

START_TEST(set_bit_middle_true_one) {
  big_decimal value = (big_decimal){{1}};
  Bset_bit(&value, 16, true);

  ck_assert(Bget_bit(value, 16) == true);

  // Функция set_bit поменять бит 1 на бит 0 индекс 96
}
END_TEST

START_TEST(set_bit_overflow_false_one) {
  big_decimal value = (big_decimal){{1}};
  Bset_bit(&value, 96, false);

  ck_assert(Bget_bit(value, 96) == false);

  // s21_add
  // Функция s21_add сложение двух положительных чисел
}
END_TEST

START_TEST(add_positive_numbers) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  s21_decimal result;
  s21_decimal expected = {{30, 0, 0, 0}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // s21_add
  // Функция s21_add сложение двух больших положительных чисел
}
END_TEST

START_TEST(add_big_positive_numbers) {
  s21_decimal value_1 = {{10, 30, 60000, 0}};
  s21_decimal value_2 = {{20, 30, 60000, 0}};
  s21_decimal result;
  s21_decimal expected = {{30, 60, 120000, 0}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение двух отрицательных чисел
}
END_TEST

START_TEST(add_negative_numbers) {
  s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
  s21_decimal result;
  s21_decimal expected = {{30, 0, 0, 0x80000000}};

  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение положительного и отрицательного чисел
}
END_TEST

START_TEST(add_positive_and_negative) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
  s21_decimal result;
  s21_decimal expected = {{10, 0, 0, 0x80000000}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение отрицательного и положительного чисел
}
END_TEST

START_TEST(add_negative_and_positive) {
  s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  s21_decimal result;
  s21_decimal expected = {{10, 0, 0, 0}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение двух положительных дробных
}
END_TEST

START_TEST(add_positive_float) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result;
  s21_decimal expected = {{200001, 0, 0, 0}};
  set_scale(&expected, 9);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение двух больших положительных дробных
  // #test add_big_positive_float
  // s21_decimal value_1 = {1, 0, 565264864, 0};
  // s21_decimal value_2 = {{0}};
  // str_to_decimal("50000000")
  // s21_decimal result;
  // s21_decimal expected = {{200001, 0, 0, 0}};
  // set_scale(&expected, 9);
  // int return_code = s21_add(value_1, value_2, &result);

  // ck_assert(s21_is_equal(result, expected) == 1);
  // ck_assert(return_code == 0);

  // Функция s21_add сложение двух отрицательных дробных
}
END_TEST

START_TEST(add_negative_float) {
  s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result;
  s21_decimal expected = {{200001, 0, 0, 0x80000000}};
  set_scale(&expected, 9);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение положительного и отрицательного дробных
}
END_TEST

START_TEST(add_positive_and_negative_float) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result;
  s21_decimal expected = {{199999, 0, 0, 0x80000000}};
  set_scale(&expected, 9);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение отрицательного и положительного дробных
}
END_TEST

START_TEST(add_negative_and_positive_float) {
  s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result;
  s21_decimal expected = {{199999, 0, 0, 0}};
  set_scale(&expected, 9);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);
  // Функция s21_add сложение положительного дробного и целого
}
END_TEST

START_TEST(add_positive_float_int) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  s21_decimal result;
  s21_decimal expected = {{2820130817U, 4, 0, 0}};
  set_scale(&expected, 9);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение отрицательного дробного и целого
}
END_TEST

START_TEST(add_negative_float_int) {
  s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
  set_scale(&value_1, 10);
  s21_decimal result;
  s21_decimal expected = {{2820130817U, 4, 0, 0x80000000}};
  set_scale(&expected, 9);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение отрицательного дробного и положительного целого
}
END_TEST

START_TEST(add_negative_float_positive_int) {
  s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  s21_decimal result;
  s21_decimal expected = {{2820130815U, 4, 0, 0}};
  set_scale(&expected, 9);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение положительного дробного и отрицательного целого
}
END_TEST

START_TEST(add_positive_float_negative_int) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
  set_scale(&value_1, 10);
  s21_decimal result;
  s21_decimal expected = {{2820130815U, 4, 0, 0x80000000}};
  set_scale(&expected, 9);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение положительного целого отрицательного дробного
}
END_TEST

START_TEST(add_positive_int_negative_float) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
  set_scale(&value_2, 5);
  s21_decimal result;
  s21_decimal expected = {{99998, 0, 0, 0}};
  set_scale(&expected, 4);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);
  //
  //// Функция s21_add сложение отрицательного целого положительного дробного
}
END_TEST

START_TEST(add_negative_int_positive_float) {
  s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_scale(&value_2, 5);
  s21_decimal result;
  s21_decimal expected = {{99998, 0, 0, 0x80000000}};
  set_scale(&expected, 4);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add очень большое число и маленькое - переполнение
}
END_TEST

START_TEST(add_overflow) {
  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal value_2 = {{1, 0, 0, 0}};
  s21_decimal result;

  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(return_code == 1);

  // Функция s21_add сложение очень маленького и очень большого - переполнение
}
END_TEST

START_TEST(add_overflow_two) {
  s21_decimal value_1 = {{1, 0, 0, 0}};
  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal result;

  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(return_code == 1);

  // Функция s21_add сложение двух очень больших - переполнение ????
  // 79228162514264337593543950335+79228162514264337593543950335=79228162514264337593543950334
}
END_TEST

START_TEST(add_overflow_three) {
  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal result;

  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(return_code == 1);

  // Функция s21_add сложение отрицательных очень большое число и маленькое -
  // переполнение отрицательная бесконечность
}
END_TEST

START_TEST(add_overflow_negative) {
  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  s21_decimal value_2 = {{1, 0, 0, 0x80000000}};
  s21_decimal result;

  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(return_code == 2);

  // Функция s21_add сложение отрицательных очень маленького и очень большого -
  // переполнение отрицательная бесконечность
}
END_TEST

START_TEST(add_overflow_negative_two) {
  s21_decimal value_1 = {{1, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  s21_decimal result;

  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(return_code == 2);

  // Функция s21_add сложение отрицательных двух очень больших - переполнение
  // ???
  //-79228162514264337593543950335-79228162514264337593543950335=-79228162514264337593543950334
}
END_TEST

START_TEST(add_overflow_negative_three) {
  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  s21_decimal result;

  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(return_code == 2);

  // Функция s21_add сложение двух нулей
}
END_TEST

START_TEST(add_positive_numbers_zero) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  s21_decimal result;
  s21_decimal expected = {{0, 0, 0, 0}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение положительного и отрицательного нуля
}
END_TEST

START_TEST(add_positive_and_negative_zero) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0x80000000}};
  s21_decimal result;
  s21_decimal expected = {{0, 0, 0, 0}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение отрицательного и положительного нуля
}
END_TEST

START_TEST(add_negative_and_positive_zero) {
  s21_decimal value_1 = {{0, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  s21_decimal result;
  s21_decimal expected = {{0, 0, 0, 0}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение отрицательных нулей
}
END_TEST

START_TEST(add_negative_numbers_zero) {
  s21_decimal value_1 = {{0, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{0, 0, 0, 0x80000000}};
  s21_decimal expected = {{0, 0, 0, 0x80000000}};
  s21_decimal result;
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение положительного числа и нуля
}
END_TEST

START_TEST(add_positive_numbers_and_zero) {
  s21_decimal value_1 = {{15, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  s21_decimal result;
  s21_decimal expected = {{15, 0, 0, 0}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение нуля и положительного числа
}
END_TEST

START_TEST(add_zero_and_positive_numbers) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{15, 0, 0, 0}};
  s21_decimal result;
  s21_decimal expected = {{15, 0, 0, 0}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение положительного дробного и нуля
}
END_TEST

START_TEST(add_positive_float_and_zero) {
  s21_decimal value_1 = {{15, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  set_scale(&value_1, 7);
  s21_decimal result;
  s21_decimal expected = {{15, 0, 0, 0}};
  set_scale(&expected, 7);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение нуля и положительного дробного
}
END_TEST

START_TEST(add_zero_and_positive_float) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{15, 0, 0, 0}};
  set_scale(&value_2, 7);
  s21_decimal result;
  s21_decimal expected = {{15, 0, 0, 0}};
  set_scale(&expected, 7);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение отрицательного числа и нуля
}
END_TEST

START_TEST(add_negative_numbers_and_zero) {
  s21_decimal value_1 = {{15, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  s21_decimal result;
  s21_decimal expected = {{15, 0, 0, 0x80000000}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение нуля и отрицательного числа
}
END_TEST

START_TEST(add_zero_and_negative_numbers) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{15, 0, 0, 0x80000000}};
  s21_decimal result;
  s21_decimal expected = {{15, 0, 0, 0x80000000}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение отрицательного дробного и нуля
}
END_TEST

START_TEST(add_negative_float_and_zero) {
  s21_decimal value_1 = {{15, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  set_scale(&value_1, 7);
  s21_decimal result;
  s21_decimal expected = {{15, 0, 0, 0x80000000}};
  set_scale(&expected, 7);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение нуля и отрицательного дробного
}
END_TEST

START_TEST(add_zero_and_negative_float) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{15, 0, 0, 0x80000000}};
  set_scale(&value_2, 7);
  s21_decimal result;
  s21_decimal expected = {{15, 0, 0, 0x80000000}};
  set_scale(&expected, 7);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение двух положительных чисел с большой мантиссой
}
END_TEST

START_TEST(add_positive_float_big_scale) {
  s21_decimal value_1 = {{1, 0, 0, 0}};
  s21_decimal value_2 = {{2, 0, 0, 0}};
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result;
  s21_decimal expected = {{21, 0, 0, 0}};
  set_scale(&expected, 28);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение двух отрицательных чисел с большой мантиссой
}
END_TEST

START_TEST(add_negative_float_big_scale_) {
  s21_decimal value_1 = {{1, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{2, 0, 0, 0x80000000}};
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result;
  s21_decimal expected = {{21, 0, 0, 0x80000000}};
  set_scale(&expected, 28);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение отрицательного и положительного с большой
  // мантиссой
}
END_TEST

START_TEST(add_negative_and_positive_float_big_scale_) {
  s21_decimal value_1 = {{1, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{2, 0, 0, 0}};
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result;
  s21_decimal expected = {{19, 0, 0, 0}};
  set_scale(&expected, 28);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение положительного и отрицательного с большой
  // мантиссой
}
END_TEST

START_TEST(add_positive_and_negative_float_big_scale) {
  s21_decimal value_1 = {{1, 0, 0, 0}};
  s21_decimal value_2 = {{2, 0, 0, 0x80000000}};
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result;
  s21_decimal expected = {{19, 0, 0, 0x80000000}};
  set_scale(&expected, 28);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // s21_sub
  // Функция s21_sub вычитание двух положительных целых чисел
}
END_TEST

START_TEST(sub_positive_numbers) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  s21_decimal result;
  s21_decimal expected = {{10, 0, 0, 0x80000000}};
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание двух отрицательных целых чисел
}
END_TEST

START_TEST(sub_negative_numbers) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_sign(&value_1, minus);
  set_sign(&value_2, minus);
  s21_decimal expected = {{10, 0, 0, 0}};
  s21_decimal result;
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание позитивного и отрицательного целых чисел
}
END_TEST

START_TEST(sub_positive_and_negative) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_sign(&value_2, minus);
  s21_decimal result;
  s21_decimal expected = {{30, 0, 0, 0}};
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание отрицательного и позитивного целых чисел
}
END_TEST

START_TEST(sub_negative_and_positive) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_sign(&value_1, minus);
  s21_decimal result;
  s21_decimal expected = {{30, 0, 0, 0x80000000}};
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание двух положительных дробных чисел
}
END_TEST

START_TEST(sub_positive_float) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result;
  s21_decimal expected = {{199999, 0, 0, 0x80000000}};
  set_scale(&expected, 9);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание двух отрицательных дробных чисел
}
END_TEST

START_TEST(sub_negative_float) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_sign(&value_1, minus);
  set_sign(&value_2, minus);
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result;
  s21_decimal expected = {{199999, 0, 0, 0}};
  set_scale(&expected, 9);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание положительного и отрицательного дробных чисел
}
END_TEST

START_TEST(sub_positive_and_negative_float) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_sign(&value_2, minus);
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result;
  s21_decimal expected = {{200001, 0, 0, 0}};
  set_scale(&expected, 9);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание отрицательного и положительного дробных чисел
}
END_TEST

START_TEST(sub_negative_and_positive_float) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_sign(&value_1, minus);
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result;
  s21_decimal expected = {{200001, 0, 0, 0x80000000}};
  set_scale(&expected, 9);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание положительных дробного и целого
}
END_TEST

START_TEST(sub_positive_float_int) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  s21_decimal result;
  s21_decimal expected = {{2820130815U, 4, 0, 0x80000000}};
  set_scale(&expected, 9);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание отрицательных дробного и целого
}
END_TEST

START_TEST(sub_negative_float_int) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_sign(&value_1, minus);
  set_sign(&value_2, minus);
  set_scale(&value_1, 10);
  s21_decimal result;
  s21_decimal expected = {{2820130815U, 4, 0, 0}};
  set_scale(&expected, 9);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание отрицательного дробного и положительного целого
}
END_TEST

START_TEST(sub_negative_float_positive_int) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_sign(&value_1, minus);
  set_scale(&value_1, 10);
  s21_decimal result;
  s21_decimal expected = {{2820130817U, 4, 0, 0x80000000}};
  set_scale(&expected, 9);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание положительного дробного и отрицательного целого
}
END_TEST

START_TEST(sub_positive_float_negative_int) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  set_sign(&value_2, minus);
  s21_decimal result;
  s21_decimal expected = {{2820130817U, 4, 0, 0}};
  set_scale(&expected, 9);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание положительного целого и отрицательного дробного
}
END_TEST

START_TEST(sub_positive_int_negative_float) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_sign(&value_2, minus);
  set_scale(&value_2, 5);
  s21_decimal result;
  s21_decimal expected = {{100002, 0, 0, 0}};
  set_scale(&expected, 4);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание отрицательного целого и положительного дробного
}
END_TEST

START_TEST(sub_negative_int_positive_float) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_sign(&value_1, minus);
  set_scale(&value_2, 5);
  s21_decimal result;
  s21_decimal expected = {{100002, 0, 0, 0x80000000}};
  set_scale(&expected, 4);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание максимального отрицательного из максимального
  // положительного
}
END_TEST

START_TEST(sub_overflow) {
  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  set_sign(&value_1, minus);
  s21_decimal result;

  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(return_code == 2);

  // Функция s21_sub вычитание минимального отрицательного и максимального
  // положительного
}
END_TEST

START_TEST(sub_overflow_two) {
  s21_decimal value_1 = {{1, 0, 0, 0}};
  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  set_sign(&value_1, minus);
  s21_decimal result;

  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(return_code == 2);

  // Функция s21_sub вычитание максимального отрицательного и минимального
  // положительного
}
END_TEST

START_TEST(sub_overflow_negative) {
  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal value_2 = {{1, 0, 0, 0}};
  set_sign(&value_1, minus);
  s21_decimal result;

  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(return_code == 2);

  // Функция s21_sub вычитание нулей
}
END_TEST

START_TEST(sub_positive_numbers_zero) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  s21_decimal result;
  s21_decimal expected = {{0, 0, 0, 0}};
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание нулей
}
END_TEST

START_TEST(sub_positive_and_negative_zero) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  set_sign(&value_2, minus);
  s21_decimal result;
  s21_decimal expected = {{0, 0, 0, 0}};
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание нулей
}
END_TEST

START_TEST(sub_negative_and_positive_zero) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  set_sign(&value_1, minus);
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-0", &expected);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание нулей
}
END_TEST

START_TEST(sub_negative_numbers_zero) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  set_sign(&value_1, minus);
  set_sign(&value_2, minus);
  s21_decimal expected = {{0, 0, 0, 0}};
  s21_decimal result;
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание положительных чисел с большим скейлом
}
END_TEST

START_TEST(sub_positive_float_big_scale) {
  s21_decimal value_1 = {{1, 0, 0, 0}};
  s21_decimal value_2 = {{2, 0, 0, 0}};
  set_scale(&value_1, MAX_SCALE);
  set_scale(&value_2, 27);
  s21_decimal result;
  s21_decimal expected = {{19, 0, 0, 0x80000000}};
  set_scale(&expected, 28);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание отрицательных чисел с большим скейлом
}
END_TEST

START_TEST(sub_negative_float_big_scale) {
  s21_decimal value_1 = {{1, 0, 0, 0}};
  s21_decimal value_2 = {{2, 0, 0, 0}};
  set_sign(&value_1, minus);
  set_sign(&value_2, minus);
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result;
  s21_decimal expected = {{19, 0, 0, 0}};
  set_scale(&expected, 28);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание отрицательного и положительного чисел с большим
  // скейлом
}
END_TEST

START_TEST(sub_negative_and_positive_float_big_scale) {
  s21_decimal value_1 = {{1, 0, 0, 0}};
  s21_decimal value_2 = {{2, 0, 0, 0}};
  set_sign(&value_1, minus);
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result;
  s21_decimal expected = {{21, 0, 0, 0x80000000}};
  set_scale(&expected, 28);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание полоижтельного и отрицательного чисел с большим
  // скейлом
}
END_TEST

START_TEST(sub_positive_and_negative_float_big_scale) {
  s21_decimal value_1 = {{1, 0, 0, 0}};
  s21_decimal value_2 = {{2, 0, 0, 0}};
  set_sign(&value_2, minus);
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result;
  s21_decimal expected = {{21, 0, 0, 0}};
  set_scale(&expected, 28);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание положительного числа и нуля
}
END_TEST

START_TEST(sub_positive_numbers_and_zero) {
  s21_decimal value_1 = {{15, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  s21_decimal result;
  s21_decimal expected = {{15, 0, 0, 0}};
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание нуля и положительного числа
}
END_TEST

START_TEST(sub_zero_and_positive_numbers) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{15, 0, 0, 0}};
  s21_decimal result;
  s21_decimal expected = {{15, 0, 0, 0}};
  set_sign(&expected, minus);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание положительного дробного и нуля
}
END_TEST

START_TEST(sub_positive_float_and_zero) {
  s21_decimal value_1 = {{15, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  set_scale(&value_1, 7);
  s21_decimal result;
  s21_decimal expected = {{15, 0, 0, 0}};
  set_scale(&expected, 7);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание нуля и положительного дробного
}
END_TEST

START_TEST(sub_zero_and_positive_float) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{15, 0, 0, 0}};
  set_scale(&value_2, 7);
  s21_decimal result;
  s21_decimal expected = {{15, 0, 0, 0}};
  set_scale(&expected, 7);
  set_sign(&expected, minus);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание отрицательного числа и нуля
}
END_TEST

START_TEST(sub_negative_numbers_and_zero) {
  s21_decimal value_1 = {{15, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  set_sign(&value_1, minus);
  s21_decimal result;
  s21_decimal expected = {{15, 0, 0, 0}};
  set_sign(&expected, minus);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание нуля и отрицательного числа
}
END_TEST

START_TEST(sub_zero_and_negative_numbers) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{15, 0, 0, 0}};
  set_sign(&value_2, minus);
  s21_decimal result;
  s21_decimal expected = {{15, 0, 0, 0}};
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание отрицательного дробного и нуля
}
END_TEST

START_TEST(sub_negative_float_and_zero) {
  s21_decimal value_1 = {{15, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  set_scale(&value_1, 7);
  set_sign(&value_1, minus);

  s21_decimal result;
  s21_decimal expected = {{15, 0, 0, 0x80000000}};
  set_scale(&expected, 7);
  set_sign(&value_1, minus);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание нуля и отрицательного дробного
}
END_TEST

START_TEST(sub_zero_and_negative_float) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{15, 0, 0, 0}};
  set_scale(&value_2, 7);
  set_sign(&value_2, minus);
  s21_decimal result;
  s21_decimal expected = {{15, 0, 0, 0}};
  set_scale(&expected, 7);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // s21_mul
  // s21_mul
  // Функция s21_mul умножение двух положительных чисел
}
END_TEST

START_TEST(mul_positive_numbers) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  s21_decimal result;
  s21_decimal expected = {{200, 0, 0, 0}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение двух отрицательных чисел
}
END_TEST

START_TEST(mul_negative_numbers) {
  s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
  s21_decimal result;
  s21_decimal expected = {{200, 0, 0, 0}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение положительного и отрицательного чисел
}
END_TEST

START_TEST(mul_positive_and_negative) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
  s21_decimal result;
  s21_decimal expected = {{200, 0, 0, 0x80000000}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение отрицательного и положительного чисел
}
END_TEST

START_TEST(mul_negative_and_positive) {
  s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  s21_decimal result;
  s21_decimal expected = {{200, 0, 0, 0x80000000}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение двух положительных дробных
}
END_TEST

START_TEST(mul_positive_float) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result;
  s21_decimal expected = {{2, 0, 0, 0}};
  set_scale(&expected, 13);
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение двух отрицательных дробных
}
END_TEST

START_TEST(mul_negative_float) {
  s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result;
  s21_decimal expected = {{2, 0, 0, 0}};
  set_scale(&expected, 13);
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  //// Функция s21_mul умножение положительного и отрицательного дробных
}
END_TEST

START_TEST(mul_positive_and_negative_float) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result;
  s21_decimal expected = {{2, 0, 0, 0x80000000}};
  set_scale(&expected, 13);
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение отрицательного и положительного дробных
}
END_TEST

START_TEST(mul_negative_and_positive_float) {
  s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result;
  s21_decimal expected = {{2, 0, 0, 0x80000000}};
  set_scale(&expected, 13);
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение положительного дробного и целого
}
END_TEST

START_TEST(mul_positive_float_int) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  s21_decimal result;
  s21_decimal expected = {{2, 0, 0, 0}};
  set_scale(&expected, 8);
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение отрицательного дробного и целого
}
END_TEST

START_TEST(mul_negative_float_int) {
  s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
  set_scale(&value_1, 10);
  s21_decimal result;
  s21_decimal expected = {{2, 0, 0, 0}};
  set_scale(&expected, 8);
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение отрицательного дробного и положительного целого
}
END_TEST

START_TEST(mul_negative_float_positive_int) {
  s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  s21_decimal result;
  s21_decimal expected = {{2, 0, 0, 0x80000000}};
  set_scale(&expected, 8);
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение положительного дробного и отрицательного целого
}
END_TEST

START_TEST(mul_positive_float_negative_int) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
  set_scale(&value_1, 10);
  s21_decimal result;
  s21_decimal expected = {{2, 0, 0, 0x80000000}};
  set_scale(&expected, 8);
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение положительного целого отрицательного дробного
}
END_TEST

START_TEST(mul_positive_int_negative_float) {
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
  set_scale(&value_2, 5);
  s21_decimal result;
  s21_decimal expected = {{2, 0, 0, 0x80000000}};
  set_scale(&expected, 3);
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение отрицательного целого положительного дробного
}
END_TEST

START_TEST(mul_negative_int_positive_float) {
  s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_scale(&value_2, 5);
  s21_decimal result;
  s21_decimal expected = {{2, 0, 0, 0x80000000}};
  int return_code = s21_mul(value_1, value_2, &result);
  set_scale(&expected, 3);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul очень большое число и маленькое - переполнение
}
END_TEST

START_TEST(mul_overflow) {
  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal value_2 = {{2, 0, 0, 0}};
  s21_decimal result;

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 1);

  // Функция s21_mul умножение очень маленького и очень большого - переполнение
}
END_TEST

START_TEST(mul_overflow_two) {
  s21_decimal value_1 = {{2, 0, 0, 0}};
  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal result;

  int return_code = s21_mul(value_1, value_2, &result);
  ck_assert(return_code == 1);

  // Функция s21_mul умножение двух очень больших - переполнение
}
END_TEST

START_TEST(mul_overflow_three) {
  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal result;

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 1);

  // Функция s21_mul умножение двух очень больших отрицательное и положительное
  // - переполнение
}
END_TEST

START_TEST(mul_overflow_four) {
  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal result;

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 2);

  // Функция s21_mul умножение двух очень больших положительное и отрицательное
  // - переполнение
}
END_TEST

START_TEST(mul_overflow_five) {
  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  s21_decimal result;

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 2);

  // Функция s21_mul умножение отрицательных очень большое число и маленькое -
  // переполнение
}
END_TEST

START_TEST(mul_overflow_negative) {
  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  s21_decimal value_2 = {{2, 0, 0, 0x80000000}};
  s21_decimal result;

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 1);

  // Функция s21_mul умножение отрицательных очень маленького и очень большого -
  // переполнение
}
END_TEST

START_TEST(mul_overflow_negative_two) {
  s21_decimal value_1 = {{2, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  s21_decimal result;

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 1);

  // Функция s21_mul умножение отрицательных двух очень больших - переполнение
}
END_TEST

START_TEST(mul_overflow_negative_three) {
  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  s21_decimal result;

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 1);

  // Функция s21_mul умножение двух нулей
}
END_TEST

START_TEST(mul_positive_numbers_zero) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  s21_decimal result;
  s21_decimal expected = {{0, 0, 0, 0}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение положительного и отрицательного нуля
}
END_TEST

START_TEST(mul_positive_and_negative_zero) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0x80000000}};
  s21_decimal result;
  s21_decimal expected = {{0, 0, 0, 0x80000000}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение отрицательного и положительного нуля
}
END_TEST

START_TEST(mul_negative_and_positive_zero) {
  s21_decimal value_1 = {{0, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  s21_decimal result;
  s21_decimal expected = {{0, 0, 0, 0x80000000}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение отрицательных нулей
}
END_TEST

START_TEST(mul_negative_numbers_zero) {
  s21_decimal value_1 = {{0, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{0, 0, 0, 0x80000000}};
  s21_decimal result;

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 0);

  // Функция s21_mul умножение положительного числа и нуля
}
END_TEST

START_TEST(mul_positive_numbers_and_zero) {
  s21_decimal value_1 = {{15, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  s21_decimal result;
  s21_decimal expected = {{0, 0, 0, 0}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение нуля и положительного числа
}
END_TEST

START_TEST(mul_zero_and_positive_numbers) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{15, 0, 0, 0}};
  s21_decimal result;
  s21_decimal expected = {{0, 0, 0, 0}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение положительного дробного и нуля
}
END_TEST

START_TEST(mul_positive_float_and_zero) {
  s21_decimal value_1 = {{15, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  set_scale(&value_1, 7);
  s21_decimal result;
  s21_decimal expected = {{0, 0, 0, 0}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение нуля и положительного дробного
}
END_TEST

START_TEST(mul_zero_and_positive_float) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{15, 0, 0, 0}};
  set_scale(&value_2, 7);
  s21_decimal result;
  s21_decimal expected = {{0, 0, 0, 0}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение отрицательного числа и нуля
}
END_TEST

START_TEST(mul_negative_numbers_and_zero) {
  s21_decimal value_1 = {{15, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  s21_decimal result;
  s21_decimal expected = {{0, 0, 0, 0x80000000}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение нуля и отрицательного числа
}
END_TEST

START_TEST(mul_zero_and_negative_numbers) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{15, 0, 0, 0x80000000}};
  s21_decimal result;
  s21_decimal expected = {{0, 0, 0, 0x80000000}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение отрицательного дробного и нуля
}
END_TEST

START_TEST(mul_negative_float_and_zero) {
  s21_decimal value_1 = {{15, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  set_scale(&value_1, 7);
  s21_decimal result;
  s21_decimal expected = {{0, 0, 0, 0x80000000}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение нуля и отрицательного дробного
}
END_TEST

START_TEST(mul_zero_and_negative_float) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{15, 0, 0, 0x80000000}};
  set_scale(&value_2, 7);
  s21_decimal result;
  s21_decimal expected = {{0, 0, 0, 0x80000000}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение двух положительных чисел с большой мантиссой
}
END_TEST

START_TEST(mul_positive_float_big_scale) {
  s21_decimal value_1 = {{1, 0, 0, 0}};
  s21_decimal value_2 = {{2, 0, 0, 0}};
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result;

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 1);

  // Функция s21_mul умножение двух отрицательных чисел с большой мантиссой
}
END_TEST

START_TEST(mul_negative_float_big_scale) {
  s21_decimal value_1 = {{1, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{2, 0, 0, 0x80000000}};
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result;

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 1);

  // Функция s21_mul умножение отрицательного и положительного с большой
  /// мантиссой
}
END_TEST

START_TEST(mul_negative_and_positive_float_big_scale) {
  s21_decimal value_1 = {{1, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{2, 0, 0, 0}};
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result;

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 2);

  // Функция s21_mul умножение положительного и отрицательного с большой
  /// мантиссой
}
END_TEST

START_TEST(mul_positive_and_negative_float_big_scale) {
  s21_decimal value_1 = {{1, 0, 0, 0}};
  s21_decimal value_2 = {{2, 0, 0, 0x80000000}};
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result;

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 2);

  // Функция s21_mul умножение двух положительных чисел с большой мантиссой с
  // ненулевыми разрядами
}
END_TEST

START_TEST(mul_positive_float_big_scale_not_zero) {
  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result;

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 1);

  // Функция s21_mul умножение двух отрицательных чисел с большой мантиссой с
  // ненулевыми разрядами
}
END_TEST

START_TEST(mul_negative_float_big_scale_not_zero) {
  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result;

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 1);

  // Функция s21_mul умножение отрицательного и положительного с большой
  // мантиссой / с ненулевыми разрядами
}
END_TEST

START_TEST(mul_negative_and_positive_float_big_scale_not_zero) {
  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result;

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 2);

  // Функция s21_mul умножение положительного и отрицательного с большой
  // мантиссой / с ненулевыми разрядами
}
END_TEST

START_TEST(mul_positive_and_negative_float_big_scale_not_zero) {
  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result;

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 2);

  // Функция s21_mul умножение целые большие числа с нулями
  // Функция s21_mul очень большое целое число на очень маленькое число с
  // плавающей точкой (отриц и положит)

  // Функция s21_mul умножение двух положительных дробных результат 5
}
END_TEST

START_TEST(mul_positive_float__) {
  s21_decimal value_1 = {{50, 0, 0, 0}};
  s21_decimal value_2 = {{10, 0, 0, 0}};
  set_scale(&value_2, 2);
  s21_decimal result;
  s21_decimal expected = {{5, 0, 0, 0}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение двух положительных дробных результат 5
}
END_TEST

START_TEST(mul_positive_float____) {
  s21_decimal value_1 = {{5, 0, 0, 0}};
  s21_decimal value_2 = {{10, 0, 0, 0}};
  set_scale(&value_2, 1);
  s21_decimal result;
  s21_decimal expected = {{5, 0, 0, 0}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция void alignment
}
END_TEST

START_TEST(alignment_both_zero_with_scale) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  set_scale(&value_1, MAX_SCALE);
  set_scale(&value_2, 27);
  alignment(&value_1, &value_2, 1);

  s21_decimal expected1 = {{0, 0, 0, 0}};
  s21_decimal expected2 = {{0, 0, 0, 0}};
  set_scale(&expected1, 0);
  set_scale(&expected2, 0);

  ck_assert(s21_is_equal(value_1, expected1) == 1);
  ck_assert(s21_is_equal(value_2, expected2) == 1);

  // Функция void alignment
}
END_TEST

START_TEST(alignment_both_zero_without_scale) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};

  alignment(&value_1, &value_2, 1);

  s21_decimal expected1 = {{0, 0, 0, 0}};
  s21_decimal expected2 = {{0, 0, 0, 0}};

  ck_assert(s21_is_equal(value_1, expected1) == 1);
  ck_assert(s21_is_equal(value_2, expected2) == 1);

  // Функция void alignment
}
END_TEST

START_TEST(alignment_both_zero_without_scale_and_with_scale) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  set_scale(&value_2, MAX_SCALE);

  alignment(&value_1, &value_2, 1);

  s21_decimal expected1 = {{0, 0, 0, 0}};
  s21_decimal expected2 = {{0, 0, 0, 0}};
  set_scale(&expected2, 0);

  ck_assert(s21_is_equal(value_1, expected1) == 1);
  ck_assert(s21_is_equal(value_2, expected2) == 1);

  // Функция void alignment
}
END_TEST

START_TEST(alignment_both_zero_with_scale_and_without_scale) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  set_scale(&value_1, MAX_SCALE);

  alignment(&value_1, &value_2, 1);

  s21_decimal expected1 = {{0, 0, 0, 0}};
  s21_decimal expected2 = {{0, 0, 0, 0}};
  set_scale(&expected1, 0);

  ck_assert(s21_is_equal(value_1, expected1) == 1);
  ck_assert(s21_is_equal(value_2, expected2) == 1);

  // Функция void alignment
}
END_TEST

START_TEST(alignment_float_with_zero_and_int) {
  s21_decimal value_1 = {{1234000, 0, 0, 0}};
  s21_decimal value_2 = {{5678, 0, 0, 0}};
  set_scale(&value_1, 7);
  set_scale(&value_2, 0);

  alignment(&value_1, &value_2, 1);

  s21_decimal expected1 = {{1234, 0, 0, 0}};
  s21_decimal expected2 = {{56780000, 0, 0, 0}};
  set_scale(&expected1, 4);
  set_scale(&expected2, 4);

  ck_assert(s21_is_equal(value_1, expected1) == 1);
  ck_assert(s21_is_equal(value_2, expected2) == 1);

  // Функция void alignment
}
END_TEST

START_TEST(alignment_int_and_float_with_zero) {
  s21_decimal value_1 = {{1234, 0, 0, 0}};
  s21_decimal value_2 = {{5678000, 0, 0, 0}};
  set_scale(&value_1, 0);
  set_scale(&value_2, 7);

  alignment(&value_1, &value_2, 1);

  s21_decimal expected1 = {{12340000, 0, 0, 0}};
  s21_decimal expected2 = {{5678, 0, 0, 0}};
  set_scale(&expected1, 4);
  set_scale(&expected2, 4);

  ck_assert(s21_is_equal(value_1, expected1) == 1);
  ck_assert(s21_is_equal(value_2, expected2) == 1);

  // Функция void alignment
}
END_TEST

START_TEST(alignment_big_float_big_scale_and_min_scale_) {
  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  set_scale(&value_1, MAX_SCALE);
  set_scale(&value_2, 1);
  alignment(&value_1, &value_2, 1);

  s21_decimal expected1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal expected2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  set_scale(&expected1, 28);
  set_scale(&expected2, 28);

  ck_assert(s21_is_equal(value_1, expected1) == 1);
  ck_assert(s21_is_equal(value_2, expected2) == 1);

  // Функция void alignment
}
END_TEST

START_TEST(alignment_big_float_min_scale_and_big_scale) {
  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  set_scale(&value_1, 1);
  set_scale(&value_2, MAX_SCALE);
  alignment(&value_1, &value_2, 1);

  s21_decimal expected1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal expected2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  set_scale(&expected1, 28);
  set_scale(&expected2, 28);

  ck_assert(s21_is_equal(value_1, expected1) == 1);
  ck_assert(s21_is_equal(value_2, expected2) == 1);

  // Функция void alignment
}
END_TEST

START_TEST(alignment_min_float_big_scale_and_min_scale_) {
  s21_decimal value_1 = {{1, 0, 0, 0}};
  s21_decimal value_2 = {{1, 0, 0, 0}};
  set_scale(&value_1, MAX_SCALE);
  set_scale(&value_2, 1);
  alignment(&value_1, &value_2, 1);

  s21_decimal expected1 = {{1, 0, 0, 0}};
  s21_decimal expected2 = {{1, 0, 0, 0}};
  set_scale(&expected1, 28);
  set_scale(&expected2, 28);

  ck_assert(s21_is_equal(value_1, expected1) == 1);
  ck_assert(s21_is_equal(value_2, expected2) == 1);

  // Функция void alignment
}
END_TEST

START_TEST(alignment_min_float_min_scale_and_big_scale) {
  s21_decimal value_1 = {{1, 0, 0, 0}};
  s21_decimal value_2 = {{1, 0, 0, 0}};
  set_scale(&value_1, 1);
  set_scale(&value_2, MAX_SCALE);
  alignment(&value_1, &value_2, 1);

  s21_decimal expected1 = {{1, 0, 0, 0}};
  s21_decimal expected2 = {{1, 0, 0, 0}};
  set_scale(&expected1, 28);
  set_scale(&expected2, 28);

  ck_assert(s21_is_equal(value_1, expected1) == 1);
  ck_assert(s21_is_equal(value_2, expected2) == 1);
}
END_TEST

START_TEST(positive_s21_is_equal_00) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  bool result = s21_is_equal(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(positive_s21_is_equal_01) {
  s21_decimal value_1 = {{0, 500, 1, 0}};
  s21_decimal value_2 = {{0, 500, 1, 0}};
  set_sign(&value_1, minus);
  set_sign(&value_2, minus);
  set_scale(&value_1, 27);
  set_scale(&value_2, 27);
  bool result = s21_is_equal(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(negative_s21_is_equal_00) {
  s21_decimal value_1 = {{1, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  bool result = s21_is_equal(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(negative_s21_is_equal_01) {
  s21_decimal value_1 = {{1, 0, 0, 0}};
  s21_decimal value_2 = {{1, 0, 0, 0}};
  set_sign(&value_1, minus);
  bool result = s21_is_equal(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(negative_s21_is_equal_02) {
  s21_decimal value_1 = {{1, 0, 0, 0}};
  s21_decimal value_2 = {{1, 0, 0, 0}};
  set_scale(&value_1, 27);
  bool result = s21_is_equal(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(negative_s21_is_equal_03) {
  s21_decimal value_1 = {{0, 1, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  bool result = s21_is_equal(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(negative_s21_is_not_equal_00) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  bool result = s21_is_not_equal(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(negative_s21_is_not_equal_01) {
  s21_decimal value_1 = {{0, 500, 1, 0}};
  s21_decimal value_2 = {{0, 500, 1, 0}};
  set_sign(&value_1, minus);
  set_sign(&value_2, minus);
  set_scale(&value_1, 27);
  set_scale(&value_2, 27);
  bool result = s21_is_not_equal(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(positive_s21_is_not_equal_00) {
  s21_decimal value_1 = {{1, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  bool result = s21_is_not_equal(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(positive_s21_is_not_equal_01) {
  s21_decimal value_1 = {{1, 0, 0, 0}};
  s21_decimal value_2 = {{1, 0, 0, 0}};
  set_sign(&value_1, minus);
  bool result = s21_is_not_equal(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(positive_s21_is_not_equal_02) {
  s21_decimal value_1 = {{1, 0, 0, 0}};
  s21_decimal value_2 = {{1, 0, 0, 0}};
  set_scale(&value_1, 27);
  bool result = s21_is_not_equal(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(positive_s21_is_not_equal_03) {
  s21_decimal value_1 = {{0, 1, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  bool result = s21_is_not_equal(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(positive_s21_is_less_00) {
  s21_decimal value_1 = {{0, 1, 0, 0}};
  s21_decimal value_2 = {{0, 0, 1, 0}};
  bool result = s21_is_less(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(positive_s21_is_less_01) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 1, 0}};
  bool result = s21_is_less(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(positive_s21_is_less_02) {
  s21_decimal value_1 = {{0, 0, 1, 0}};
  s21_decimal value_2 = {{0, 0, 1, 0}};
  set_sign(&value_1, minus);
  bool result = s21_is_less(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(positive_s21_is_less_03) {
  s21_decimal value_1 = {{1, 0, 1, 0}};
  s21_decimal value_2 = {{1, 0, 1, 0}};
  set_scale(&value_1, 27);
  set_scale(&value_2, 26);
  bool result = s21_is_less(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(negative_s21_is_less_00) {
  s21_decimal value_1 = {{0, 0, 1, 0}};
  s21_decimal value_2 = {{0, 1, 0, 0}};
  bool result = s21_is_less(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(negative_s21_is_less_01) {
  s21_decimal value_1 = {{0, 0, 1, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  bool result = s21_is_less(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(negative_s21_is_less_02) {
  s21_decimal value_1 = {{0, 0, 1, 0}};
  s21_decimal value_2 = {{0, 0, 1, 0}};
  set_sign(&value_2, minus);
  bool result = s21_is_less(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(negative_s21_is_less_03) {
  s21_decimal value_1 = {{1, 0, 1, 0}};
  s21_decimal value_2 = {{1, 0, 1, 0}};
  set_scale(&value_1, 25);
  set_scale(&value_2, 26);
  bool result = s21_is_less(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(negative_s21_is_less_04) {
  s21_decimal value_1 = {{1, 0, 1, 0}};
  s21_decimal value_2 = {{1, 0, 1, 0}};
  bool result = s21_is_less(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(negative_s21_is_greater_00) {
  s21_decimal value_1 = {{0, 1, 0, 0}};
  s21_decimal value_2 = {{0, 0, 1, 0}};
  bool result = s21_is_greater(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(negative_s21_is_greater_01) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 1, 0}};
  bool result = s21_is_greater(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(negative_s21_is_greater_02) {
  s21_decimal value_1 = {{0, 0, 1, 0}};
  s21_decimal value_2 = {{0, 0, 1, 0}};
  set_sign(&value_1, minus);
  bool result = s21_is_greater(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(negative_s21_is_greater_03) {
  s21_decimal value_1 = {{1, 0, 1, 0}};
  s21_decimal value_2 = {{1, 0, 1, 0}};
  set_scale(&value_1, 27);
  set_scale(&value_2, 26);
  bool result = s21_is_greater(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(negative_s21_is_greater_04) {
  s21_decimal value_1 = {{1, 0, 1, 0}};
  s21_decimal value_2 = {{1, 0, 1, 0}};
  bool result = s21_is_greater(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(positive_s21_is_greater_00) {
  s21_decimal value_1 = {{0, 0, 1, 0}};
  s21_decimal value_2 = {{0, 1, 0, 0}};
  bool result = s21_is_greater(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(positive_s21_is_greater_01) {
  s21_decimal value_1 = {{0, 0, 1, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  bool result = s21_is_greater(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(positive_s21_is_greater_02) {
  s21_decimal value_1 = {{0, 0, 1, 0}};
  s21_decimal value_2 = {{0, 0, 1, 0}};
  set_sign(&value_2, minus);
  bool result = s21_is_greater(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(positive_s21_is_greater_03) {
  s21_decimal value_1 = {{1, 0, 1, 0}};
  s21_decimal value_2 = {{1, 0, 1, 0}};
  set_scale(&value_1, 25);
  set_scale(&value_2, 26);
  bool result = s21_is_greater(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(positive_s21_is_less_or_equal_000) {
  s21_decimal value_1 = {{1, 0, 1, 0}};
  s21_decimal value_2 = {{1, 0, 1, 0}};
  bool result = s21_is_less_or_equal(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(positive_s21_is_less_or_equal_00) {
  s21_decimal value_1 = {{0, 1, 0, 0}};
  s21_decimal value_2 = {{0, 0, 1, 0}};
  bool result = s21_is_less_or_equal(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(positive_s21_is_less_or_equal_01) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 1, 0}};
  bool result = s21_is_less_or_equal(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(positive_s21_is_less_or_equal_02) {
  s21_decimal value_1 = {{0, 0, 1, 0}};
  s21_decimal value_2 = {{0, 0, 1, 0}};
  set_sign(&value_1, minus);
  bool result = s21_is_less_or_equal(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(positive_s21_is_less_or_equal_03) {
  s21_decimal value_1 = {{1, 0, 1, 0}};
  s21_decimal value_2 = {{1, 0, 1, 0}};
  set_scale(&value_1, 27);
  set_scale(&value_2, 26);
  bool result = s21_is_less_or_equal(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(negative_s21_is_less_or_equal_00) {
  s21_decimal value_1 = {{0, 0, 1, 0}};
  s21_decimal value_2 = {{0, 1, 0, 0}};
  bool result = s21_is_less_or_equal(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(negative_s21_is_less_or_equal_01) {
  s21_decimal value_1 = {{0, 0, 1, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  bool result = s21_is_less_or_equal(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(negative_s21_is_less_or_equal_02) {
  s21_decimal value_1 = {{0, 0, 1, 0}};
  s21_decimal value_2 = {{0, 0, 1, 0}};
  set_sign(&value_2, minus);
  bool result = s21_is_less_or_equal(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(negative_s21_is_less_or_equal_03) {
  s21_decimal value_1 = {{1, 0, 1, 0}};
  s21_decimal value_2 = {{1, 0, 1, 0}};
  set_scale(&value_1, 25);
  set_scale(&value_2, 26);
  bool result = s21_is_less_or_equal(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(negative_s21_is_greater_or_equal_00) {
  s21_decimal value_1 = {{0, 1, 0, 0}};
  s21_decimal value_2 = {{0, 0, 1, 0}};
  bool result = s21_is_greater_or_equal(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(negative_s21_is_greater__or_equal01) {
  s21_decimal value_1 = {{0, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 1, 0}};
  bool result = s21_is_greater_or_equal(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(negative_s21_is_greater__or_equal02) {
  s21_decimal value_1 = {{0, 0, 1, 0}};
  s21_decimal value_2 = {{0, 0, 1, 0}};
  set_sign(&value_1, minus);
  bool result = s21_is_greater_or_equal(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(negative_s21_is_greater_or_equal_03) {
  s21_decimal value_1 = {{1, 0, 1, 0}};
  s21_decimal value_2 = {{1, 0, 1, 0}};
  set_scale(&value_1, 27);
  set_scale(&value_2, 26);
  bool result = s21_is_greater_or_equal(value_1, value_2);
  ck_assert(result == 0);
}
END_TEST

START_TEST(positive_s21_is_greater_or_equal_000) {
  s21_decimal value_1 = {{1, 0, 1, 0}};
  s21_decimal value_2 = {{1, 0, 1, 0}};
  bool result = s21_is_greater_or_equal(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(positive_s21_is_greater_or_equal_00) {
  s21_decimal value_1 = {{0, 0, 1, 0}};
  s21_decimal value_2 = {{0, 1, 0, 0}};
  bool result = s21_is_greater_or_equal(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(positive_s21_is_greater_or_equal_01) {
  s21_decimal value_1 = {{0, 0, 1, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  bool result = s21_is_greater_or_equal(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(positive_s21_is_greater_or_equal_02) {
  s21_decimal value_1 = {{0, 0, 1, 0}};
  s21_decimal value_2 = {{0, 0, 1, 0}};
  set_sign(&value_2, minus);
  bool result = s21_is_greater_or_equal(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(positive_s21_is_greater_or_equal_03) {
  s21_decimal value_1 = {{1, 0, 1, 0}};
  s21_decimal value_2 = {{1, 0, 1, 0}};
  set_scale(&value_1, 25);
  set_scale(&value_2, 26);
  bool result = s21_is_greater_or_equal(value_1, value_2);
  ck_assert(result == 1);
}
END_TEST

START_TEST(truncate_1) {
  s21_decimal value = {{25, 0, 0, 0}};
  s21_decimal result = {{0, 0, 0, 0}};
  s21_decimal expected = {{2, 0, 0, 0}};
  set_scale(&value, 1);
  set_scale(&expected, 0);
  s21_truncate(value, &result);
  int err_code = s21_is_equal(result, expected);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(truncate_2) {
  s21_decimal value = {{12345, 0, 0, 0}};
  s21_decimal result = {{0, 0, 0, 0}};
  s21_decimal expected = {{123, 0, 0, 0}};
  set_scale(&value, 2);
  set_scale(&expected, 0);
  s21_truncate(value, &result);
  int err_code = s21_is_equal(result, expected);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(truncate_3) {
  s21_decimal value = {{98765, 0, 0, 0}};
  s21_decimal result = {{0, 0, 0, 0}};
  s21_decimal expected = {{987, 0, 0, 0}};
  set_scale(&value, 2);
  set_scale(&expected, 0);
  s21_truncate(value, &result);
  int err_code = s21_is_equal(result, expected);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(truncate_4) {
  s21_decimal value = {{1000, 0, 0, 0}};
  s21_decimal result = {{0, 0, 0, 0}};
  s21_decimal expected = {{10, 0, 0, 0}};
  set_scale(&value, 2);
  set_scale(&expected, 0);
  s21_truncate(value, &result);
  int err_code = s21_is_equal(result, expected);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(truncate_5) {
  s21_decimal value = {{250, 0, 0, 0}};
  s21_decimal result = {{0, 0, 0, 0}};
  s21_decimal expected = {{25, 0, 0, 0}};
  set_sign(&value, minus);
  set_sign(&expected, minus);
  set_scale(&value, 1);
  set_scale(&expected, 0);
  s21_truncate(value, &result);
  int err_code = s21_is_equal(result, expected);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(truncate_6) {
  s21_decimal value = {{123456789, 0, 0, 0}};
  s21_decimal result = {{0, 0, 0, 0}};
  s21_decimal expected = {{1234567, 0, 0, 0}};
  set_sign(&value, minus);
  set_sign(&expected, minus);
  set_scale(&value, 2);
  set_scale(&expected, 0);
  s21_truncate(value, &result);
  int err_code = s21_is_equal(result, expected);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(truncate_7) {
  s21_decimal value = {{0, 0, 0, 0}};
  s21_decimal result = {{0, 0, 0, 0}};
  s21_decimal expected = {{0, 0, 0, 0}};
  set_scale(&value, 3);
  set_scale(&expected, 0);
  s21_truncate(value, &result);
  int err_code = s21_is_equal(result, expected);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(truncate_8) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-171701", &value);
  str_to_decimal("-171701", &expected);
  int err_code = s21_truncate(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(truncate_9) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-0", &value);
  str_to_decimal("-0", &expected);
  int err_code = s21_truncate(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(truncate_10) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-0.1412132131231", &value);
  str_to_decimal("-0", &expected);
  int err_code = s21_truncate(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(truncate_11) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-4213213.21312", &value);
  str_to_decimal("-4213213", &expected);
  int err_code = s21_truncate(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(truncate_12) {
  s21_decimal value;
  s21_decimal result;
  set_scale(&value, 29);
  int err_code = s21_truncate(value, &result);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(truncate_13) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("79228162514264337593543950335", &value);
  str_to_decimal("79228162514264337593543950335", &expected);
  int err_code = s21_truncate(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(truncate_14) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-79228162514264337593543950335", &value);
  str_to_decimal("-79228162514264337593543950335", &expected);
  int err_code = s21_truncate(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(round_1) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-4213213.21312", &value);
  str_to_decimal("-4213213", &expected);
  int err_code = s21_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(round_2) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-4213213.71312", &value);
  str_to_decimal("-4213214", &expected);
  int err_code = s21_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(round_3) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-4213213.51312", &value);
  str_to_decimal("-4213214", &expected);
  int err_code = s21_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(round_4) {
  s21_decimal value;
  s21_decimal result;
  str_to_decimal("0", &value);
  set_scale(&value, 29);
  int err_code = s21_round(value, &result);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(round_5) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-0", &value);
  str_to_decimal("-0", &expected);
  int err_code = s21_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(round_6) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-0.4", &value);
  str_to_decimal("-0", &expected);
  int err_code = s21_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(round_7) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("79228162514264337593543950335", &value);
  str_to_decimal("79228162514264337593543950335", &expected);
  int err_code = s21_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(round_8) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-79228162514264337593543950335", &value);
  str_to_decimal("-79228162514264337593543950335", &expected);
  int err_code = s21_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(floor_1) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("4213213.21312", &value);
  str_to_decimal("4213213", &expected);
  int err_code = s21_floor(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(floor_2) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-4213213.71312", &value);
  str_to_decimal("-4213214", &expected);
  int err_code = s21_floor(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(floor_3) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-4213213.51312", &value);
  str_to_decimal("-4213214", &expected);
  int err_code = s21_floor(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(floor_4) {
  s21_decimal value;
  s21_decimal result;
  str_to_decimal("0", &value);
  set_scale(&value, 29);
  int err_code = s21_floor(value, &result);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(floor_5) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-0", &value);
  str_to_decimal("-0", &expected);
  int err_code = s21_floor(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(floor_6) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-0.4", &value);
  str_to_decimal("-1", &expected);
  int err_code = s21_floor(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(floor_7) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("79228162514264337593543950335", &value);
  str_to_decimal("79228162514264337593543950335", &expected);
  int err_code = s21_floor(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(floor_8) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-79228162514264337593543950335", &value);
  str_to_decimal("-79228162514264337593543950335", &expected);
  int err_code = s21_floor(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(floor_9) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-7922816251426433759354395033.5", &value);
  str_to_decimal("-7922816251426433759354395034", &expected);
  int err_code = s21_floor(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(floor_10) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-4213213.001", &value);
  str_to_decimal("-4213214", &expected);
  int err_code = s21_floor(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(bank_round_1) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("4213213.21312", &value);
  str_to_decimal("4213213", &expected);
  int err_code = bank_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(bank_round_2) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-4213213.71312", &value);
  str_to_decimal("-4213214", &expected);
  int err_code = bank_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(bank_round_3) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-4213213.51312", &value);
  str_to_decimal("-4213214", &expected);
  int err_code = bank_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(bank_round_4) {
  s21_decimal value;
  s21_decimal result;
  str_to_decimal("0", &value);
  set_scale(&value, 29);
  int err_code = bank_round(value, &result);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(bank_round_5) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-0", &value);
  str_to_decimal("-0", &expected);
  int err_code = bank_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(bank_round_6) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-0.4", &value);
  str_to_decimal("-0", &expected);
  int err_code = bank_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(bank_round_7) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("79228162514264337593543950335", &value);
  str_to_decimal("79228162514264337593543950335", &expected);
  int err_code = bank_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(bank_round_8) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-79228162514264337593543950335", &value);
  str_to_decimal("-79228162514264337593543950335", &expected);
  int err_code = bank_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(bank_round_9) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-7922816251426433759354395033.5", &value);
  str_to_decimal("-7922816251426433759354395034", &expected);
  int err_code = bank_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(bank_round_10) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-4213213.001", &value);
  str_to_decimal("-4213213", &expected);
  int err_code = bank_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(bank_round_11) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-4213213.51", &value);
  str_to_decimal("-4213214", &expected);
  int err_code = bank_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(bank_round_12) {
  s21_decimal value;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-4213214.5", &value);
  str_to_decimal("-4213214", &expected);
  int err_code = bank_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(truncate_positive_float) {
  s21_decimal value = {{12345, 0, 0, 0}};
  s21_decimal result;
  s21_decimal expected = {{123, 0, 0, 0}};
  set_scale(&value, 2);
  set_scale(&expected, 0);
  int return_code = s21_truncate(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div - деление двух положительных дробных
}
END_TEST

START_TEST(div_positive_float1) {
  s21_decimal value_1 = {{100, 0, 0, 0}};
  s21_decimal value_2 = {{25, 0, 0, 0}};
  s21_decimal result;
  s21_decimal expected = {{4, 0, 0, 0}};
  set_scale(&value_1, 2);
  set_scale(&value_2, 2);
  set_scale(&expected, 0);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div - деление двух отрицательных дробных
}
END_TEST

START_TEST(div_negative_float2) {
  s21_decimal value_1 = {{100, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{25, 0, 0, 0x80000000}};
  s21_decimal result;
  s21_decimal expected = {{4, 0, 0, 0}};
  set_scale(&value_1, 2);
  set_scale(&value_2, 2);
  set_scale(&expected, 0);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div - деление положительного на отрицательное
}
END_TEST

START_TEST(div_positive_negative3) {
  s21_decimal value_1 = {{100, 0, 0, 0}};
  s21_decimal value_2 = {{25, 0, 0, 0x80000000}};
  s21_decimal result;
  s21_decimal expected = {{4, 0, 0, 0}};
  set_scale(&value_1, 2);
  set_scale(&value_2, 2);
  set_scale(&expected, 0);
  set_sign(&expected, minus);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div - деление отрицательного на положительное
}
END_TEST

START_TEST(div_negative_positive4) {
  s21_decimal value_1 = {{100, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{25, 0, 0, 0}};
  s21_decimal result;
  s21_decimal expected = {{4, 0, 0, 0x80000000}};
  set_scale(&value_1, 2);
  set_scale(&value_2, 2);
  set_scale(&expected, 0);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);
}
END_TEST

START_TEST(div_by_zero) {
  s21_decimal value_1 = {{100, 0, 0, 0}};
  s21_decimal value_2 = {{0, 0, 0, 0}};
  s21_decimal result;
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(return_code == 3);
}
END_TEST

START_TEST(s21_negate1) {
  s21_decimal value;
  s21_decimal expected;
  str_to_decimal("171701", &value);
  str_to_decimal("-171701", &expected);
  int err_code = s21_negate(value, &value);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(s21_negate2) {
  s21_decimal value;
  s21_decimal expected;
  str_to_decimal("-171701", &value);
  str_to_decimal("171701", &expected);
  int err_code = s21_negate(value, &value);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(s21_negate3) {
  s21_decimal value;
  s21_decimal expected;
  str_to_decimal("-171701.31231213", &value);
  str_to_decimal("171701.31231213", &expected);
  int err_code = s21_negate(value, &value);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(s21_negate4) {
  // negate есть умножение на -1
  s21_decimal value;
  s21_decimal expected;
  str_to_decimal("-0", &value);
  str_to_decimal("0", &expected);
  int err_code = s21_negate(value, &value);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(s21_negate5) {
  s21_decimal value;
  s21_decimal expected;
  str_to_decimal("0", &value);
  str_to_decimal("-0", &expected);
  int err_code = s21_negate(value, &value);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(s21_negate6) {
  s21_decimal value;
  s21_decimal expected;
  str_to_decimal("79228162514264337593543950335", &value);
  str_to_decimal("-79228162514264337593543950335", &expected);
  int err_code = s21_negate(value, &value);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(s21_negate7) {
  s21_decimal value;
  s21_decimal expected;
  str_to_decimal("-79228162514264337593543950335", &value);
  str_to_decimal("79228162514264337593543950335", &expected);
  int err_code = s21_negate(value, &value);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(s21_negate8) {
  s21_decimal value;
  s21_decimal expected;
  str_to_decimal("-7922816251426.4337593543950335", &value);
  str_to_decimal("7922816251426.4337593543950335", &expected);
  int err_code = s21_negate(value, &value);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(s21_negate9) {
  s21_decimal value;
  s21_decimal expected;
  str_to_decimal("79228162514264337593543950.335", &value);
  str_to_decimal("-79228162514264337593543950.335", &expected);
  int err_code = s21_negate(value, &value);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(inf_div) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("20", &value_1);
  str_to_decimal("7", &value_2);
  str_to_decimal("2.8571428571428571428571428571", &expected);
  int return_code = s21_div(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);
}
END_TEST

START_TEST(neginf_div) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("-20", &value_1);
  str_to_decimal("7", &value_2);
  str_to_decimal("-2.8571428571428571428571428571", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);
}
END_TEST

START_TEST(div2) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("171701", &value_1);
  str_to_decimal("200000", &value_2);
  str_to_decimal("858505", &expected);
  set_scale(&expected, 6);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);
}
END_TEST

START_TEST(div3) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal(MAX_DECIMAL, &value_1);
  str_to_decimal("1000000000", &value_2);
  str_to_decimal(MAX_DECIMAL, &expected);
  set_scale(&expected, 9);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);
}
END_TEST

START_TEST(div4) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("1432345362332124431467430", &value_1);
  str_to_decimal("320", &value_2);
  str_to_decimal("447607925728788884833571875", &expected);
  set_scale(&expected, 5);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);
}
END_TEST

START_TEST(from_float_to_decimal_1) {
  float fvalue = -79228157791897854723898736640.f;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-79228160000000000000000000000", &expected);
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(from_float_to_decimal_2) {
  float fvalue = 0.123456f;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("0.123456", &expected);
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(from_float_to_decimal_3) {
  float fvalue_inf = INFINITY;
  s21_decimal result_inf;
  s21_decimal expected_inf;
  str_to_decimal("0", &expected_inf);
  int err_code = s21_from_float_to_decimal(fvalue_inf, &result_inf);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(from_float_to_decimal_4) {
  float fvalue_neg_inf = -INFINITY;
  s21_decimal result_neg_inf;
  s21_decimal expected_neg_inf;
  str_to_decimal("0", &expected_neg_inf);
  int err_code = s21_from_float_to_decimal(fvalue_neg_inf, &result_neg_inf);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(from_float_to_decimal_5) {
  float fvalue_nan = NAN;
  s21_decimal result_nan;
  s21_decimal expected_nan;
  str_to_decimal("0", &expected_nan);
  int err_code = s21_from_float_to_decimal(fvalue_nan, &result_nan);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(from_float_to_decimal_6) {
  float fvalue = 12345;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("12345", &expected);
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(from_float_to_decimal_7) {
  float fvalue = 0.12345678;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("0.1234568", &expected);
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(from_float_to_decimal_8) {
  float fvalue = 0.12345671;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("0.1234567", &expected);
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(from_float_to_decimal_9) {
  float fvalue = 0.12345;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("0.12345", &expected);
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(from_float_to_decimal_10) {
  float fvalue = 0.f;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("0", &expected);
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(from_float_to_decimal_11) {
  float fvalue = -11111111.123123;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-11111110", &expected);
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(from_float_to_decimal_12) {
  float fvalue = 11111.123123;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("11111.12", &expected);
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(from_float_to_decimal_13) {
  float fvalue = -11111.129123;
  s21_decimal result;
  s21_decimal expected;
  str_to_decimal("-11111.13", &expected);
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(from_float_to_decimal_14) {
  float fvalue = 79228162514264337593543950336.f;
  s21_decimal result;
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(from_float_to_decimal_15) {
  float fvalue = 1e-29;
  s21_decimal result;
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(from_float_to_decimal_16) {
  float fvalue = 792281625142643375935439503351.f;
  s21_decimal result;
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(from_float_to_decimal_17) {
  float fvalue = -0.f;
  s21_decimal result;
  s21_decimal expected;
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  str_to_decimal("-0", &expected);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(from_decimal_to_float_1) {
  s21_decimal value_1 = {{0}};
  float result = 0;
  str_to_decimal("78123", &value_1);
  int err_code = s21_from_decimal_to_float(value_1, &result);
  ck_assert(0 == err_code);
  ck_assert(78123.0 == result);
}
END_TEST

START_TEST(from_decimal_to_float_2) {
  s21_decimal value_1 = {{0}};
  float result = 0;
  str_to_decimal("781865", &value_1);
  set_sign(&value_1, 1);
  int err_code = s21_from_decimal_to_float(value_1, &result);
  ck_assert(0 == err_code);
  ck_assert(-781865.0 == result);
}
END_TEST

START_TEST(from_decimal_to_float_3) {
  s21_decimal value_1 = {{0}};
  float result = 0;
  str_to_decimal("6408.25", &value_1);
  set_sign(&value_1, 1);
  int err_code = s21_from_decimal_to_float(value_1, &result);
  ck_assert(0 == err_code);
  ck_assert(-6408.25 == result);
}
END_TEST

START_TEST(from_decimal_to_float_4) {
  s21_decimal value_1;
  float result = 0;
  str_to_decimal("-0", &value_1);
  int err_code = s21_from_decimal_to_float(value_1, &result);
  ck_assert(0 == err_code);
  ck_assert(-0.f == result);
}
END_TEST

START_TEST(from_decimal_to_float_5) {
  s21_decimal value_1;
  float result = 0;
  str_to_decimal("0", &value_1);
  int err_code = s21_from_decimal_to_float(value_1, &result);
  ck_assert(0 == err_code);
  ck_assert(0.f == result);
}
END_TEST

START_TEST(from_decimal_to_float_6) {
  s21_decimal value_1;
  float result = 0;
  str_to_decimal("0", &value_1);
  int err_code = s21_from_decimal_to_float(value_1, &result);
  ck_assert(0 == err_code);
  ck_assert(0.f == result);
}
END_TEST

START_TEST(from_decimal_to_float_7) {
  s21_decimal value_1;
  float result = 0;
  str_to_decimal("0", &value_1);
  int err_code = s21_from_decimal_to_float(value_1, &result);
  ck_assert(0 == err_code);
  ck_assert(0.f == result);
}
END_TEST

START_TEST(from_int_to_decimal_0) {
  int src = 6418934;
  s21_decimal value = {{0}};
  int err_code = s21_from_int_to_decimal(src, &value);
  s21_decimal expected = {{6418934, 0, 0, 0}};
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(from_int_to_decimal_1) {
  int src = -6418934;
  s21_decimal value = {{0}};
  int err_code = s21_from_int_to_decimal(src, &value);
  s21_decimal expected = {{6418934, 0, 0, 0}};
  set_sign(&expected, 1);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(from_int_to_decimal_2) {
  int src = 2147483647;
  s21_decimal value = {{0}};
  int err_code = s21_from_int_to_decimal(src, &value);
  s21_decimal expected = {{2147483647, 0, 0, 0}};
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(from_int_to_decimal_3) {
  int src = -2147483648;
  s21_decimal value = {{0}};
  int err_code = s21_from_int_to_decimal(src, &value);
  s21_decimal expected = {{2147483648U, 0, 0, 0}};
  set_sign(&expected, 1);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(from_int_to_decimal_4) {
  s21_decimal value;
  s21_decimal expected;
  int src = 0;
  str_to_decimal("0", &expected);
  int err_code = s21_from_int_to_decimal(src, &value);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(from_int_to_decimal_5) {
  s21_decimal value;
  s21_decimal expected;
  int src = -232432;
  str_to_decimal("-232432", &expected);
  int err_code = s21_from_int_to_decimal(src, &value);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(from_decimal_to_int_1) {
  int src = 0;
  s21_decimal value = {{2147483647, 1, 0, 0}};
  set_sign(&value, 1);
  int err_code = s21_from_decimal_to_int(value, &src);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(from_decimal_to_int_2) {
  int src = 0;
  s21_decimal value = {{2147483647, 1, 0, 0}};
  int err_code = s21_from_decimal_to_int(value, &src);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(from_decimal_to_int_3) {
  int src = 0;
  s21_decimal value;
  set_scale(&value, 3);
  str_to_decimal("0.001", &value);
  int err_code = s21_from_decimal_to_int(value, &src);
  ck_assert(src == 0);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(from_decimal_to_int_4) {
  int result = 0;
  s21_decimal value;
  str_to_decimal("-21474836.4", &value);
  int err_code = s21_from_decimal_to_int(value, &result);
  ck_assert(result == -21474836);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(from_decimal_to_int_5) {
  int result = 0;
  s21_decimal value;
  str_to_decimal("-21476.41212321121", &value);
  int err_code = s21_from_decimal_to_int(value, &result);
  ck_assert(result == -21476);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(from_decimal_to_int_6) {
  int result = 0;
  s21_decimal value;
  str_to_decimal("-214761312312", &value);
  int err_code = s21_from_decimal_to_int(value, &result);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(from_decimal_to_int_7) {
  int result = 0;
  s21_decimal value;
  str_to_decimal("214761312312", &value);
  int err_code = s21_from_decimal_to_int(value, &result);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(from_decimal_to_int_8) {
  int result = 0;
  s21_decimal value;
  str_to_decimal("-2.147611213123121", &value);
  int err_code = s21_from_decimal_to_int(value, &result);
  ck_assert(result == -2);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(from_decimal_to_int_9) {
  int src = 0;
  s21_decimal value = {{0, 0, 1, 0}};
  int err_code = s21_from_decimal_to_int(value, &src);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(big_to_decimal_0) {
  big_decimal value = {{0, 0, 0, 1, 0, 0, 0}};
  s21_decimal result = {{0}};
  int err_code = big_to_decimal(value, &result);
  ck_assert(err_code == 1);
}
END_TEST

START_TEST(big_to_decimal_1) {
  s21_decimal value_1 = {{1, 0, 0, 0}};
  set_sign(&value_1, 1);
  big_decimal value = {{0}};
  decimal_to_big(value_1, &value);
  value.bits[3] = 1;
  s21_decimal result = {{0}};
  int err_code = big_to_decimal(value, &result);
  ck_assert(err_code == 2);
}
END_TEST

START_TEST(big_to_decimal_2) {
  big_decimal value = {{0, 1, 0, 0, 0, 0, 0}};
  s21_decimal result = {{0}};
  int err_code = big_to_decimal(value, &result);
  ck_assert(result.bits[1] == 1);
  ck_assert(err_code == 0);
}
END_TEST

START_TEST(big_to_int_1) {
  big_decimal value = {{659865, 0, 0, 0, 0, 0, 0}};
  int result = big_to_int(value);
  int expected = 659865;
  ck_assert(result == expected);

  // Функция s21_add сложение с домножением нулей
}
END_TEST

START_TEST(add_multiplying_zeros) {
  s21_decimal value_1 = {{100, 0, 0, 0}};
  s21_decimal value_2 = {{1, 0, 0, 0}};
  set_scale(&value_2, 2);
  s21_decimal result;
  s21_decimal expected = {{10001, 0, 0, 0}};
  set_scale(&expected, 2);

  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub сложение с домножением нулей
}
END_TEST

START_TEST(sub_multiplying_zeros) {
  s21_decimal value_1 = {{100, 0, 0, 0}};
  s21_decimal value_2 = {{1, 0, 0, 0}};
  set_scale(&value_2, 2);
  s21_decimal result;
  s21_decimal expected = {{9999, 0, 0, 0}};
  set_scale(&expected, 2);

  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub переполнение с округлением
}
END_TEST

START_TEST(sub_overflow_bank_round) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("79228162514264337593543950335", &value_1);
  str_to_decimal("0.6", &value_2);
  str_to_decimal("79228162514264337593543950334", &expected);
  int return_code = s21_sub(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  //  ОКРУГЛЕНИЕ
  //  Функция s21_add сложение двух положительных чисел с большой мантиссой с
  //  ненулевыми разрядами
}
END_TEST

START_TEST(add_positive_float_big_scale_bank_round) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("7.9228162514264337593543950335", &value_1);
  str_to_decimal("79.28162514264337593543950335", &value_2);
  str_to_decimal("87.20444139406980969479389838", &expected);
  int return_code = s21_add(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение двух отрицательных чисел с большой мантиссой с
  // ненулевыми разрядами
}
END_TEST

START_TEST(add_negative_float_big_scale_bank_round) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("-7.9228162514264337593543950335", &value_1);
  str_to_decimal("-79.28162514264337593543950335", &value_2);
  str_to_decimal("-87.20444139406980969479389838", &expected);
  int return_code = s21_add(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение отрицательного и положительного с большой
  // мантиссой с ненулевыми разрядами
}
END_TEST

START_TEST(add_negative_and_positive_float_big_scale_bank_round) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("-7.9228162514264337593543950335", &value_1);
  str_to_decimal("79.28162514264337593543950335", &value_2);
  str_to_decimal("71.358808891216942176085108316", &expected);
  int return_code = s21_add(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение положительного и отрицательного с большой
  // мантиссой с ненулевыми разрядами
}
END_TEST

START_TEST(add_positive_and_negative_float_big_scale_bank_round) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("7.9228162514264337593543950335", &value_1);
  str_to_decimal("-79.28162514264337593543950335", &value_2);
  str_to_decimal("-71.358808891216942176085108316", &expected);
  int return_code = s21_add(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  //   Функция s21_sub вычитание двух положительных чисел с большой мантиссой с
  //   ненулевыми разрядами
}
END_TEST

START_TEST(sub_positive_float_big_scale_bank_round) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("7.9228162514264337593543950335", &value_1);
  str_to_decimal("79.28162514264337593543950335", &value_2);
  str_to_decimal("-71.358808891216942176085108316", &expected);
  int return_code = s21_sub(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание двух отрицательных чисел с большой мантиссой с
  // ненулевыми разрядами
}
END_TEST

START_TEST(sub_negative_float_big_scale_bank_round) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("-7.9228162514264337593543950335", &value_1);
  str_to_decimal("-79.28162514264337593543950335", &value_2);
  str_to_decimal("71.358808891216942176085108316", &expected);
  int return_code = s21_sub(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание отрицательного и положительного с большой
  // мантиссой с ненулевыми разрядами
}
END_TEST

START_TEST(sub_negative_and_positive_float_big_scale_bank_round) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("-7.9228162514264337593543950335", &value_1);
  str_to_decimal("79.28162514264337593543950335", &value_2);
  str_to_decimal("-87.20444139406980969479389838", &expected);
  int return_code = s21_sub(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание положительного и отрицательного с большой
  // мантиссой с ненулевыми разрядами
}
END_TEST

START_TEST(sub_positive_and_negative_float_big_scale_bank_round) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("7.9228162514264337593543950335", &value_1);
  str_to_decimal("-79.28162514264337593543950335", &value_2);
  str_to_decimal("87.20444139406980969479389838", &expected);
  int return_code = s21_sub(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  //   Функция s21_mul умножение двух положительных чисел с большой мантиссой с
  //   ненулевыми разрядами
}
END_TEST

START_TEST(mul_positive_float_big_scale_bank_round) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal result;
  str_to_decimal("7.9228162514264337593543950335", &value_1);
  str_to_decimal("79.28162514264337593543950335", &value_2);
  int return_code = s21_mul(value_1, value_2, &result);
  ck_assert(return_code == 1);

  // Функция s21_mul умножение двух отрицательных чисел с большой мантиссой с
  // ненулевыми разрядами
}
END_TEST

START_TEST(mul_negative_float_big_scale_bank_round) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal result;
  str_to_decimal("-7.9228162514264337593543950335", &value_1);
  str_to_decimal("-79.28162514264337593543950335", &value_2);
  int return_code = s21_mul(value_1, value_2, &result);
  ck_assert(return_code == 1);

  // Функция s21_mul умножение отрицательного и положительного с большой
  // мантиссой с ненулевыми разрядами
}
END_TEST

START_TEST(mul_negative_and_positive_float_big_scale_bank_round) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal result;
  str_to_decimal("-7.9228162514264337593543950335", &value_1);
  str_to_decimal("79.28162514264337593543950335", &value_2);
  int return_code = s21_mul(value_1, value_2, &result);
  ck_assert(return_code == 2);

  // Функция s21_mul умножение положительного и отрицательного с большой
  // мантиссой с ненулевыми разрядами
}
END_TEST

START_TEST(mul_positive_and_negative_float_big_scale_bank_round) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal result;
  str_to_decimal("7.9228162514264337593543950335", &value_1);
  str_to_decimal("-79.28162514264337593543950335", &value_2);
  int return_code = s21_mul(value_1, value_2, &result);
  ck_assert(return_code == 2);

  //   Функция s21_div деление двух положительных чисел с большой мантиссой с
  //   ненулевыми разрядами
}
END_TEST

START_TEST(div_positive_float_big_scale_bank_round) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal result;
  str_to_decimal("7.9228162514264337593543950335", &value_1);
  str_to_decimal("79.28162514264337593543950335", &value_2);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(return_code == 1);

  // Функция s21_div деление двух отрицательных чисел с большой мантиссой с
  // ненулевыми разрядами
}
END_TEST

START_TEST(div_negative_float_big_scale_bank_round) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal result;
  str_to_decimal("-7.9228162514264337593543950335", &value_1);
  str_to_decimal("-79.28162514264337593543950335", &value_2);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(return_code == 1);

  // Функция s21_div деление отрицательного и положительного с большой
  // мантиссой с ненулевыми разрядами
}
END_TEST

START_TEST(div_negative_and_positive_float_big_scale_bank_round) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal result;
  str_to_decimal("-7.9228162514264337593543950335", &value_1);
  str_to_decimal("79.28162514264337593543950335", &value_2);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(return_code == 2);

  // Функция s21_div деление положительного и отрицательного с большой
  // мантиссой с ненулевыми разрядами
}
END_TEST

START_TEST(div_positive_and_negative_float_big_scale_bank_round) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal result;
  str_to_decimal("7.9228162514264337593543950335", &value_1);
  str_to_decimal("-79.28162514264337593543950335", &value_2);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(return_code == 2);

  //////////////////////
  //////////////////////
  ////////////////////////

  // Функция s21_div деление двух положительных чисел
}
END_TEST

START_TEST(div_positive_numbers) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("100", &value_1);
  str_to_decimal("20", &value_2);
  str_to_decimal("5", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух больших положительных чисел
}
END_TEST

START_TEST(div_big_positive_numbers) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("79228162514264337593543950335", &value_1);
  str_to_decimal("7928162514264337593543950335", &value_2);
  str_to_decimal("9.993256618001605231407880075", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух больших отрицательных чисел
}
END_TEST

START_TEST(div_big_negative_numbers) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("-79228162514264337593543950335", &value_1);
  str_to_decimal("-7928162514264337593543950335", &value_2);
  str_to_decimal("9.993256618001605231407880075", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух больших отрицательныого и положительного чисел
  // должен быть отрицательный результат!!!
}
END_TEST

START_TEST(div_big_negative_positive_numbers) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("-79228162514264337593543950335", &value_1);
  str_to_decimal("7928162514264337593543950335", &value_2);
  str_to_decimal("-9.993256618001605231407880075", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух больших положительного и отрицательного чисел
  // должен быть отрицательный результат!!!
}
END_TEST

START_TEST(div_big_positive_negative_numbers) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("79228162514264337593543950335", &value_1);
  str_to_decimal("-7928162514264337593543950335", &value_2);
  str_to_decimal("-9.993256618001605231407880075", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух больших положительных чисел одинаковых
}
END_TEST

START_TEST(div_big_positive_numbers_the_one) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("79228162514264337593543950335", &value_1);
  str_to_decimal("79228162514264337593543950335", &value_2);
  str_to_decimal("1", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух больших отрицательных чисел одинаковых
}
END_TEST

START_TEST(div_big_positive_numbers_the_one_minus) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("-79228162514264337593543950335", &value_1);
  str_to_decimal("-79228162514264337593543950335", &value_2);
  str_to_decimal("1", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух больших отрицательных чисел одинаковых
}
END_TEST

START_TEST(div_big_positive_numbers_the_one_minus_plus) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("-79228162514264337593543950335", &value_1);
  str_to_decimal("79228162514264337593543950335", &value_2);
  str_to_decimal("-1", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух больших отрицательных чисел одинаковых
}
END_TEST

START_TEST(div_big_positive_numbers_the_one_plus_minus) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("79228162514264337593543950335", &value_1);
  str_to_decimal("-79228162514264337593543950335", &value_2);
  str_to_decimal("-1", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух отрицательных чисел
}
END_TEST

START_TEST(div_negative_numbers) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("-100", &value_1);
  str_to_decimal("-20", &value_2);
  str_to_decimal("5", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление положительного и отрицательного чисел
}
END_TEST

START_TEST(div_positive_and_negative) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("100", &value_1);
  str_to_decimal("-20", &value_2);
  str_to_decimal("-5", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление отрицательного и положительного чисел
}
END_TEST

START_TEST(div_negative_and_positive) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("-100", &value_1);
  str_to_decimal("20", &value_2);
  str_to_decimal("-5", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух положительных дробных
}
END_TEST

START_TEST(div_positive_float) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("150.18", &value_1);
  str_to_decimal("1.2", &value_2);
  str_to_decimal("125.15", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух отрицательных дробных
}
END_TEST

START_TEST(div_negative_float) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("-150.18", &value_1);
  str_to_decimal("-1.2", &value_2);
  str_to_decimal("125.15", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление негативного и положительного дробных
}
END_TEST

START_TEST(div_negative_positive_float) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("-150.18", &value_1);
  str_to_decimal("1.2", &value_2);
  str_to_decimal("-125.15", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление положительного и отрицательного дробных
}
END_TEST

START_TEST(div_positive_negative_float) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("150.18", &value_1);
  str_to_decimal("-1.2", &value_2);
  str_to_decimal("-125.15", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление положительного дробного и целого
}
END_TEST

START_TEST(div_positive_float_int) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("150.18", &value_1);
  str_to_decimal("2", &value_2);
  str_to_decimal("75.09", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление отрицательного дробного и целого
}
END_TEST

START_TEST(div_negative_float_int) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("-150.18", &value_1);
  str_to_decimal("2", &value_2);
  str_to_decimal("-75.09", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление дробного и отрицательного целого
}
END_TEST

START_TEST(div_negative_float_positive_int) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("150.18", &value_1);
  str_to_decimal("-2", &value_2);
  str_to_decimal("-75.09", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление положительного целого отрицательного дробного
}
END_TEST

START_TEST(div_positive_int_negative_float) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("150", &value_1);
  str_to_decimal("-2.56", &value_2);
  str_to_decimal("-58.59375", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление отрицательного целого положительного дробного
}
END_TEST

START_TEST(div_negative_int_positive_float) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("-150", &value_1);
  str_to_decimal("2.56", &value_2);
  str_to_decimal("-58.59375", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div очень большое число и маленькое
}
END_TEST

START_TEST(div_max_and_min) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("79228162514264337593543950335", &value_1);
  str_to_decimal("2", &value_2);
  str_to_decimal("39614081257132168796771975168", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление отрицательных очень большое число и маленькое
}
END_TEST

START_TEST(div_max_and_min2) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("-79228162514264337593543950335", &value_1);
  str_to_decimal("-2", &value_2);
  str_to_decimal("39614081257132168796771975168", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление отрицательных очень большое число и маленькое
  // неправильный знак!!!
}
END_TEST

START_TEST(div_max_and_min3) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("-79228162514264337593543950335", &value_1);
  str_to_decimal("2", &value_2);
  str_to_decimal("-39614081257132168796771975168", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление отрицательных очень большое число и маленькое
  // неправильный знак!!!
}
END_TEST

START_TEST(div_max_and_min4) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("79228162514264337593543950335", &value_1);
  str_to_decimal("-2", &value_2);
  str_to_decimal("-39614081257132168796771975168", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div очень маленькое число и большое
}
END_TEST

START_TEST(div_min_and_max) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("2", &value_1);
  str_to_decimal("79228162514264337593543950335", &value_2);
  str_to_decimal("0", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);
  // 0.0000000000000000000000000000

  // Функция s21_div очень маленькое число и большое
}
END_TEST

START_TEST(div_min_and_max2) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("-2", &value_1);
  str_to_decimal("-79228162514264337593543950335", &value_2);
  str_to_decimal("0", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);
  // 0.0000000000000000000000000000

  // Функция s21_div очень маленькое число и большое
  // должен быть отрицательный ноль!!!
}
END_TEST

START_TEST(div_min_and_max3) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("2", &value_1);
  str_to_decimal("-79228162514264337593543950335", &value_2);
  str_to_decimal("-0", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);
  // 0.0000000000000000000000000000

  // Функция s21_div очень маленькое число и большое
  // должен быть отрицательный ноль!!!
}
END_TEST

START_TEST(div_min_and_max4) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("-2", &value_1);
  str_to_decimal("79228162514264337593543950335", &value_2);
  str_to_decimal("-0", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);
  // 0.0000000000000000000000000000

  // Функция s21_div деление двух нулей
}
END_TEST

START_TEST(div_positive_numbers_zero) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal result;
  str_to_decimal("0", &value_1);
  str_to_decimal("0", &value_2);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(return_code == 3);

  // Функция s21_div деление положительного и отрицательного нуля
}
END_TEST

START_TEST(div_positive_and_negative_zero) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal result;
  str_to_decimal("0", &value_1);
  str_to_decimal("-0", &value_2);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(return_code == 3);

  // Функция s21_div деление отрицательного и положительного нуля
}
END_TEST

START_TEST(div_negative_and_positive_zero) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal result;
  str_to_decimal("-0", &value_1);
  str_to_decimal("0", &value_2);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(return_code == 3);

  // Функция s21_div деление отрицательных нулей
}
END_TEST

START_TEST(div_negative_numbers_zero) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal result;
  str_to_decimal("79228162514264337593543950335", &value_1);
  str_to_decimal("0", &value_2);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(return_code == 3);

  // Функция s21_div деление положительного числа и нуля
}
END_TEST

START_TEST(div_positive_numbers_and_zero) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal result;
  str_to_decimal("79228162514264337593543950335", &value_1);
  str_to_decimal("0", &value_2);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(return_code == 3);

  // Функция s21_div деление нуля и положительного числа
}
END_TEST

START_TEST(div_zero_and_positive_numbers) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("0", &value_1);
  str_to_decimal("79228162514264337593543950335", &value_2);
  str_to_decimal("0", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление положительного дробного и нуля
}
END_TEST

START_TEST(div_positive_float_and_zero) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal result;
  str_to_decimal("792281625142643375.93543950335", &value_1);
  str_to_decimal("0", &value_2);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(return_code == 3);

  // Функция s21_div деление нуля и положительного дробного
}
END_TEST

START_TEST(div_zero_and_positive_float) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("0", &value_1);
  str_to_decimal("7922816251426.4337593543950335", &value_2);
  str_to_decimal("0", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление отрицательного числа и нуля
}
END_TEST

START_TEST(div_negative_numbers_and_zero) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal result;
  str_to_decimal("-79228162514264337593543950335", &value_1);
  str_to_decimal("0", &value_2);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(return_code == 3);

  // Функция s21_div деление нуля и отрицательного числа
}
END_TEST

START_TEST(div_zero_and_negative_numbers) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("0", &value_1);
  str_to_decimal("-79228162514264337593543950335", &value_2);
  str_to_decimal("-0", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление отрицательного дробного и нуля
}
END_TEST

START_TEST(div_negative_float_and_zero) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal result;
  str_to_decimal("-792281625142643375.93543950335", &value_1);
  str_to_decimal("0", &value_2);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(return_code == 3);

  // Функция s21_div деление нуля и отрицательного дробного
}
END_TEST

START_TEST(div_zero_and_negative_float) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("0", &value_1);
  str_to_decimal("-792281625142643.37593543950335", &value_2);
  str_to_decimal("-0", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух положительных чисел с большой мантиссой
}
END_TEST

START_TEST(div_positive_float_big_scale) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("0.0000000000000000000000000001", &value_1);
  str_to_decimal("0.0000000000000000000000000002", &value_2);
  str_to_decimal("0.5", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух отрицательных чисел с большой мантиссой
}
END_TEST

START_TEST(div_negative_float_big_scale_) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("-0.0000000000000000000000000001", &value_1);
  str_to_decimal("-0.0000000000000000000000000002", &value_2);
  str_to_decimal("0.5", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление отрицательного и положительного с большой
  // мантиссой
}
END_TEST

START_TEST(div_negative_and_positive_float_big_scale_) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("-0.0000000000000000000000000001", &value_1);
  str_to_decimal("0.0000000000000000000000000002", &value_2);
  str_to_decimal("-0.5", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление положительного и отрицательного с большой
  // мантиссой
}
END_TEST

START_TEST(div_positive_and_negative_float_big_scale) {
  s21_decimal value_1;
  s21_decimal value_2;
  s21_decimal expected;
  s21_decimal result;
  str_to_decimal("0.0000000000000000000000000001", &value_1);
  str_to_decimal("-0.0000000000000000000000000002", &value_2);
  str_to_decimal("-0.5", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);
}
END_TEST

int main(void) {
  Suite *s1 = suite_create("Core");
  TCase *tc1_1 = tcase_create("Core");
  SRunner *sr = srunner_create(s1);
  int nf;

  suite_add_tcase(s1, tc1_1);
  tcase_add_test(tc1_1, set_sign_positive);
  tcase_add_test(tc1_1, set_sign_negative);
  tcase_add_test(tc1_1, get_sign_positive);
  tcase_add_test(tc1_1, get_sign_negative);
  tcase_add_test(tc1_1, set_bit_zero_false);
  tcase_add_test(tc1_1, set_bit_zero_true);
  tcase_add_test(tc1_1, set_bit_one_false);
  tcase_add_test(tc1_1, set_bit_one_true);
  tcase_add_test(tc1_1, set_bit_middle_false);
  tcase_add_test(tc1_1, set_bit_middle_true);
  tcase_add_test(tc1_1, set_bit_middle_false_one);
  tcase_add_test(tc1_1, set_bit_middle_true_one);
  tcase_add_test(tc1_1, set_bit_overflow_false_one);
  tcase_add_test(tc1_1, add_positive_numbers);
  tcase_add_test(tc1_1, add_big_positive_numbers);
  tcase_add_test(tc1_1, add_negative_numbers);
  tcase_add_test(tc1_1, add_positive_and_negative);
  tcase_add_test(tc1_1, add_negative_and_positive);
  tcase_add_test(tc1_1, add_positive_float);
  tcase_add_test(tc1_1, add_negative_float);
  tcase_add_test(tc1_1, add_positive_and_negative_float);
  tcase_add_test(tc1_1, add_negative_and_positive_float);
  tcase_add_test(tc1_1, add_positive_float_int);
  tcase_add_test(tc1_1, add_negative_float_int);
  tcase_add_test(tc1_1, add_negative_float_positive_int);
  tcase_add_test(tc1_1, add_positive_float_negative_int);
  tcase_add_test(tc1_1, add_positive_int_negative_float);
  tcase_add_test(tc1_1, add_negative_int_positive_float);
  tcase_add_test(tc1_1, add_overflow);
  tcase_add_test(tc1_1, add_overflow_two);
  tcase_add_test(tc1_1, add_overflow_three);
  tcase_add_test(tc1_1, add_overflow_negative);
  tcase_add_test(tc1_1, add_overflow_negative_two);
  tcase_add_test(tc1_1, add_overflow_negative_three);
  tcase_add_test(tc1_1, add_positive_numbers_zero);
  tcase_add_test(tc1_1, add_positive_and_negative_zero);
  tcase_add_test(tc1_1, add_negative_and_positive_zero);
  tcase_add_test(tc1_1, add_negative_numbers_zero);
  tcase_add_test(tc1_1, add_positive_numbers_and_zero);
  tcase_add_test(tc1_1, add_zero_and_positive_numbers);
  tcase_add_test(tc1_1, add_positive_float_and_zero);
  tcase_add_test(tc1_1, add_zero_and_positive_float);
  tcase_add_test(tc1_1, add_negative_numbers_and_zero);
  tcase_add_test(tc1_1, add_zero_and_negative_numbers);
  tcase_add_test(tc1_1, add_negative_float_and_zero);
  tcase_add_test(tc1_1, add_zero_and_negative_float);
  tcase_add_test(tc1_1, add_positive_float_big_scale);
  tcase_add_test(tc1_1, add_negative_float_big_scale_);
  tcase_add_test(tc1_1, add_negative_and_positive_float_big_scale_);
  tcase_add_test(tc1_1, add_positive_and_negative_float_big_scale);
  tcase_add_test(tc1_1, sub_positive_numbers);
  tcase_add_test(tc1_1, sub_negative_numbers);
  tcase_add_test(tc1_1, sub_positive_and_negative);
  tcase_add_test(tc1_1, sub_negative_and_positive);
  tcase_add_test(tc1_1, sub_positive_float);
  tcase_add_test(tc1_1, sub_negative_float);
  tcase_add_test(tc1_1, sub_positive_and_negative_float);
  tcase_add_test(tc1_1, sub_negative_and_positive_float);
  tcase_add_test(tc1_1, sub_positive_float_int);
  tcase_add_test(tc1_1, sub_negative_float_int);
  tcase_add_test(tc1_1, sub_negative_float_positive_int);
  tcase_add_test(tc1_1, sub_positive_float_negative_int);
  tcase_add_test(tc1_1, sub_positive_int_negative_float);
  tcase_add_test(tc1_1, sub_negative_int_positive_float);
  tcase_add_test(tc1_1, sub_overflow);
  tcase_add_test(tc1_1, sub_overflow_two);
  tcase_add_test(tc1_1, sub_overflow_negative);
  tcase_add_test(tc1_1, sub_positive_numbers_zero);
  tcase_add_test(tc1_1, sub_positive_and_negative_zero);
  tcase_add_test(tc1_1, sub_negative_and_positive_zero);
  tcase_add_test(tc1_1, sub_negative_numbers_zero);
  tcase_add_test(tc1_1, sub_positive_float_big_scale);
  tcase_add_test(tc1_1, sub_negative_float_big_scale);
  tcase_add_test(tc1_1, sub_negative_and_positive_float_big_scale);
  tcase_add_test(tc1_1, sub_positive_and_negative_float_big_scale);
  tcase_add_test(tc1_1, sub_positive_numbers_and_zero);
  tcase_add_test(tc1_1, sub_zero_and_positive_numbers);
  tcase_add_test(tc1_1, sub_positive_float_and_zero);
  tcase_add_test(tc1_1, sub_zero_and_positive_float);
  tcase_add_test(tc1_1, sub_negative_numbers_and_zero);
  tcase_add_test(tc1_1, sub_zero_and_negative_numbers);
  tcase_add_test(tc1_1, sub_negative_float_and_zero);
  tcase_add_test(tc1_1, sub_zero_and_negative_float);
  tcase_add_test(tc1_1, mul_positive_numbers);
  tcase_add_test(tc1_1, mul_negative_numbers);
  tcase_add_test(tc1_1, mul_positive_and_negative);
  tcase_add_test(tc1_1, mul_negative_and_positive);
  tcase_add_test(tc1_1, mul_positive_float);
  tcase_add_test(tc1_1, mul_negative_float);
  tcase_add_test(tc1_1, mul_positive_and_negative_float);
  tcase_add_test(tc1_1, mul_negative_and_positive_float);
  tcase_add_test(tc1_1, mul_positive_float_int);
  tcase_add_test(tc1_1, mul_negative_float_int);
  tcase_add_test(tc1_1, mul_negative_float_positive_int);
  tcase_add_test(tc1_1, mul_positive_float_negative_int);
  tcase_add_test(tc1_1, mul_positive_int_negative_float);
  tcase_add_test(tc1_1, mul_negative_int_positive_float);
  tcase_add_test(tc1_1, mul_overflow);
  tcase_add_test(tc1_1, mul_overflow_two);
  tcase_add_test(tc1_1, mul_overflow_three);
  tcase_add_test(tc1_1, mul_overflow_four);
  tcase_add_test(tc1_1, mul_overflow_five);
  tcase_add_test(tc1_1, mul_overflow_negative);
  tcase_add_test(tc1_1, mul_overflow_negative_two);
  tcase_add_test(tc1_1, mul_overflow_negative_three);
  tcase_add_test(tc1_1, mul_positive_numbers_zero);
  tcase_add_test(tc1_1, mul_positive_and_negative_zero);
  tcase_add_test(tc1_1, mul_negative_and_positive_zero);
  tcase_add_test(tc1_1, mul_negative_numbers_zero);
  tcase_add_test(tc1_1, mul_positive_numbers_and_zero);
  tcase_add_test(tc1_1, mul_zero_and_positive_numbers);
  tcase_add_test(tc1_1, mul_positive_float_and_zero);
  tcase_add_test(tc1_1, mul_zero_and_positive_float);
  tcase_add_test(tc1_1, mul_negative_numbers_and_zero);
  tcase_add_test(tc1_1, mul_zero_and_negative_numbers);
  tcase_add_test(tc1_1, mul_negative_float_and_zero);
  tcase_add_test(tc1_1, mul_zero_and_negative_float);
  tcase_add_test(tc1_1, mul_positive_float_big_scale);
  tcase_add_test(tc1_1, mul_negative_float_big_scale);
  tcase_add_test(tc1_1, mul_negative_and_positive_float_big_scale);
  tcase_add_test(tc1_1, mul_positive_and_negative_float_big_scale);
  tcase_add_test(tc1_1, mul_positive_float_big_scale_not_zero);
  tcase_add_test(tc1_1, mul_negative_float_big_scale_not_zero);
  tcase_add_test(tc1_1, mul_negative_and_positive_float_big_scale_not_zero);
  tcase_add_test(tc1_1, mul_positive_and_negative_float_big_scale_not_zero);
  tcase_add_test(tc1_1, mul_positive_float__);
  tcase_add_test(tc1_1, mul_positive_float____);
  tcase_add_test(tc1_1, alignment_both_zero_with_scale);
  tcase_add_test(tc1_1, alignment_both_zero_without_scale);
  tcase_add_test(tc1_1, alignment_both_zero_without_scale_and_with_scale);
  tcase_add_test(tc1_1, alignment_both_zero_with_scale_and_without_scale);
  tcase_add_test(tc1_1, alignment_float_with_zero_and_int);
  tcase_add_test(tc1_1, alignment_int_and_float_with_zero);
  tcase_add_test(tc1_1, alignment_big_float_big_scale_and_min_scale_);
  tcase_add_test(tc1_1, alignment_big_float_min_scale_and_big_scale);
  tcase_add_test(tc1_1, alignment_min_float_big_scale_and_min_scale_);
  tcase_add_test(tc1_1, alignment_min_float_min_scale_and_big_scale);
  tcase_add_test(tc1_1, positive_s21_is_equal_00);
  tcase_add_test(tc1_1, positive_s21_is_equal_01);
  tcase_add_test(tc1_1, negative_s21_is_equal_00);
  tcase_add_test(tc1_1, negative_s21_is_equal_01);
  tcase_add_test(tc1_1, negative_s21_is_equal_02);
  tcase_add_test(tc1_1, negative_s21_is_equal_03);
  tcase_add_test(tc1_1, negative_s21_is_not_equal_00);
  tcase_add_test(tc1_1, negative_s21_is_not_equal_01);
  tcase_add_test(tc1_1, positive_s21_is_not_equal_00);
  tcase_add_test(tc1_1, positive_s21_is_not_equal_01);
  tcase_add_test(tc1_1, positive_s21_is_not_equal_02);
  tcase_add_test(tc1_1, positive_s21_is_not_equal_03);
  tcase_add_test(tc1_1, positive_s21_is_less_00);
  tcase_add_test(tc1_1, positive_s21_is_less_01);
  tcase_add_test(tc1_1, positive_s21_is_less_02);
  tcase_add_test(tc1_1, positive_s21_is_less_03);
  tcase_add_test(tc1_1, negative_s21_is_less_00);
  tcase_add_test(tc1_1, negative_s21_is_less_01);
  tcase_add_test(tc1_1, negative_s21_is_less_02);
  tcase_add_test(tc1_1, negative_s21_is_less_03);
  tcase_add_test(tc1_1, negative_s21_is_less_04);
  tcase_add_test(tc1_1, negative_s21_is_greater_00);
  tcase_add_test(tc1_1, negative_s21_is_greater_01);
  tcase_add_test(tc1_1, negative_s21_is_greater_02);
  tcase_add_test(tc1_1, negative_s21_is_greater_03);
  tcase_add_test(tc1_1, negative_s21_is_greater_04);
  tcase_add_test(tc1_1, positive_s21_is_greater_00);
  tcase_add_test(tc1_1, positive_s21_is_greater_01);
  tcase_add_test(tc1_1, positive_s21_is_greater_02);
  tcase_add_test(tc1_1, positive_s21_is_greater_03);
  tcase_add_test(tc1_1, positive_s21_is_less_or_equal_000);
  tcase_add_test(tc1_1, positive_s21_is_less_or_equal_00);
  tcase_add_test(tc1_1, positive_s21_is_less_or_equal_01);
  tcase_add_test(tc1_1, positive_s21_is_less_or_equal_02);
  tcase_add_test(tc1_1, positive_s21_is_less_or_equal_03);
  tcase_add_test(tc1_1, negative_s21_is_less_or_equal_00);
  tcase_add_test(tc1_1, negative_s21_is_less_or_equal_01);
  tcase_add_test(tc1_1, negative_s21_is_less_or_equal_02);
  tcase_add_test(tc1_1, negative_s21_is_less_or_equal_03);
  tcase_add_test(tc1_1, negative_s21_is_greater_or_equal_00);
  tcase_add_test(tc1_1, negative_s21_is_greater__or_equal01);
  tcase_add_test(tc1_1, negative_s21_is_greater__or_equal02);
  tcase_add_test(tc1_1, negative_s21_is_greater_or_equal_03);
  tcase_add_test(tc1_1, positive_s21_is_greater_or_equal_000);
  tcase_add_test(tc1_1, positive_s21_is_greater_or_equal_00);
  tcase_add_test(tc1_1, positive_s21_is_greater_or_equal_01);
  tcase_add_test(tc1_1, positive_s21_is_greater_or_equal_02);
  tcase_add_test(tc1_1, positive_s21_is_greater_or_equal_03);
  tcase_add_test(tc1_1, truncate_1);
  tcase_add_test(tc1_1, truncate_2);
  tcase_add_test(tc1_1, truncate_3);
  tcase_add_test(tc1_1, truncate_4);
  tcase_add_test(tc1_1, truncate_5);
  tcase_add_test(tc1_1, truncate_6);
  tcase_add_test(tc1_1, truncate_7);
  tcase_add_test(tc1_1, truncate_8);
  tcase_add_test(tc1_1, truncate_9);
  tcase_add_test(tc1_1, truncate_10);
  tcase_add_test(tc1_1, truncate_11);
  tcase_add_test(tc1_1, truncate_12);
  tcase_add_test(tc1_1, truncate_13);
  tcase_add_test(tc1_1, truncate_14);
  tcase_add_test(tc1_1, round_1);
  tcase_add_test(tc1_1, round_2);
  tcase_add_test(tc1_1, round_3);
  tcase_add_test(tc1_1, round_4);
  tcase_add_test(tc1_1, round_5);
  tcase_add_test(tc1_1, round_6);
  tcase_add_test(tc1_1, round_7);
  tcase_add_test(tc1_1, round_8);
  tcase_add_test(tc1_1, floor_1);
  tcase_add_test(tc1_1, floor_2);
  tcase_add_test(tc1_1, floor_3);
  tcase_add_test(tc1_1, floor_4);
  tcase_add_test(tc1_1, floor_5);
  tcase_add_test(tc1_1, floor_6);
  tcase_add_test(tc1_1, floor_7);
  tcase_add_test(tc1_1, floor_8);
  tcase_add_test(tc1_1, floor_9);
  tcase_add_test(tc1_1, floor_10);
  tcase_add_test(tc1_1, bank_round_1);
  tcase_add_test(tc1_1, bank_round_2);
  tcase_add_test(tc1_1, bank_round_3);
  tcase_add_test(tc1_1, bank_round_4);
  tcase_add_test(tc1_1, bank_round_5);
  tcase_add_test(tc1_1, bank_round_6);
  tcase_add_test(tc1_1, bank_round_7);
  tcase_add_test(tc1_1, bank_round_8);
  tcase_add_test(tc1_1, bank_round_9);
  tcase_add_test(tc1_1, bank_round_10);
  tcase_add_test(tc1_1, bank_round_11);
  tcase_add_test(tc1_1, bank_round_12);
  tcase_add_test(tc1_1, truncate_positive_float);
  tcase_add_test(tc1_1, div_positive_float1);
  tcase_add_test(tc1_1, div_negative_float2);
  tcase_add_test(tc1_1, div_positive_negative3);
  tcase_add_test(tc1_1, div_negative_positive4);
  tcase_add_test(tc1_1, div_by_zero);
  tcase_add_test(tc1_1, s21_negate1);
  tcase_add_test(tc1_1, s21_negate2);
  tcase_add_test(tc1_1, s21_negate3);
  tcase_add_test(tc1_1, s21_negate4);
  tcase_add_test(tc1_1, s21_negate5);
  tcase_add_test(tc1_1, s21_negate6);
  tcase_add_test(tc1_1, s21_negate7);
  tcase_add_test(tc1_1, s21_negate8);
  tcase_add_test(tc1_1, s21_negate9);
  tcase_add_test(tc1_1, inf_div);
  tcase_add_test(tc1_1, neginf_div);
  tcase_add_test(tc1_1, div2);
  tcase_add_test(tc1_1, div3);
  tcase_add_test(tc1_1, div4);
  tcase_add_test(tc1_1, from_float_to_decimal_1);
  tcase_add_test(tc1_1, from_float_to_decimal_2);
  tcase_add_test(tc1_1, from_float_to_decimal_3);
  tcase_add_test(tc1_1, from_float_to_decimal_4);
  tcase_add_test(tc1_1, from_float_to_decimal_5);
  tcase_add_test(tc1_1, from_float_to_decimal_6);
  tcase_add_test(tc1_1, from_float_to_decimal_7);
  tcase_add_test(tc1_1, from_float_to_decimal_8);
  tcase_add_test(tc1_1, from_float_to_decimal_9);
  tcase_add_test(tc1_1, from_float_to_decimal_10);
  tcase_add_test(tc1_1, from_float_to_decimal_11);
  tcase_add_test(tc1_1, from_float_to_decimal_12);
  tcase_add_test(tc1_1, from_float_to_decimal_13);
  tcase_add_test(tc1_1, from_float_to_decimal_14);
  tcase_add_test(tc1_1, from_float_to_decimal_15);
  tcase_add_test(tc1_1, from_float_to_decimal_16);
  tcase_add_test(tc1_1, from_float_to_decimal_17);
  tcase_add_test(tc1_1, from_decimal_to_float_1);
  tcase_add_test(tc1_1, from_decimal_to_float_2);
  tcase_add_test(tc1_1, from_decimal_to_float_3);
  tcase_add_test(tc1_1, from_decimal_to_float_4);
  tcase_add_test(tc1_1, from_decimal_to_float_5);
  tcase_add_test(tc1_1, from_decimal_to_float_6);
  tcase_add_test(tc1_1, from_decimal_to_float_7);
  tcase_add_test(tc1_1, from_int_to_decimal_0);
  tcase_add_test(tc1_1, from_int_to_decimal_1);
  tcase_add_test(tc1_1, from_int_to_decimal_2);
  tcase_add_test(tc1_1, from_int_to_decimal_3);
  tcase_add_test(tc1_1, from_int_to_decimal_4);
  tcase_add_test(tc1_1, from_int_to_decimal_5);
  tcase_add_test(tc1_1, from_decimal_to_int_1);
  tcase_add_test(tc1_1, from_decimal_to_int_2);
  tcase_add_test(tc1_1, from_decimal_to_int_3);
  tcase_add_test(tc1_1, from_decimal_to_int_4);
  tcase_add_test(tc1_1, from_decimal_to_int_5);
  tcase_add_test(tc1_1, from_decimal_to_int_6);
  tcase_add_test(tc1_1, from_decimal_to_int_7);
  tcase_add_test(tc1_1, from_decimal_to_int_8);
  tcase_add_test(tc1_1, from_decimal_to_int_9);
  tcase_add_test(tc1_1, big_to_decimal_0);
  tcase_add_test(tc1_1, big_to_decimal_1);
  tcase_add_test(tc1_1, big_to_decimal_2);
  tcase_add_test(tc1_1, big_to_int_1);
  tcase_add_test(tc1_1, add_multiplying_zeros);
  tcase_add_test(tc1_1, sub_multiplying_zeros);
  tcase_add_test(tc1_1, sub_overflow_bank_round);
  tcase_add_test(tc1_1, add_positive_float_big_scale_bank_round);
  tcase_add_test(tc1_1, add_negative_float_big_scale_bank_round);
  tcase_add_test(tc1_1, add_negative_and_positive_float_big_scale_bank_round);
  tcase_add_test(tc1_1, add_positive_and_negative_float_big_scale_bank_round);
  tcase_add_test(tc1_1, sub_positive_float_big_scale_bank_round);
  tcase_add_test(tc1_1, sub_negative_float_big_scale_bank_round);
  tcase_add_test(tc1_1, sub_negative_and_positive_float_big_scale_bank_round);
  tcase_add_test(tc1_1, sub_positive_and_negative_float_big_scale_bank_round);
  tcase_add_test(tc1_1, mul_positive_float_big_scale_bank_round);
  tcase_add_test(tc1_1, mul_negative_float_big_scale_bank_round);
  tcase_add_test(tc1_1, mul_negative_and_positive_float_big_scale_bank_round);
  tcase_add_test(tc1_1, mul_positive_and_negative_float_big_scale_bank_round);
  tcase_add_test(tc1_1, div_positive_float_big_scale_bank_round);
  tcase_add_test(tc1_1, div_negative_float_big_scale_bank_round);
  tcase_add_test(tc1_1, div_negative_and_positive_float_big_scale_bank_round);
  tcase_add_test(tc1_1, div_positive_and_negative_float_big_scale_bank_round);
  tcase_add_test(tc1_1, div_positive_numbers);
  tcase_add_test(tc1_1, div_big_positive_numbers);
  tcase_add_test(tc1_1, div_big_negative_numbers);
  tcase_add_test(tc1_1, div_big_negative_positive_numbers);
  tcase_add_test(tc1_1, div_big_positive_negative_numbers);
  tcase_add_test(tc1_1, div_big_positive_numbers_the_one);
  tcase_add_test(tc1_1, div_big_positive_numbers_the_one_minus);
  tcase_add_test(tc1_1, div_big_positive_numbers_the_one_minus_plus);
  tcase_add_test(tc1_1, div_big_positive_numbers_the_one_plus_minus);
  tcase_add_test(tc1_1, div_negative_numbers);
  tcase_add_test(tc1_1, div_positive_and_negative);
  tcase_add_test(tc1_1, div_negative_and_positive);
  tcase_add_test(tc1_1, div_positive_float);
  tcase_add_test(tc1_1, div_negative_float);
  tcase_add_test(tc1_1, div_negative_positive_float);
  tcase_add_test(tc1_1, div_positive_negative_float);
  tcase_add_test(tc1_1, div_positive_float_int);
  tcase_add_test(tc1_1, div_negative_float_int);
  tcase_add_test(tc1_1, div_negative_float_positive_int);
  tcase_add_test(tc1_1, div_positive_int_negative_float);
  tcase_add_test(tc1_1, div_negative_int_positive_float);
  tcase_add_test(tc1_1, div_max_and_min);
  tcase_add_test(tc1_1, div_max_and_min2);
  tcase_add_test(tc1_1, div_max_and_min3);
  tcase_add_test(tc1_1, div_max_and_min4);
  tcase_add_test(tc1_1, div_min_and_max);
  tcase_add_test(tc1_1, div_min_and_max2);
  tcase_add_test(tc1_1, div_min_and_max3);
  tcase_add_test(tc1_1, div_min_and_max4);
  tcase_add_test(tc1_1, div_positive_numbers_zero);
  tcase_add_test(tc1_1, div_positive_and_negative_zero);
  tcase_add_test(tc1_1, div_negative_and_positive_zero);
  tcase_add_test(tc1_1, div_negative_numbers_zero);
  tcase_add_test(tc1_1, div_positive_numbers_and_zero);
  tcase_add_test(tc1_1, div_zero_and_positive_numbers);
  tcase_add_test(tc1_1, div_positive_float_and_zero);
  tcase_add_test(tc1_1, div_zero_and_positive_float);
  tcase_add_test(tc1_1, div_negative_numbers_and_zero);
  tcase_add_test(tc1_1, div_zero_and_negative_numbers);
  tcase_add_test(tc1_1, div_negative_float_and_zero);
  tcase_add_test(tc1_1, div_zero_and_negative_float);
  tcase_add_test(tc1_1, div_positive_float_big_scale);
  tcase_add_test(tc1_1, div_negative_float_big_scale_);
  tcase_add_test(tc1_1, div_negative_and_positive_float_big_scale_);
  tcase_add_test(tc1_1, div_positive_and_negative_float_big_scale);

  srunner_set_fork_status(sr, CK_NOFORK);
  srunner_run_all(sr, CK_ENV);
  nf = srunner_ntests_failed(sr);
  srunner_free(sr);

  return nf == 0 ? 0 : 1;
}
