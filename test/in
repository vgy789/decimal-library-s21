#include <check.h>
#include <stdio.h>

#include "../decimal/bitwise_helper.h"
#include "../decimal/s21_decimal.h"

static s21_decimal uint128_to_bin(__uint128_t n) {
  // use it → s21_decimal result = uint128_to_bin(1234123125678965432);
  s21_decimal result = {{0, 0, 0, 0}};
  int binary_num[128];
  int i = 0;

  while (n > 0) {
    binary_num[i++] = n % 2;
    n /= 2;
  }

  for (int j = i - 1; j >= 0; j--) {
    set_bit(&result, j, binary_num[j]);
  }
  return result;
}

// set_sign
// Функция set_sign поставить знак плюс
#test set_sign_positive
s21_decimal value = {0};
set_sign(&value, plus);

ck_assert(((value.bits[3] >> 31) & 1) == plus);

// Функция set_sign поставить знак минус
#test set_sign_negative
s21_decimal value = {0};
set_sign(&value, minus);

ck_assert(((value.bits[3] >> 31) & 1) == minus);

// get_sign
//  Функция get_sign проверить знак плюс
#test get_sign_positive
s21_decimal value = {0};
set_sign(&value, plus);

ck_assert(get_sign(value) == plus);

// Функция get_sign проверить знак плюс
#test get_sign_negative
s21_decimal value = {0};
set_sign(&value, minus);

ck_assert(get_sign(value) == minus);

// set_bit
//  Функция set_bit поменять бит 0 на бит 0 индекс 0
#test set_bit_zero_false
s21_decimal value = (s21_decimal){{0}};
set_bit(&value, 0, false);

ck_assert(get_bit(value, 0) == false);

// Функция set_bit поменять бит 0 на бит 1 индекс 0
#test set_bit_zero_true
s21_decimal value = (s21_decimal){{0}};
set_bit(&value, 0, true);

ck_assert(get_bit(value, 0) == true);

// Функция set_bit поменять бит 1 на бит 0 индекс 0
#test set_bit_one_false
s21_decimal value = (s21_decimal){{1}};
set_bit(&value, 0, false);

ck_assert(get_bit(value, 0) == false);

// Функция set_bit поменять бит 1 на бит 1 индекс 0
#test set_bit_one_true
s21_decimal value = (s21_decimal){{1}};
set_bit(&value, 0, true);

ck_assert(get_bit(value, 0) == true);

// Функция set_bit поменять бит 0 на бит 0 индекс 16
#test set_bit_middle_false
s21_decimal value = (s21_decimal){{0}};
set_bit(&value, 16, false);

ck_assert(get_bit(value, 16) == false);

// Функция set_bit поменять бит 0 на бит 1 индекс 16
#test set_bit_middle_true
s21_decimal value = (s21_decimal){{0}};
set_bit(&value, 16, true);

ck_assert(get_bit(value, 16) == true);

// Функция set_bit поменять бит 1 на бит 0 индекс 16
#test set_bit_middle_false_one
s21_decimal value = (s21_decimal){{1}};
set_bit(&value, 16, false);

ck_assert(get_bit(value, 16) == false);

// Функция set_bit поменять бит 1 на бит 1 индекс 16
#test set_bit_middle_true_one
s21_decimal value = (s21_decimal){{1}};
set_bit(&value, 16, true);

ck_assert(get_bit(value, 16) == true);

// Функция set_bit поменять бит 0 на бит 1 индекс 96
#test set_bit_overflow_true
s21_decimal value = (s21_decimal){{0}};
set_bit(&value, 96, true);

ck_assert(get_bit(value, 96) == true);

// Функция set_bit поменять бит 0 на бит 0 индекс 96
#test set_bit_overflow_false
s21_decimal value = (s21_decimal){{0}};
set_bit(&value, 96, false);

ck_assert(get_bit(value, 96) == false);

// Функция set_bit поменять бит 1 на бит 1 индекс 96
#test set_bit_overflow_true_one
s21_decimal value = (s21_decimal){{1}};
set_bit(&value, 96, true);

ck_assert(get_bit(value, 96) == true);

// Функция set_bit поменять бит 1 на бит 0 индекс 96
#test set_bit_overflow_false_one
s21_decimal value = (s21_decimal){{1}};
set_bit(&value, 96, false);

ck_assert(get_bit(value, 96) == false);

// s21_add
// Функция s21_add сложение двух положительных чисел
#test add_positive_numbers
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{30, 0, 0, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение двух отрицательных чисел
#test add_negative_numbers
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{30, 0, 0, 0x80000000}};

int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение положительного и отрицательного чисел
#test add_positive_and_negative
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{10, 0, 0, 0x80000000}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного и положительного чисел
#test add_negative_and_positive
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{10, 0, 0, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение двух положительных дробных
#test add_positive_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{200001, 0, 0, 0}};
set_scale(&expected, 9);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение двух отрицательных дробных
#test add_negative_float
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{200001, 0, 0, 0x80000000}};
set_scale(&expected, 9);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение положительного и отрицательного дробных
#test add_positive_and_negative_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{199999, 0, 0, 0x80000000}};
set_scale(&expected, 9);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного и положительного дробных
#test add_negative_and_positive_float
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{199999, 0, 0, 0}};
set_scale(&expected, 9);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение положительного дробного и целого
// #test add_positive_float_int
// s21_decimal value_1 = {{10, 0, 0, 0}};
// s21_decimal value_2 = {{20, 0, 0, 0}};
// set_scale(&value_1, 10);
// s21_decimal result = {{0, 0, 0, 0}};
// s21_decimal expected = {{20000000001, 0, 0, 0}};
// set_scale(&expected, 9);
// int return_code = s21_add(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);
//
//// Функция s21_add сложение отрицательного дробного и целого
// #test add_negative_float_int
// s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
// s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
// set_scale(&value_1, 10);
// s21_decimal result = {{0, 0, 0, 0}};
// s21_decimal expected = {{20000000001, 0, 0, 0x80000000}};
// set_scale(&expected, 9);
// int return_code = s21_add(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);
//
//// Функция s21_add сложение отрицательного дробного и положительного целого
// #test add_negative_float_positive_int
// s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
// s21_decimal value_2 = {{20, 0, 0, 0}};
// set_scale(&value_1, 10);
// s21_decimal result = {{0, 0, 0, 0}};
// s21_decimal expected = {{19999999999, 0, 0, 0}};
// set_scale(&expected, 9);
// int return_code = s21_add(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);
//
//// Функция s21_add сложение положительного дробного и отрицательного целого
// #test add_positive_float_negative_int
// s21_decimal value_1 = {{10, 0, 0, 0}};
// s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
// set_scale(&value_1, 10);
// s21_decimal result = {{0, 0, 0, 0}};
// s21_decimal expected = {{19999999999, 0, 0, 0x80000000}};
// set_scale(&expected, 9);
// int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение положительного целого отрицательного дробного
#test add_positive_int_negative_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
set_scale(&value_2, 5);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{99998, 0, 0, 0}};
set_scale(&expected, 4);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного целого положительного дробного
#test add_negative_int_positive_float
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_scale(&value_2, 5);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{99998, 0, 0, 0x80000000}};
set_scale(&expected, 4);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add очень большое число и маленькое - переполнение
#test add_overflow
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{1, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_add(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_add сложение очень маленького и очень большого - переполнение
#test add_overflow_two
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_add(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_add сложение двух очень больших - переполнение ????
// 79228162514264337593543950335+79228162514264337593543950335=79228162514264337593543950334
#test add_overflow_three
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_add(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_add сложение отрицательных очень большое число и маленькое -
// переполнение отрицательная бесконечность
#test add_overflow_negative
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal value_2 = {{1, 0, 0, 0x80000000}};
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_add(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_add сложение отрицательных очень маленького и очень большого -
// переполнение отрицательная бесконечность
#test add_overflow_negative_two
s21_decimal value_1 = {{1, 0, 0, 0x80000000}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_add(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_add сложение отрицательных двух очень больших - переполнение ???
//-79228162514264337593543950335-79228162514264337593543950335=-79228162514264337593543950334
#test add_overflow_negative_three
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_add(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_add сложение двух нулей
#test add_positive_numbers_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение положительного и отрицательного нуля
#test add_positive_and_negative_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0x80000000}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного и положительного нуля
#test add_negative_and_positive_zero
s21_decimal value_1 = {{0, 0, 0, 0x80000000}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение отрицательных нулей
#test add_negative_numbers_zero
s21_decimal value_1 = {{0, 0, 0, 0x80000000}};
s21_decimal value_2 = {{0, 0, 0, 0x80000000}};
s21_decimal expected = {{0, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение положительного числа и нуля
#test add_positive_numbers_and_zero
s21_decimal value_1 = {{15, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{15, 0, 0, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение нуля и положительного числа
#test add_zero_and_positive_numbers
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{15, 0, 0, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение положительного дробного и нуля
#test add_positive_float_and_zero
s21_decimal value_1 = {{15, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_scale(&value_1, 7);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{15, 0, 0, 0}};
set_scale(&expected, 7);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение нуля и положительного дробного
#test add_zero_and_positive_float
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0}};
set_scale(&value_2, 7);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{15, 0, 0, 0}};
set_scale(&expected, 7);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного числа и нуля
#test add_negative_numbers_and_zero
s21_decimal value_1 = {{15, 0, 0, 0x80000000}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{15, 0, 0, 0x80000000}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение нуля и отрицательного числа
#test add_zero_and_negative_numbers
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0x80000000}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{15, 0, 0, 0x80000000}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного дробного и нуля
#test add_negative_float_and_zero
s21_decimal value_1 = {{15, 0, 0, 0x80000000}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_scale(&value_1, 7);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{15, 0, 0, 0x80000000}};
set_scale(&expected, 7);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение нуля и отрицательного дробного
#test add_zero_and_negative_float
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0x80000000}};
set_scale(&value_2, 7);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{15, 0, 0, 0x80000000}};
set_scale(&expected, 7);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение двух положительных чисел с большой мантиссой
#test add_positive_float_big_scale
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{2, 0, 0, 0}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{21, 0, 0, 0}};
set_scale(&expected, 28);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение двух отрицательных чисел с большой мантиссой
#test add_negative_float_big_scale_
s21_decimal value_1 = {{1, 0, 0, 0x80000000}};
s21_decimal value_2 = {{2, 0, 0, 0x80000000}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{21, 0, 0, 0x80000000}};
set_scale(&expected, 28);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного и положительного с большой мантиссой
#test add_negative_and_positive_float_big_scale_
s21_decimal value_1 = {{1, 0, 0, 0x80000000}};
s21_decimal value_2 = {{2, 0, 0, 0}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{19, 0, 0, 0}};
set_scale(&expected, 28);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение положительного и отрицательного с большой мантиссой
#test add_positive_and_negative_float_big_scale
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{2, 0, 0, 0x80000000}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{19, 0, 0, 0x80000000}};
set_scale(&expected, 28);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// ОКРУГЛЕНИЕ - поменять название тестов
//  Функция s21_add сложение двух положительных чисел с большой мантиссой с
//  ненулевыми разрядами
// #test add_positive_float_big_scale
// s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
// s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
// set_scale(&value_1, 28);
// set_scale(&value_2, 27);
// s21_decimal result = {{0, 0, 0, 0}};
// s21_decimal expected = ???;
// set_scale(&expected, ???);
// int return_code = s21_add(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);
//
//// Функция s21_add сложение двух отрицательных чисел с большой мантиссой с
/// ненулевыми разрядами
// #test add_negative_float_big_scale
// s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// set_scale(&value_1, 28);
// set_scale(&value_2, 27);
// s21_decimal result = {{0, 0, 0, 0}};
// s21_decimal expected = ???;
// set_scale(&expected, ???);
// int return_code = s21_add(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);
//
//// Функция s21_add сложение отрицательного и положительного с большой
/// мантиссой с ненулевыми разрядами
// #test add_negative_and_positive_float_big_scale
// s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
// set_scale(&value_1, 28);
// set_scale(&value_2, 27);
// s21_decimal result = {{0, 0, 0, 0}};
// s21_decimal expected = ???;
// set_scale(&expected, ???);
// int return_code = s21_add(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);
//
//// Функция s21_add сложение положительного и отрицательного с большой
/// мантиссой с ненулевыми разрядами
// #test add_positive_and_negative_float_big_scale
// s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
// s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// set_scale(&value_1, 28);
// set_scale(&value_2, 27);
// s21_decimal result = {{0, 0, 0, 0}};
// s21_decimal expected = ???;
// set_scale(&expected, ???);
// int return_code = s21_add(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);

// s21_sub
// Функция s21_sub вычитание двух положительных целых чисел
#test sub_positive_numbers
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{10, 0, 0, 0x80000000}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание двух отрицательных целых чисел
#test sub_negative_numbers
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_sign(&value_1, minus);
set_sign(&value_2, minus);
s21_decimal expected = {{10, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание позитивного и отрицательного целых чисел
#test sub_positive_and_negative
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_sign(&value_2, minus);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{30, 0, 0, 0}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательного и позитивного целых чисел
#test sub_negative_and_positive
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_sign(&value_1, minus);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{30, 0, 0, 0x80000000}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание двух положительных дробных чисел
#test sub_positive_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{199999, 0, 0, 0x80000000}};
set_scale(&expected, 9);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание двух отрицательных дробных чисел
#test sub_negative_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_sign(&value_1, minus);
set_sign(&value_2, minus);
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{199999, 0, 0, 0}};
set_scale(&expected, 9);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание положительного и отрицательного дробных чисел
#test sub_positive_and_negative_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_sign(&value_2, minus);
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{200001, 0, 0, 0}};
set_scale(&expected, 9);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательного и положительного дробных чисел
#test sub_negative_and_positive_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_sign(&value_1, minus);
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{200001, 0, 0, 0x80000000}};
set_scale(&expected, 9);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

//// Функция s21_sub вычитание положительных дробного и целого
// #test sub_positive_float_int
// s21_decimal value_1 = {{10, 0, 0, 0}};
// s21_decimal value_2 = {{20, 0, 0, 0}};
// set_scale(&value_1, 10);
// s21_decimal result = {{0, 0, 0, 0}};
// s21_decimal expected = {{19999999999, 0, 0, 0x80000000}};
// set_scale(&expected, 9);
// int return_code = s21_sub(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);
//
//// Функция s21_sub вычитание отрицательных дробного и целого
// #test sub_negative_float_int
// s21_decimal value_1 = {{10, 0, 0, 0}};
// s21_decimal value_2 = {{20, 0, 0, 0}};
// set_sign(&value_1, minus);
// set_sign(&value_2, minus);
// set_scale(&value_1, 10);
// s21_decimal result = {{0, 0, 0, 0}};
// s21_decimal expected = {{19999999999, 0, 0, 0}};
// set_scale(&expected, 9);
// int return_code = s21_sub(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);

//// Функция s21_sub вычитание отрицательного дробного и положительного целого
// #test sub_negative_float_positive_int
// s21_decimal value_1 = {{10, 0, 0, 0}};
// s21_decimal value_2 = {{20, 0, 0, 0}};
// set_sign(&value_1, minus);
// set_scale(&value_1, 10);
// s21_decimal result = {{0, 0, 0, 0}};
// s21_decimal expected = {{20000000001, 0, 0, 0x80000000}};
// set_scale(&expected, 9);
// int return_code = s21_sub(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);
//
//// Функция s21_sub вычитание положительного дробного и отрицательного целого
// #test sub_positive_float_negative_int
// s21_decimal value_1 = {{10, 0, 0, 0}};
// s21_decimal value_2 = {{20, 0, 0, 0}};
// set_scale(&value_1, 10);
// set_sign(&value_2, minus);
// s21_decimal result = {{0, 0, 0, 0}};
// s21_decimal expected = {{20000000001, 0, 0, 0}};
// set_scale(&expected, 4);
// int return_code = s21_sub(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);

// Функция s21_sub вычитание положительного целого и отрицательного дробного
#test sub_positive_int_negative_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_sign(&value_2, minus);
set_scale(&value_2, 5);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{100002, 0, 0, 0}};
set_scale(&expected, 4);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательного целого и положительного дробного
#test sub_negative_int_positive_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_sign(&value_1, minus);
set_scale(&value_2, 5);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{100002, 0, 0, 0x80000000}};
set_scale(&expected, 4);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание максимального отрицательного из максимального
// положительного
#test sub_overflow
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
set_sign(&value_1, minus);
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_sub(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_sub вычитание минимального отрицательного и максимального
// положительного
#test sub_overflow_two
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
set_sign(&value_1, minus);
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_sub(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_sub вычитание максимального отрицательного и минимального
// положительного
#test sub_overflow_negative
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{1, 0, 0, 0}};
set_sign(&value_1, minus);
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_sub(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_sub вычитание нулей
#test sub_positive_numbers_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание нулей
#test sub_positive_and_negative_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_sign(&value_2, minus);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание нулей
#test sub_negative_and_positive_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_sign(&value_1, minus);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание нулей
#test sub_negative_numbers_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_sign(&value_1, minus);
set_sign(&value_2, minus);
s21_decimal expected = {{0, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание положительных чисел с большим скейлом
#test sub_positive_float_big_scale
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{2, 0, 0, 0}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{21, 0, 0, 0}};
set_scale(&expected, 28);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательных чисел с большим скейлом
#test sub_negative_float_big_scale
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{2, 0, 0, 0}};
set_sign(&value_1, minus);
set_sign(&value_2, minus);
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{21, 0, 0, 0x80000000}};
set_scale(&expected, 28);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательного и положительного чисел с большим
// скейлом
#test sub_negative_and_positive_float_big_scale
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{2, 0, 0, 0}};
set_sign(&value_1, minus);
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{19, 0, 0, 0}};
set_scale(&expected, 28);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание полоижтельного и отрицательного чисел с большим
// скейлом
#test sub_positive_and_negative_float_big_scale
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{2, 0, 0, 0}};
set_sign(&value_2, minus);
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{19, 0, 0, 0x80000000}};
set_scale(&expected, 28);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание положительного числа и нуля
#test sub_positive_numbers_and_zero
s21_decimal value_1 = {{15, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{15, 0, 0, 0}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание нуля и положительного числа
#test sub_zero_and_positive_numbers
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{15, 0, 0, 0}};
set_sign(&expected, minus);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание положительного дробного и нуля
#test sub_positive_float_and_zero
s21_decimal value_1 = {{15, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_scale(&value_1, 7);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{15, 0, 0, 0}};
set_scale(&expected, 7);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание нуля и положительного дробного
#test sub_zero_and_positive_float
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0}};
set_scale(&value_2, 7);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{15, 0, 0, 0}};
set_scale(&expected, 7);
set_sign(&expected, minus);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательного числа и нуля
#test sub_negative_numbers_and_zero
s21_decimal value_1 = {{15, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_sign(&value_1, minus);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{15, 0, 0, 0}};
set_sign(&expected, minus);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание нуля и отрицательного числа
#test sub_zero_and_negative_numbers
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0}};
set_sign(&value_2, minus);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{15, 0, 0, 0}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add вычитание отрицательного дробного и нуля
#test sub_negative_float_and_zero
s21_decimal value_1 = {{15, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_scale(&value_1, 7);
set_sign(&value_1, minus);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{15, 0, 0, 0}};
set_scale(&expected, 7);
set_sign(&value_1, minus);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание нуля и отрицательного дробного
#test sub_zero_and_negative_float
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0}};
set_scale(&value_2, 7);
set_sign(&value_2, minus);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{15, 0, 0, 0}};
set_scale(&expected, 7);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// ОКРУГЛЕНИЕ - поменять название тестов
//  Функция s21_sub сложение двух положительных чисел с большой мантиссой с
//  ненулевыми разрядами
// #test sub_positive_float_big_scale
// s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
// s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
// set_scale(&value_1, 28);
// set_scale(&value_2, 27);
// s21_decimal result = {{0, 0, 0, 0}};
// s21_decimal expected = ???;
// set_scale(&expected, ???);
// int return_code = s21_sub(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);
//
//// Функция s21_sub сложение двух отрицательных чисел с большой мантиссой с
/// ненулевыми разрядами
// #test sub_negative_float_big_scale
// s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// set_scale(&value_1, 28);
// set_scale(&value_2, 27);
// s21_decimal result = {{0, 0, 0, 0}};
// s21_decimal expected = ???;
// set_scale(&expected, ???);
// int return_code = s21_sub(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);
//
//// Функция s21_sub сложение отрицательного и положительного с большой
/// мантиссой с ненулевыми разрядами
// #test sub_negative_and_positive_float_big_scale
// s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
// set_scale(&value_1, 28);
// set_scale(&value_2, 27);
// s21_decimal result = {{0, 0, 0, 0}};
// s21_decimal expected = ???;
// set_scale(&expected, ???);
// int return_code = s21_sub(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);
//
//// Функция s21_sub сложение положительного и отрицательного с большой
/// мантиссой с ненулевыми разрядами
// #test sub_positive_and_negative_float_big_scale
// s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
// s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// set_scale(&value_1, 28);
// set_scale(&value_2, 27);
// s21_decimal result = {{0, 0, 0, 0}};
// s21_decimal expected = ???;
// set_scale(&expected, ???);
// int return_code = s21_sub(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);

// s21_mul
// s21_mul
// Функция s21_mul умножение двух положительных чисел
#test mul_positive_numbers
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{200, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение двух отрицательных чисел
#test mul_negative_numbers
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{200, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение положительного и отрицательного чисел
#test mul_positive_and_negative
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{200, 0, 0, 0x80000000}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного и положительного чисел
#test mul_negative_and_positive
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{200, 0, 0, 0x80000000}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение двух положительных дробных
#test mul_positive_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{2, 0, 0, 0}};
set_scale(&expected, 13);
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение двух отрицательных дробных
#test mul_negative_float
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{2, 0, 0, 0}};
set_scale(&expected, 13);
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение положительного и отрицательного дробных
#test mul_positive_and_negative_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{2, 0, 0, 0x80000000}};
set_scale(&expected, 13);
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного и положительного дробных
#test mul_negative_and_positive_float
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{2, 0, 0, 0x80000000}};
set_scale(&expected, 13);
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение положительного дробного и целого
#test mul_positive_float_int
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_scale(&value_1, 10);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{2, 0, 0, 0}};
set_scale(&expected, 8);
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного дробного и целого
#test mul_negative_float_int
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
set_scale(&value_1, 10);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{2, 0, 0, 0}};
set_scale(&expected, 8);
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного дробного и положительного целого
#test mul_negative_float_positive_int
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_scale(&value_1, 10);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{2, 0, 0, 0x80000000}};
set_scale(&expected, 8);
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение положительного дробного и отрицательного целого
#test mul_positive_float_negative_int
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
set_scale(&value_1, 10);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{2, 0, 0, 0x80000000}};
set_scale(&expected, 8);
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение положительного целого отрицательного дробного
#test mul_positive_int_negative_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
set_scale(&value_2, 5);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{2, 0, 0, 0x80000000}};
set_scale(&expected, 3);
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного целого положительного дробного
#test mul_negative_int_positive_float
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_scale(&value_2, 5);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{2, 0, 0, 0x80000000}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul очень большое число и маленькое - переполнение
#test mul_overflow
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{2, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_mul умножение очень маленького и очень большого - переполнение
#test mul_overflow_two
s21_decimal value_1 = {{2, 0, 0, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_mul умножение двух очень больших - переполнение
#test mul_overflow_three
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_mul умножение двух очень больших отрицательное и положительное -
// переполнение
#test mul_overflow_four
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_mul умножение двух очень больших положительное и отрицательное -
// переполнение
#test mul_overflow_five
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_mul умножение отрицательных очень большое число и маленькое -
// переполнение
#test mul_overflow_negative
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal value_2 = {{2, 0, 0, 0x80000000}};
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_mul умножение отрицательных очень маленького и очень большого -
// переполнение
#test mul_overflow_negative_two
s21_decimal value_1 = {{2, 0, 0, 0x80000000}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_mul умножение отрицательных двух очень больших - переполнение
#test mul_overflow_negative_three
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_mul умножение двух нулей
#test mul_positive_numbers_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение положительного и отрицательного нуля
#test mul_positive_and_negative_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0x80000000}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного и положительного нуля
#test mul_negative_and_positive_zero
s21_decimal value_1 = {{0, 0, 0, 0x80000000}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательных нулей
#test mul_negative_numbers_zero
s21_decimal value_1 = {{0, 0, 0, 0x80000000}};
s21_decimal value_2 = {{0, 0, 0, 0x80000000}};
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_mul умножение положительного числа и нуля
#test mul_positive_numbers_and_zero
s21_decimal value_1 = {{15, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение нуля и положительного числа
#test mul_zero_and_positive_numbers
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение положительного дробного и нуля
#test mul_positive_float_and_zero
s21_decimal value_1 = {{15, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_scale(&value_1, 7);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение нуля и положительного дробного
#test mul_zero_and_positive_float
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0}};
set_scale(&value_2, 7);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного числа и нуля
#test mul_negative_numbers_and_zero
s21_decimal value_1 = {{15, 0, 0, 0x80000000}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение нуля и отрицательного числа
#test mul_zero_and_negative_numbers
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0x80000000}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного дробного и нуля
#test mul_negative_float_and_zero
s21_decimal value_1 = {{15, 0, 0, 0x80000000}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_scale(&value_1, 7);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение нуля и отрицательного дробного
#test mul_zero_and_negative_float
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0x80000000}};
set_scale(&value_2, 7);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение двух положительных чисел с большой мантиссой
#test mul_positive_float_big_scale
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{2, 0, 0, 0}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_mul умножение двух отрицательных чисел с большой мантиссой
#test mul_negative_float_big_scale
s21_decimal value_1 = {{1, 0, 0, 0x80000000}};
s21_decimal value_2 = {{2, 0, 0, 0x80000000}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_mul умножение отрицательного и положительного с большой мантиссой
#test mul_negative_and_positive_float_big_scale
s21_decimal value_1 = {{1, 0, 0, 0x80000000}};
s21_decimal value_2 = {{2, 0, 0, 0}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_mul умножение положительного и отрицательного с большой мантиссой
#test mul_positive_and_negative_float_big_scale
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{2, 0, 0, 0x80000000}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_mul умножение двух положительных чисел с большой мантиссой с
// ненулевыми разрядами
#test mul_positive_float_big_scale_not_zero
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_mul умножение двух отрицательных чисел с большой мантиссой с
// ненулевыми разрядами
#test mul_negative_float_big_scale_not_zero
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_mul умножение отрицательного и положительного с большой мантиссой
// с ненулевыми разрядами
#test mul_negative_and_positive_float_big_scale_not_zero
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_mul умножение положительного и отрицательного с большой мантиссой
// с ненулевыми разрядами
#test mul_positive_and_negative_float_big_scale_not_zero
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result = {{0, 0, 0, 0}};

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_mul умножение целые большие числа с нулями
// Функция s21_mul очень большое целое число на очень маленькое число с
// плавающей точкой (отриц и положит)

// Функция s21_mul умножение двух положительных дробных результат 5
#test mul_positive_float__
s21_decimal value_1 = {{50, 0, 0, 0}};
s21_decimal value_2 = {{10, 0, 0, 0}};
set_scale(&value_2, 2);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{5, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение двух положительных дробных результат 5
#test mul_positive_float____
s21_decimal value_1 = {{5, 0, 0, 0}};
s21_decimal value_2 = {{10, 0, 0, 0}};
set_scale(&value_2, 1);
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{5, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);