#include <check.h>
#include <stdio.h>

#include "../s21_decimal.h"
#include "debug_helper.h"

// set_sign
// Функция set_sign поставить знак плюс
#test set_sign_positive
  big_decimal value = {0};
  Bset_sign(&value, plus);

  ck_assert(((value.bits[3] >> 31) & 1) == plus);

  // Функция set_sign поставить знак минус

#test set_sign_negative
  big_decimal value = {0};
  Bset_sign(&value, minus);

  ck_assert(((value.bits[6] >> 31) & 1) == minus);

  // get_sign
  //  Функция get_sign проверить знак плюс

#test get_sign_positive
  big_decimal value = {0};
  Bset_sign(&value, plus);

  ck_assert(Bget_sign(value) == plus);

  // Функция get_sign проверить знак плюс

#test get_sign_negative
  big_decimal value = {0};
  Bset_sign(&value, minus);

  ck_assert(Bget_sign(value) == minus);

  // set_bit
  //  Функция set_bit поменять бит 0 на бит 0 индекс 0

#test set_bit_zero_false
  big_decimal value = (big_decimal){{0}};
  Bset_bit(&value, 0, false);

  ck_assert(Bget_bit(value, 0) == false);

  // Функция set_bit поменять бит 0 на бит 1 индекс 0

#test set_bit_zero_true
  big_decimal value = (big_decimal){{0}};
  Bset_bit(&value, 0, true);

  ck_assert(Bget_bit(value, 0) == true);

  // Функция set_bit поменять бит 1 на бит 0 индекс 0

#test set_bit_one_false
  big_decimal value = (big_decimal){{1}};
  Bset_bit(&value, 0, false);

  ck_assert(Bget_bit(value, 0) == false);

  // Функция set_bit поменять бит 1 на бит 1 индекс 0

#test set_bit_one_true
  big_decimal value = (big_decimal){{1}};
  Bset_bit(&value, 0, true);

  ck_assert(Bget_bit(value, 0) == true);

  // Функция set_bit поменять бит 0 на бит 0 индекс 16

#test set_bit_middle_false
  big_decimal value = (big_decimal){{0}};
  Bset_bit(&value, 16, false);

  ck_assert(Bget_bit(value, 16) == false);

  // Функция set_bit поменять бит 0 на бит 1 индекс 16

#test set_bit_middle_true
  big_decimal value = (big_decimal){{0}};
  Bset_bit(&value, 16, true);

  ck_assert(Bget_bit(value, 16) == true);

  // Функция set_bit поменять бит 1 на бит 0 индекс 16

#test set_bit_middle_false_one
  big_decimal value = (big_decimal){{1}};
  Bset_bit(&value, 16, false);

  ck_assert(Bget_bit(value, 16) == false);

  // Функция set_bit поменять бит 1 на бит 1 индекс 16

#test set_bit_middle_true_one
  big_decimal value = (big_decimal){{1}};
  Bset_bit(&value, 16, true);

  ck_assert(Bget_bit(value, 16) == true);

  // Функция set_bit поменять бит 1 на бит 0 индекс 96

#test set_bit_overflow_false_one
  big_decimal value = (big_decimal){{1}};
  Bset_bit(&value, 96, false);

  ck_assert(Bget_bit(value, 96) == false);

  // s21_add
  // Функция s21_add сложение двух положительных чисел

#test add_positive_numbers
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{30, 0, 0, 0}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // s21_add
  // Функция s21_add сложение двух больших положительных чисел

#test add_big_positive_numbers
  s21_decimal value_1 = (s21_decimal){{10, 30, 60000, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 30, 60000, 0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{30, 60, 120000, 0}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение двух отрицательных чисел

#test add_negative_numbers
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0x80000000}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{30, 0, 0, 0x80000000}};

  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение положительного и отрицательного чисел

#test add_positive_and_negative
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0x80000000}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{10, 0, 0, 0x80000000}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение отрицательного и положительного чисел

#test add_negative_and_positive
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{10, 0, 0, 0}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение двух положительных дробных

#test add_positive_float
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{200001, 0, 0, 0}};
  set_scale(&expected, 9);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение двух больших положительных дробных
  // #test add_big_positive_float
  // s21_decimal value_1 = {1, 0, 565264864, 0};
  // s21_decimal value_2 = (s21_decimal){{0}};
  // str_to_decimal("50000000")
  // s21_decimal result = (s21_decimal){{0}};
  // s21_decimal expected = (s21_decimal){{200001, 0, 0, 0}};
  // set_scale(&expected, 9);
  // int return_code = s21_add(value_1, value_2, &result);

  // ck_assert(s21_is_equal(result, expected) == 1);
  // ck_assert(return_code == 0);

  // Функция s21_add сложение двух отрицательных дробных

#test add_negative_float
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0x80000000}};
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{200001, 0, 0, 0x80000000}};
  set_scale(&expected, 9);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение положительного и отрицательного дробных

#test add_positive_and_negative_float
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0x80000000}};
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{199999, 0, 0, 0x80000000}};
  set_scale(&expected, 9);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение отрицательного и положительного дробных

#test add_negative_and_positive_float
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{199999, 0, 0, 0}};
  set_scale(&expected, 9);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);
  // Функция s21_add сложение положительного дробного и целого

#test add_positive_float_int
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{2820130817U, 4, 0, 0}};
  set_scale(&expected, 9);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение отрицательного дробного и целого

#test add_negative_float_int
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0x80000000}};
  set_scale(&value_1, 10);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{2820130817U, 4, 0, 0x80000000}};
  set_scale(&expected, 9);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение отрицательного дробного и положительного целого

#test add_negative_float_positive_int
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{2820130815U, 4, 0, 0}};
  set_scale(&expected, 9);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение положительного дробного и отрицательного целого

#test add_positive_float_negative_int
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0x80000000}};
  set_scale(&value_1, 10);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{2820130815U, 4, 0, 0x80000000}};
  set_scale(&expected, 9);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение положительного целого отрицательного дробного

#test add_positive_int_negative_float
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0x80000000}};
  set_scale(&value_2, 5);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{99998, 0, 0, 0}};
  set_scale(&expected, 4);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);
  //
  //// Функция s21_add сложение отрицательного целого положительного дробного

#test add_negative_int_positive_float
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_scale(&value_2, 5);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{99998, 0, 0, 0x80000000}};
  set_scale(&expected, 4);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add очень большое число и маленькое - переполнение

#test add_overflow
  s21_decimal value_1 = (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal value_2 = (s21_decimal){{1, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};

  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(return_code == 1);

  // Функция s21_add сложение очень маленького и очень большого - переполнение

#test add_overflow_two
  s21_decimal value_1 = (s21_decimal){{1, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal result = (s21_decimal){{0}};

  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(return_code == 1);

  // Функция s21_add сложение двух очень больших - переполнение ????
  // 79228162514264337593543950335+79228162514264337593543950335=79228162514264337593543950334

#test add_overflow_three
  s21_decimal value_1 = (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal value_2 = (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal result = (s21_decimal){{0}};

  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(return_code == 1);

  // Функция s21_add сложение отрицательных очень большое число и маленькое -
  // переполнение отрицательная бесконечность

#test add_overflow_negative
  s21_decimal value_1 =
      (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{1, 0, 0, 0x80000000}};
  s21_decimal result = (s21_decimal){{0}};

  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(return_code == 2);

  // Функция s21_add сложение отрицательных очень маленького и очень большого -
  // переполнение отрицательная бесконечность

#test add_overflow_negative_two
  s21_decimal value_1 = (s21_decimal){{1, 0, 0, 0x80000000}};
  s21_decimal value_2 =
      (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  s21_decimal result = (s21_decimal){{0}};

  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(return_code == 2);

  // Функция s21_add сложение отрицательных двух очень больших - переполнение
  // ???
  //-79228162514264337593543950335-79228162514264337593543950335=-79228162514264337593543950334

#test add_overflow_negative_three
  s21_decimal value_1 =
      (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  s21_decimal value_2 =
      (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  s21_decimal result = (s21_decimal){{0}};

  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(return_code == 2);

  // Функция s21_add сложение двух нулей

#test add_positive_numbers_zero
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0, 0, 0, 0}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение положительного и отрицательного нуля

#test add_positive_and_negative_zero
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0x80000000}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0, 0, 0, 0}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение отрицательного и положительного нуля

#test add_negative_and_positive_zero
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0, 0, 0, 0}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение отрицательных нулей

#test add_negative_numbers_zero
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0x80000000}};
  s21_decimal expected = (s21_decimal){{0, 0, 0, 0x80000000}};
  s21_decimal result = (s21_decimal){{0}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение положительного числа и нуля

#test add_positive_numbers_and_zero
  s21_decimal value_1 = (s21_decimal){{15, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{15, 0, 0, 0}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение нуля и положительного числа

#test add_zero_and_positive_numbers
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{15, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{15, 0, 0, 0}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение положительного дробного и нуля

#test add_positive_float_and_zero
  s21_decimal value_1 = (s21_decimal){{15, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  set_scale(&value_1, 7);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{15, 0, 0, 0}};
  set_scale(&expected, 7);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение нуля и положительного дробного

#test add_zero_and_positive_float
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{15, 0, 0, 0}};
  set_scale(&value_2, 7);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{15, 0, 0, 0}};
  set_scale(&expected, 7);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение отрицательного числа и нуля

#test add_negative_numbers_and_zero
  s21_decimal value_1 = (s21_decimal){{15, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{15, 0, 0, 0x80000000}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение нуля и отрицательного числа

#test add_zero_and_negative_numbers
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{15, 0, 0, 0x80000000}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{15, 0, 0, 0x80000000}};
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение отрицательного дробного и нуля

#test add_negative_float_and_zero
  s21_decimal value_1 = (s21_decimal){{15, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  set_scale(&value_1, 7);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{15, 0, 0, 0x80000000}};
  set_scale(&expected, 7);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение нуля и отрицательного дробного

#test add_zero_and_negative_float
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{15, 0, 0, 0x80000000}};
  set_scale(&value_2, 7);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{15, 0, 0, 0x80000000}};
  set_scale(&expected, 7);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение двух положительных чисел с большой мантиссой

#test add_positive_float_big_scale
  s21_decimal value_1 = (s21_decimal){{1, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{2, 0, 0, 0}};
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{21, 0, 0, 0}};
  set_scale(&expected, 28);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение двух отрицательных чисел с большой мантиссой

#test add_negative_float_big_scale_
  s21_decimal value_1 = (s21_decimal){{1, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{2, 0, 0, 0x80000000}};
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{21, 0, 0, 0x80000000}};
  set_scale(&expected, 28);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение отрицательного и положительного с большой
  // мантиссой

#test add_negative_and_positive_float_big_scale_
  s21_decimal value_1 = (s21_decimal){{1, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{2, 0, 0, 0}};
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{19, 0, 0, 0}};
  set_scale(&expected, 28);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение положительного и отрицательного с большой
  // мантиссой

#test add_positive_and_negative_float_big_scale
  s21_decimal value_1 = (s21_decimal){{1, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{2, 0, 0, 0x80000000}};
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{19, 0, 0, 0x80000000}};
  set_scale(&expected, 28);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // s21_sub
  // Функция s21_sub вычитание двух положительных целых чисел

#test test_add_1
  // -7922816251426433759354395033.5
  s21_decimal value_1 = (s21_decimal){{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x80010000}};
  // -1.0000000000000000000000000001
  s21_decimal value_2 = (s21_decimal){{0x10000001, 0x3E250261, 0x204FCE5E, 0x801C0000}};
  // -7922816251426433759354395035
  s21_decimal expected = (s21_decimal){{0x9999999B, 0x99999999, 0x19999999, 0x80000000}};
  s21_decimal result = (s21_decimal){{0}};
  int return_code = s21_add(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);
  
#test sub_positive_numbers
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{10, 0, 0, 0x80000000}};
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание двух отрицательных целых чисел

#test sub_negative_numbers
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_sign(&value_1, minus);
  set_sign(&value_2, minus);
  s21_decimal expected = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание позитивного и отрицательного целых чисел

#test sub_positive_and_negative
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_sign(&value_2, minus);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{30, 0, 0, 0}};
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание отрицательного и позитивного целых чисел

#test sub_negative_and_positive
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_sign(&value_1, minus);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{30, 0, 0, 0x80000000}};
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание двух положительных дробных чисел

#test sub_positive_float
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{199999, 0, 0, 0x80000000}};
  set_scale(&expected, 9);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание двух отрицательных дробных чисел

#test sub_negative_float
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_sign(&value_1, minus);
  set_sign(&value_2, minus);
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{199999, 0, 0, 0}};
  set_scale(&expected, 9);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание положительного и отрицательного дробных чисел

#test sub_positive_and_negative_float
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_sign(&value_2, minus);
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{200001, 0, 0, 0}};
  set_scale(&expected, 9);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание отрицательного и положительного дробных чисел

#test sub_negative_and_positive_float
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_sign(&value_1, minus);
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{200001, 0, 0, 0x80000000}};
  set_scale(&expected, 9);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание положительных дробного и целого

#test sub_positive_float_int
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{2820130815U, 4, 0, 0x80000000}};
  set_scale(&expected, 9);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание отрицательных дробного и целого

#test sub_negative_float_int
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_sign(&value_1, minus);
  set_sign(&value_2, minus);
  set_scale(&value_1, 10);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{2820130815U, 4, 0, 0}};
  set_scale(&expected, 9);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание отрицательного дробного и положительного целого

#test sub_negative_float_positive_int
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_sign(&value_1, minus);
  set_scale(&value_1, 10);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{2820130817U, 4, 0, 0x80000000}};
  set_scale(&expected, 9);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание положительного дробного и отрицательного целого

#test sub_positive_float_negative_int
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  set_sign(&value_2, minus);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{2820130817U, 4, 0, 0}};
  set_scale(&expected, 9);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание положительного целого и отрицательного дробного

#test sub_positive_int_negative_float
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_sign(&value_2, minus);
  set_scale(&value_2, 5);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{100002, 0, 0, 0}};
  set_scale(&expected, 4);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание отрицательного целого и положительного дробного

#test sub_negative_int_positive_float
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_sign(&value_1, minus);
  set_scale(&value_2, 5);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{100002, 0, 0, 0x80000000}};
  set_scale(&expected, 4);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание максимального отрицательного из максимального
  // положительного

#test sub_overflow
  s21_decimal value_1 = (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal value_2 = (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  set_sign(&value_1, minus);
  s21_decimal result = (s21_decimal){{0}};

  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(return_code == 2);

  // Функция s21_sub вычитание минимального отрицательного и максимального
  // положительного

#test sub_overflow_two
  s21_decimal value_1 = (s21_decimal){{1, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  set_sign(&value_1, minus);
  s21_decimal result = (s21_decimal){{0}};

  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(return_code == 2);

  // Функция s21_sub вычитание максимального отрицательного и минимального
  // положительного

#test sub_overflow_negative
  s21_decimal value_1 = (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal value_2 = (s21_decimal){{1, 0, 0, 0}};
  set_sign(&value_1, minus);
  s21_decimal result = (s21_decimal){{0}};

  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(return_code == 2);

  // Функция s21_sub вычитание нулей

#test sub_positive_numbers_zero
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0, 0, 0, 0}};
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание нулей

#test sub_positive_and_negative_zero
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  set_sign(&value_2, minus);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0, 0, 0, 0}};
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание нулей

#test sub_negative_and_positive_zero
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  set_sign(&value_1, minus);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-0", &expected);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание нулей

#test sub_negative_numbers_zero
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  set_sign(&value_1, minus);
  set_sign(&value_2, minus);
  s21_decimal expected = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание положительных чисел с большим скейлом

#test sub_positive_float_big_scale
  s21_decimal value_1 = (s21_decimal){{1, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{2, 0, 0, 0}};
  set_scale(&value_1, MAX_SCALE);
  set_scale(&value_2, 27);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{19, 0, 0, 0x80000000}};
  set_scale(&expected, 28);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание отрицательных чисел с большим скейлом

#test sub_negative_float_big_scale
  s21_decimal value_1 = (s21_decimal){{1, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{2, 0, 0, 0}};
  set_sign(&value_1, minus);
  set_sign(&value_2, minus);
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{19, 0, 0, 0}};
  set_scale(&expected, 28);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание отрицательного и положительного чисел с большим
  // скейлом

#test sub_negative_and_positive_float_big_scale
  s21_decimal value_1 = (s21_decimal){{1, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{2, 0, 0, 0}};
  set_sign(&value_1, minus);
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{21, 0, 0, 0x80000000}};
  set_scale(&expected, 28);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание полоижтельного и отрицательного чисел с большим
  // скейлом

#test sub_positive_and_negative_float_big_scale
  s21_decimal value_1 = (s21_decimal){{1, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{2, 0, 0, 0}};
  set_sign(&value_2, minus);
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{21, 0, 0, 0}};
  set_scale(&expected, 28);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание положительного числа и нуля

#test sub_positive_numbers_and_zero
  s21_decimal value_1 = (s21_decimal){{15, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{15, 0, 0, 0}};
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание нуля и положительного числа

#test sub_zero_and_positive_numbers
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{15, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{15, 0, 0, 0}};
  set_sign(&expected, minus);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание положительного дробного и нуля

#test sub_positive_float_and_zero
  s21_decimal value_1 = (s21_decimal){{15, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  set_scale(&value_1, 7);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{15, 0, 0, 0}};
  set_scale(&expected, 7);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание нуля и положительного дробного

#test sub_zero_and_positive_float
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{15, 0, 0, 0}};
  set_scale(&value_2, 7);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{15, 0, 0, 0}};
  set_scale(&expected, 7);
  set_sign(&expected, minus);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание отрицательного числа и нуля

#test sub_negative_numbers_and_zero
  s21_decimal value_1 = (s21_decimal){{15, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  set_sign(&value_1, minus);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{15, 0, 0, 0}};
  set_sign(&expected, minus);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание нуля и отрицательного числа

#test sub_zero_and_negative_numbers
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{15, 0, 0, 0}};
  set_sign(&value_2, minus);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{15, 0, 0, 0}};
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание отрицательного дробного и нуля

#test sub_negative_float_and_zero
  s21_decimal value_1 = (s21_decimal){{15, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  set_scale(&value_1, 7);
  set_sign(&value_1, minus);

  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{15, 0, 0, 0x80000000}};
  set_scale(&expected, 7);
  set_sign(&value_1, minus);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание нуля и отрицательного дробного

#test sub_zero_and_negative_float
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{15, 0, 0, 0}};
  set_scale(&value_2, 7);
  set_sign(&value_2, minus);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{15, 0, 0, 0}};
  set_scale(&expected, 7);
  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // s21_mul
  // s21_mul
  // Функция s21_mul умножение двух положительных чисел

#test mul_positive_numbers
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{200, 0, 0, 0}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение двух отрицательных чисел

#test mul_negative_numbers
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0x80000000}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{200, 0, 0, 0}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение положительного и отрицательного чисел

#test mul_positive_and_negative
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0x80000000}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{200, 0, 0, 0x80000000}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение отрицательного и положительного чисел

#test mul_negative_and_positive
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{200, 0, 0, 0x80000000}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение двух положительных дробных

#test mul_positive_float
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{2, 0, 0, 0}};
  set_scale(&expected, 13);
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение двух отрицательных дробных

#test mul_negative_float
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0x80000000}};
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{2, 0, 0, 0}};
  set_scale(&expected, 13);
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  //// Функция s21_mul умножение положительного и отрицательного дробных

#test mul_positive_and_negative_float
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0x80000000}};
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{2, 0, 0, 0x80000000}};
  set_scale(&expected, 13);
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение отрицательного и положительного дробных

#test mul_negative_and_positive_float
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{2, 0, 0, 0x80000000}};
  set_scale(&expected, 13);
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение положительного дробного и целого

#test mul_positive_float_int
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{2, 0, 0, 0}};
  set_scale(&expected, 8);
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение отрицательного дробного и целого

#test mul_negative_float_int
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0x80000000}};
  set_scale(&value_1, 10);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{2, 0, 0, 0}};
  set_scale(&expected, 8);
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение отрицательного дробного и положительного целого

#test mul_negative_float_positive_int
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{2, 0, 0, 0x80000000}};
  set_scale(&expected, 8);
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение положительного дробного и отрицательного целого

#test mul_positive_float_negative_int
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0x80000000}};
  set_scale(&value_1, 10);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{2, 0, 0, 0x80000000}};
  set_scale(&expected, 8);
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение положительного целого отрицательного дробного

#test mul_positive_int_negative_float
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0x80000000}};
  set_scale(&value_2, 5);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{2, 0, 0, 0x80000000}};
  set_scale(&expected, 3);
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение отрицательного целого положительного дробного

#test mul_negative_int_positive_float
  s21_decimal value_1 = (s21_decimal){{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{20, 0, 0, 0}};
  set_scale(&value_2, 5);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{2, 0, 0, 0x80000000}};
  int return_code = s21_mul(value_1, value_2, &result);
  set_scale(&expected, 3);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul очень большое число и маленькое - переполнение

#test mul_overflow
  s21_decimal value_1 = (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal value_2 = (s21_decimal){{2, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 1);

  // Функция s21_mul умножение очень маленького и очень большого - переполнение

#test mul_overflow_two
  s21_decimal value_1 = (s21_decimal){{2, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal result = (s21_decimal){{0}};

  int return_code = s21_mul(value_1, value_2, &result);
  ck_assert(return_code == 1);

  // Функция s21_mul умножение двух очень больших - переполнение

#test mul_overflow_three
  s21_decimal value_1 = (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal value_2 = (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal result = (s21_decimal){{0}};

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 1);

  // Функция s21_mul умножение двух очень больших отрицательное и положительное
  // - переполнение

#test mul_overflow_four
  s21_decimal value_1 =
      (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal result = (s21_decimal){{0}};

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 2);

  // Функция s21_mul умножение двух очень больших положительное и отрицательное
  // - переполнение

#test mul_overflow_five
  s21_decimal value_1 = (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal value_2 =
      (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  s21_decimal result = (s21_decimal){{0}};

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 2);

  // Функция s21_mul умножение отрицательных очень большое число и маленькое -
  // переполнение

#test mul_overflow_negative
  s21_decimal value_1 =
      (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{2, 0, 0, 0x80000000}};
  s21_decimal result = (s21_decimal){{0}};

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 1);

  // Функция s21_mul умножение отрицательных очень маленького и очень большого -
  // переполнение

#test mul_overflow_negative_two
  s21_decimal value_1 = (s21_decimal){{2, 0, 0, 0x80000000}};
  s21_decimal value_2 =
      (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  s21_decimal result = (s21_decimal){{0}};

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 1);

  // Функция s21_mul умножение отрицательных двух очень больших - переполнение

#test mul_overflow_negative_three
  s21_decimal value_1 =
      (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  s21_decimal value_2 =
      (s21_decimal){{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
  s21_decimal result = (s21_decimal){{0}};

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 1);

  // Функция s21_mul умножение двух нулей

#test mul_positive_numbers_zero
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0, 0, 0, 0}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение положительного и отрицательного нуля

#test mul_positive_and_negative_zero
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0x80000000}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0, 0, 0, 0x80000000}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение отрицательного и положительного нуля

#test mul_negative_and_positive_zero
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0, 0, 0, 0x80000000}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение отрицательных нулей

#test mul_negative_numbers_zero
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0x80000000}};
  s21_decimal result = (s21_decimal){{0}};

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 0);

  // Функция s21_mul умножение положительного числа и нуля

#test mul_positive_numbers_and_zero
  s21_decimal value_1 = (s21_decimal){{15, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0, 0, 0, 0}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение нуля и положительного числа

#test mul_zero_and_positive_numbers
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{15, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0, 0, 0, 0}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение положительного дробного и нуля

#test mul_positive_float_and_zero
  s21_decimal value_1 = (s21_decimal){{15, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  set_scale(&value_1, 7);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0, 0, 0, 0}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение нуля и положительного дробного

#test mul_zero_and_positive_float
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{15, 0, 0, 0}};
  set_scale(&value_2, 7);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0, 0, 0, 0}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение отрицательного числа и нуля

#test mul_negative_numbers_and_zero
  s21_decimal value_1 = (s21_decimal){{15, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0, 0, 0, 0x80000000}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение нуля и отрицательного числа

#test mul_zero_and_negative_numbers
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{15, 0, 0, 0x80000000}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0, 0, 0, 0x80000000}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение отрицательного дробного и нуля

#test mul_negative_float_and_zero
  s21_decimal value_1 = (s21_decimal){{15, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  set_scale(&value_1, 7);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0, 0, 0, 0x80000000}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение нуля и отрицательного дробного

#test mul_zero_and_negative_float
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{15, 0, 0, 0x80000000}};
  set_scale(&value_2, 7);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0, 0, 0, 0x80000000}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);


  // Функция s21_mul умножение двух отрицательных чисел с большой мантиссой

  // Функция s21_mul умножение двух положительных чисел с большой мантиссой с
  // ненулевыми разрядами


  // Функция s21_mul умножение отрицательного и положительного с большой
  // мантиссой / с ненулевыми разрядами


  // Функция s21_mul умножение целые большие числа с нулями
  // Функция s21_mul очень большое целое число на очень маленькое число с
  // плавающей точкой (отриц и положит)

  // Функция s21_mul умножение двух положительных дробных результат 5

#test mul_positive_float__
  s21_decimal value_1 = (s21_decimal){{50, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{10, 0, 0, 0}};
  set_scale(&value_2, 2);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{5, 0, 0, 0}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_mul умножение двух положительных дробных результат 5

#test mul_positive_float____
  s21_decimal value_1 = (s21_decimal){{5, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{10, 0, 0, 0}};
  set_scale(&value_2, 1);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{5, 0, 0, 0}};
  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

#test positive_s21_is_equal_00
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  bool result = s21_is_equal(value_1, value_2);
  ck_assert(result == 1);

#test positive_s21_is_equal_01
  s21_decimal value_1 = (s21_decimal){{0, 500, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 500, 1, 0}};
  set_sign(&value_1, minus);
  set_sign(&value_2, minus);
  set_scale(&value_1, 27);
  set_scale(&value_2, 27);
  bool result = s21_is_equal(value_1, value_2);
  ck_assert(result == 1);

#test negative_s21_is_equal_00
  s21_decimal value_1 = (s21_decimal){{1, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  bool result = s21_is_equal(value_1, value_2);
  ck_assert(result == 0);

#test negative_s21_is_equal_01
  s21_decimal value_1 = (s21_decimal){{1, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{1, 0, 0, 0}};
  set_sign(&value_1, minus);
  bool result = s21_is_equal(value_1, value_2);
  ck_assert(result == 0);

#test negative_s21_is_equal_02
  s21_decimal value_1 = (s21_decimal){{1, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{1, 0, 0, 0}};
  set_scale(&value_1, 27);
  bool result = s21_is_equal(value_1, value_2);
  ck_assert(result == 0);

#test negative_s21_is_equal_03
  s21_decimal value_1 = (s21_decimal){{0, 1, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  bool result = s21_is_equal(value_1, value_2);
  ck_assert(result == 0);

#test s21_is_equal_1
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  str_to_decimal("0", &value_1);
  str_to_decimal("-0", &value_2);
  bool result = s21_is_equal(value_1, value_2);
  ck_assert(result == 1);

#test negative_s21_is_not_equal_00
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  bool result = s21_is_not_equal(value_1, value_2);
  ck_assert(result == 0);

#test negative_s21_is_not_equal_01
  s21_decimal value_1 = (s21_decimal){{0, 500, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 500, 1, 0}};
  set_sign(&value_1, minus);
  set_sign(&value_2, minus);
  set_scale(&value_1, 27);
  set_scale(&value_2, 27);
  bool result = s21_is_not_equal(value_1, value_2);
  ck_assert(result == 0);

#test positive_s21_is_not_equal_00
  s21_decimal value_1 = (s21_decimal){{1, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  bool result = s21_is_not_equal(value_1, value_2);
  ck_assert(result == 1);

#test positive_s21_is_not_equal_01
  s21_decimal value_1 = (s21_decimal){{1, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{1, 0, 0, 0}};
  set_sign(&value_1, minus);
  bool result = s21_is_not_equal(value_1, value_2);
  ck_assert(result == 1);

#test positive_s21_is_not_equal_02
  s21_decimal value_1 = (s21_decimal){{1, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{1, 0, 0, 0}};
  set_scale(&value_1, 27);
  bool result = s21_is_not_equal(value_1, value_2);
  ck_assert(result == 1);

#test positive_s21_is_not_equal_03
  s21_decimal value_1 = (s21_decimal){{0, 1, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  bool result = s21_is_not_equal(value_1, value_2);
  ck_assert(result == 1);

#test positive_s21_is_less_00
  s21_decimal value_1 = (s21_decimal){{0, 1, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 1, 0}};
  bool result = s21_is_less(value_1, value_2);
  ck_assert(result == 1);

#test positive_s21_is_less_01
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 1, 0}};
  bool result = s21_is_less(value_1, value_2);
  ck_assert(result == 1);

#test positive_s21_is_less_02
  s21_decimal value_1 = (s21_decimal){{0, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 1, 0}};
  set_sign(&value_1, minus);
  bool result = s21_is_less(value_1, value_2);
  ck_assert(result == 1);

#test positive_s21_is_less_03
  s21_decimal value_1 = (s21_decimal){{1, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{1, 0, 1, 0}};
  set_scale(&value_1, 27);
  set_scale(&value_2, 26);
  bool result = s21_is_less(value_1, value_2);
  ck_assert(result == 1);

#test negative_s21_is_less_00
  s21_decimal value_1 = (s21_decimal){{0, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 1, 0, 0}};
  bool result = s21_is_less(value_1, value_2);
  ck_assert(result == 0);

#test negative_s21_is_less_01
  s21_decimal value_1 = (s21_decimal){{0, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  bool result = s21_is_less(value_1, value_2);
  ck_assert(result == 0);

#test negative_s21_is_less_02
  s21_decimal value_1 = (s21_decimal){{0, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 1, 0}};
  set_sign(&value_2, minus);
  bool result = s21_is_less(value_1, value_2);
  ck_assert(result == 0);

#test negative_s21_is_less_03
  s21_decimal value_1 = (s21_decimal){{1, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{1, 0, 1, 0}};
  set_scale(&value_1, 25);
  set_scale(&value_2, 26);
  bool result = s21_is_less(value_1, value_2);
  ck_assert(result == 0);

#test negative_s21_is_less_04
  s21_decimal value_1 = (s21_decimal){{1, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{1, 0, 1, 0}};
  bool result = s21_is_less(value_1, value_2);
  ck_assert(result == 0);

#test negative_s21_is_greater_00
  s21_decimal value_1 = (s21_decimal){{0, 1, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 1, 0}};
  bool result = s21_is_greater(value_1, value_2);
  ck_assert(result == 0);

#test negative_s21_is_greater_01
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 1, 0}};
  bool result = s21_is_greater(value_1, value_2);
  ck_assert(result == 0);

#test negative_s21_is_greater_02
  s21_decimal value_1 = (s21_decimal){{0, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 1, 0}};
  set_sign(&value_1, minus);
  bool result = s21_is_greater(value_1, value_2);
  ck_assert(result == 0);

#test negative_s21_is_greater_03
  s21_decimal value_1 = (s21_decimal){{1, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{1, 0, 1, 0}};
  set_scale(&value_1, 27);
  set_scale(&value_2, 26);
  bool result = s21_is_greater(value_1, value_2);
  ck_assert(result == 0);

#test negative_s21_is_greater_04
  s21_decimal value_1 = (s21_decimal){{1, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{1, 0, 1, 0}};
  bool result = s21_is_greater(value_1, value_2);
  ck_assert(result == 0);

#test positive_s21_is_greater_00
  s21_decimal value_1 = (s21_decimal){{0, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 1, 0, 0}};
  bool result = s21_is_greater(value_1, value_2);
  ck_assert(result == 1);

#test positive_s21_is_greater_01
  s21_decimal value_1 = (s21_decimal){{0, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  bool result = s21_is_greater(value_1, value_2);
  ck_assert(result == 1);

#test positive_s21_is_greater_02
  s21_decimal value_1 = (s21_decimal){{0, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 1, 0}};
  set_sign(&value_2, minus);
  bool result = s21_is_greater(value_1, value_2);
  ck_assert(result == 1);

#test positive_s21_is_greater_03
  s21_decimal value_1 = (s21_decimal){{1, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{1, 0, 1, 0}};
  set_scale(&value_1, 25);
  set_scale(&value_2, 26);
  bool result = s21_is_greater(value_1, value_2);
  ck_assert(result == 1);

#test positive_s21_is_less_or_equal_000
  s21_decimal value_1 = (s21_decimal){{1, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{1, 0, 1, 0}};
  bool result = s21_is_less_or_equal(value_1, value_2);
  ck_assert(result == 1);

#test positive_s21_is_less_or_equal_00
  s21_decimal value_1 = (s21_decimal){{0, 1, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 1, 0}};
  bool result = s21_is_less_or_equal(value_1, value_2);
  ck_assert(result == 1);

#test positive_s21_is_less_or_equal_01
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 1, 0}};
  bool result = s21_is_less_or_equal(value_1, value_2);
  ck_assert(result == 1);

#test positive_s21_is_less_or_equal_02
  s21_decimal value_1 = (s21_decimal){{0, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 1, 0}};
  set_sign(&value_1, minus);
  bool result = s21_is_less_or_equal(value_1, value_2);
  ck_assert(result == 1);

#test positive_s21_is_less_or_equal_03
  s21_decimal value_1 = (s21_decimal){{1, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{1, 0, 1, 0}};
  set_scale(&value_1, 27);
  set_scale(&value_2, 26);
  bool result = s21_is_less_or_equal(value_1, value_2);
  ck_assert(result == 1);

#test negative_s21_is_less_or_equal_00
  s21_decimal value_1 = (s21_decimal){{0, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 1, 0, 0}};
  bool result = s21_is_less_or_equal(value_1, value_2);
  ck_assert(result == 0);

#test negative_s21_is_less_or_equal_01
  s21_decimal value_1 = (s21_decimal){{0, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  bool result = s21_is_less_or_equal(value_1, value_2);
  ck_assert(result == 0);

#test negative_s21_is_less_or_equal_02
  s21_decimal value_1 = (s21_decimal){{0, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 1, 0}};
  set_sign(&value_2, minus);
  bool result = s21_is_less_or_equal(value_1, value_2);
  ck_assert(result == 0);

#test negative_s21_is_less_or_equal_03
  s21_decimal value_1 = (s21_decimal){{1, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{1, 0, 1, 0}};
  set_scale(&value_1, 25);
  set_scale(&value_2, 26);
  bool result = s21_is_less_or_equal(value_1, value_2);
  ck_assert(result == 0);

#test negative_s21_is_greater_or_equal_00
  s21_decimal value_1 = (s21_decimal){{0, 1, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 1, 0}};
  bool result = s21_is_greater_or_equal(value_1, value_2);
  ck_assert(result == 0);

#test negative_s21_is_greater__or_equal01
  s21_decimal value_1 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 1, 0}};
  bool result = s21_is_greater_or_equal(value_1, value_2);
  ck_assert(result == 0);

#test negative_s21_is_greater__or_equal02
  s21_decimal value_1 = (s21_decimal){{0, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 1, 0}};
  set_sign(&value_1, minus);
  bool result = s21_is_greater_or_equal(value_1, value_2);
  ck_assert(result == 0);

#test negative_s21_is_greater_or_equal_03
  s21_decimal value_1 = (s21_decimal){{1, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{1, 0, 1, 0}};
  set_scale(&value_1, 27);
  set_scale(&value_2, 26);
  bool result = s21_is_greater_or_equal(value_1, value_2);
  ck_assert(result == 0);

#test positive_s21_is_greater_or_equal_000
  s21_decimal value_1 = (s21_decimal){{1, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{1, 0, 1, 0}};
  bool result = s21_is_greater_or_equal(value_1, value_2);
  ck_assert(result == 1);

#test positive_s21_is_greater_or_equal_00
  s21_decimal value_1 = (s21_decimal){{0, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 1, 0, 0}};
  bool result = s21_is_greater_or_equal(value_1, value_2);
  ck_assert(result == 1);

#test positive_s21_is_greater_or_equal_01
  s21_decimal value_1 = (s21_decimal){{0, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  bool result = s21_is_greater_or_equal(value_1, value_2);
  ck_assert(result == 1);

#test positive_s21_is_greater_or_equal_02
  s21_decimal value_1 = (s21_decimal){{0, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 1, 0}};
  set_sign(&value_2, minus);
  bool result = s21_is_greater_or_equal(value_1, value_2);
  ck_assert(result == 1);

#test positive_s21_is_greater_or_equal_03
  s21_decimal value_1 = (s21_decimal){{1, 0, 1, 0}};
  s21_decimal value_2 = (s21_decimal){{1, 0, 1, 0}};
  set_scale(&value_1, 25);
  set_scale(&value_2, 26);
  bool result = s21_is_greater_or_equal(value_1, value_2);
  ck_assert(result == 1);

#test truncate_1
  s21_decimal value = (s21_decimal){{25, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal expected = (s21_decimal){{2, 0, 0, 0}};
  set_scale(&value, 1);
  set_scale(&expected, 0);
  s21_truncate(value, &result);
  int err_code = s21_is_equal(result, expected);
  ck_assert(err_code == 1);

#test truncate_2
  s21_decimal value = (s21_decimal){{12345, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal expected = (s21_decimal){{123, 0, 0, 0}};
  set_scale(&value, 2);
  set_scale(&expected, 0);
  s21_truncate(value, &result);
  int err_code = s21_is_equal(result, expected);
  ck_assert(err_code == 1);

#test truncate_3
  s21_decimal value = (s21_decimal){{98765, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal expected = (s21_decimal){{987, 0, 0, 0}};
  set_scale(&value, 2);
  set_scale(&expected, 0);
  s21_truncate(value, &result);
  int err_code = s21_is_equal(result, expected);
  ck_assert(err_code == 1);

#test truncate_4
  s21_decimal value = (s21_decimal){{1000, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal expected = (s21_decimal){{10, 0, 0, 0}};
  set_scale(&value, 2);
  set_scale(&expected, 0);
  s21_truncate(value, &result);
  int err_code = s21_is_equal(result, expected);
  ck_assert(err_code == 1);

#test truncate_5
  s21_decimal value = (s21_decimal){{250, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal expected = (s21_decimal){{25, 0, 0, 0}};
  set_sign(&value, minus);
  set_sign(&expected, minus);
  set_scale(&value, 1);
  set_scale(&expected, 0);
  s21_truncate(value, &result);
  int err_code = s21_is_equal(result, expected);
  ck_assert(err_code == 1);

#test truncate_6
  s21_decimal value = (s21_decimal){{123456789, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal expected = (s21_decimal){{1234567, 0, 0, 0}};
  set_sign(&value, minus);
  set_sign(&expected, minus);
  set_scale(&value, 2);
  set_scale(&expected, 0);
  s21_truncate(value, &result);
  int err_code = s21_is_equal(result, expected);
  ck_assert(err_code == 1);

#test truncate_7
  s21_decimal value = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal expected = (s21_decimal){{0, 0, 0, 0}};
  set_scale(&value, 3);
  set_scale(&expected, 0);
  s21_truncate(value, &result);
  int err_code = s21_is_equal(result, expected);
  ck_assert(err_code == 1);

#test truncate_8
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-171701", &value);
  str_to_decimal("-171701", &expected);
  int err_code = s21_truncate(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test truncate_9
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-0", &value);
  str_to_decimal("-0", &expected);
  int err_code = s21_truncate(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test truncate_10
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-0.1412132131231", &value);
  str_to_decimal("-0", &expected);
  int err_code = s21_truncate(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test truncate_11
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-4213213.21312", &value);
  str_to_decimal("-4213213", &expected);
  int err_code = s21_truncate(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test truncate_12
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  set_scale(&value, 29);
  int err_code = s21_truncate(value, &result);
  ck_assert(err_code == 1);

#test truncate_13
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("79228162514264337593543950335", &value);
  str_to_decimal("79228162514264337593543950335", &expected);
  int err_code = s21_truncate(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test truncate_14
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-79228162514264337593543950335", &value);
  str_to_decimal("-79228162514264337593543950335", &expected);
  int err_code = s21_truncate(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test round_1
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-4213213.21312", &value);
  str_to_decimal("-4213213", &expected);
  int err_code = s21_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test round_2
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-4213213.71312", &value);
  str_to_decimal("-4213214", &expected);
  int err_code = s21_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test round_3
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-4213213.51312", &value);
  str_to_decimal("-4213214", &expected);
  int err_code = s21_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test round_4
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("0", &value);
  set_scale(&value, 29);
  int err_code = s21_round(value, &result);
  ck_assert(err_code == 1);

#test round_5
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-0", &value);
  str_to_decimal("-0", &expected);
  int err_code = s21_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test round_6
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-0.4", &value);
  str_to_decimal("-0", &expected);
  int err_code = s21_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test round_7
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("79228162514264337593543950335", &value);
  str_to_decimal("79228162514264337593543950335", &expected);
  int err_code = s21_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test round_8
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-79228162514264337593543950335", &value);
  str_to_decimal("-79228162514264337593543950335", &expected);
  int err_code = s21_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test floor_1
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("4213213.21312", &value);
  str_to_decimal("4213213", &expected);
  int err_code = s21_floor(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test floor_2
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-4213213.71312", &value);
  str_to_decimal("-4213214", &expected);
  int err_code = s21_floor(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test floor_3
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-4213213.51312", &value);
  str_to_decimal("-4213214", &expected);
  int err_code = s21_floor(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test floor_4
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("0", &value);
  set_scale(&value, 29);
  int err_code = s21_floor(value, &result);
  ck_assert(err_code == 1);

#test floor_5
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-0", &value);
  str_to_decimal("-0", &expected);
  int err_code = s21_floor(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test floor_6
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-0.4", &value);
  str_to_decimal("-1", &expected);
  int err_code = s21_floor(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test floor_7
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("79228162514264337593543950335", &value);
  str_to_decimal("79228162514264337593543950335", &expected);
  int err_code = s21_floor(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test floor_8
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-79228162514264337593543950335", &value);
  str_to_decimal("-79228162514264337593543950335", &expected);
  int err_code = s21_floor(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test floor_9
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-7922816251426433759354395033.5", &value);
  str_to_decimal("-7922816251426433759354395034", &expected);
  int err_code = s21_floor(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test floor_10
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-4213213.001", &value);
  str_to_decimal("-4213214", &expected);
  int err_code = s21_floor(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test bank_round_1
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("4213213.21312", &value);
  str_to_decimal("4213213", &expected);
  int err_code = bank_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test bank_round_2
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-4213213.71312", &value);
  str_to_decimal("-4213214", &expected);
  int err_code = bank_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test bank_round_3
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-4213213.51312", &value);
  str_to_decimal("-4213214", &expected);
  int err_code = bank_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test bank_round_4
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("0", &value);
  set_scale(&value, 29);
  int err_code = bank_round(value, &result);
  ck_assert(err_code == 1);

#test bank_round_5
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-0", &value);
  str_to_decimal("-0", &expected);
  int err_code = bank_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test bank_round_6
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-0.4", &value);
  str_to_decimal("-0", &expected);
  int err_code = bank_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test bank_round_7
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("79228162514264337593543950335", &value);
  str_to_decimal("79228162514264337593543950335", &expected);
  int err_code = bank_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test bank_round_8
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-79228162514264337593543950335", &value);
  str_to_decimal("-79228162514264337593543950335", &expected);
  int err_code = bank_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test bank_round_9
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-7922816251426433759354395033.5", &value);
  str_to_decimal("-7922816251426433759354395034", &expected);
  int err_code = bank_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test bank_round_10
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-4213213.001", &value);
  str_to_decimal("-4213213", &expected);
  int err_code = bank_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test bank_round_11
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-4213213.51", &value);
  str_to_decimal("-4213214", &expected);
  int err_code = bank_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test bank_round_12
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-4213214.5", &value);
  str_to_decimal("-4213214", &expected);
  int err_code = bank_round(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test truncate_positive_float
  s21_decimal value = (s21_decimal){{12345, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{123, 0, 0, 0}};
  set_scale(&value, 2);
  set_scale(&expected, 0);
  int return_code = s21_truncate(value, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div - деление двух положительных дробных

#test div_positive_float1
  s21_decimal value_1 = (s21_decimal){{100, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{25, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{4, 0, 0, 0}};
  set_scale(&value_1, 2);
  set_scale(&value_2, 2);
  set_scale(&expected, 0);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div - деление двух отрицательных дробных

#test div_negative_float2
  s21_decimal value_1 = (s21_decimal){{100, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{25, 0, 0, 0x80000000}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{4, 0, 0, 0}};
  set_scale(&value_1, 2);
  set_scale(&value_2, 2);
  set_scale(&expected, 0);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div - деление положительного на отрицательное

#test div_positive_negative3
  s21_decimal value_1 = (s21_decimal){{100, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{25, 0, 0, 0x80000000}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{4, 0, 0, 0}};
  set_scale(&value_1, 2);
  set_scale(&value_2, 2);
  set_scale(&expected, 0);
  set_sign(&expected, minus);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div - деление отрицательного на положительное

#test div_negative_positive4
  s21_decimal value_1 = (s21_decimal){{100, 0, 0, 0x80000000}};
  s21_decimal value_2 = (s21_decimal){{25, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{4, 0, 0, 0x80000000}};
  set_scale(&value_1, 2);
  set_scale(&value_2, 2);
  set_scale(&expected, 0);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

#test div_by_zero
  s21_decimal value_1 = (s21_decimal){{100, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{0, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(return_code == 3);

#test s21_negate1
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("171701", &value);
  str_to_decimal("-171701", &expected);
  int err_code = s21_negate(value, &value);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);

#test s21_negate2
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-171701", &value);
  str_to_decimal("171701", &expected);
  int err_code = s21_negate(value, &value);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);

#test s21_negate3
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-171701.31231213", &value);
  str_to_decimal("171701.31231213", &expected);
  int err_code = s21_negate(value, &value);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);

#test s21_negate4
  // negate есть умножение на -1
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-0", &value);
  str_to_decimal("0", &expected);
  int err_code = s21_negate(value, &value);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);

#test s21_negate5
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("0", &value);
  str_to_decimal("-0", &expected);
  int err_code = s21_negate(value, &value);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);

#test s21_negate6
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("79228162514264337593543950335", &value);
  str_to_decimal("-79228162514264337593543950335", &expected);
  int err_code = s21_negate(value, &value);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);

#test s21_negate7
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-79228162514264337593543950335", &value);
  str_to_decimal("79228162514264337593543950335", &expected);
  int err_code = s21_negate(value, &value);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);

#test s21_negate8
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-7922816251426.4337593543950335", &value);
  str_to_decimal("7922816251426.4337593543950335", &expected);
  int err_code = s21_negate(value, &value);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);

#test s21_negate9
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("79228162514264337593543950.335", &value);
  str_to_decimal("-79228162514264337593543950.335", &expected);
  int err_code = s21_negate(value, &value);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);

#test inf_div
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("20", &value_1);
  str_to_decimal("7", &value_2);
  str_to_decimal("2.8571428571428571428571428571", &expected);
  int return_code = s21_div(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

#test neginf_div
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-20", &value_1);
  str_to_decimal("7", &value_2);
  str_to_decimal("-2.8571428571428571428571428571", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

#test div2
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("171701", &value_1);
  str_to_decimal("200000", &value_2);
  str_to_decimal("858505", &expected);
  set_scale(&expected, 6);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

#test div3
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal(MAX_DECIMAL, &value_1);
  str_to_decimal("1000000000", &value_2);
  str_to_decimal(MAX_DECIMAL, &expected);
  set_scale(&expected, 9);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

#test div4
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("1432345362332124431467430", &value_1);
  str_to_decimal("320", &value_2);
  str_to_decimal("447607925728788884833571875", &expected);
  set_scale(&expected, 5);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

#test from_float_to_decimal_1
  float fvalue = -79228157791897854723898736640.f;
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-79228160000000000000000000000", &expected);
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 1);

#test from_float_to_decimal_2
  float fvalue = 0.123456f;
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("0.123456", &expected);
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test from_float_to_decimal_3
  float fvalue_inf = INFINITY;
  s21_decimal result_inf;
  s21_decimal expected_inf;
  str_to_decimal("0", &expected_inf);
  int err_code = s21_from_float_to_decimal(fvalue_inf, &result_inf);
  ck_assert(err_code == 1);

#test from_float_to_decimal_4
  float fvalue_neg_inf = -INFINITY;
  s21_decimal result_neg_inf;
  s21_decimal expected_neg_inf;
  str_to_decimal("0", &expected_neg_inf);
  int err_code = s21_from_float_to_decimal(fvalue_neg_inf, &result_neg_inf);
  ck_assert(err_code == 1);

#test from_float_to_decimal_5
  float fvalue_nan = NAN;
  s21_decimal result_nan;
  s21_decimal expected_nan;
  str_to_decimal("0", &expected_nan);
  int err_code = s21_from_float_to_decimal(fvalue_nan, &result_nan);
  ck_assert(err_code == 1);

#test from_float_to_decimal_6
  float fvalue = 12345;
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("12345", &expected);
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test from_float_to_decimal_7
  float fvalue = 0.12345678;
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("0.1234568", &expected);
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test from_float_to_decimal_8
  float fvalue = 0.12345671;
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("0.1234567", &expected);
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test from_float_to_decimal_9
  float fvalue = 0.12345;
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("0.12345", &expected);
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test from_float_to_decimal_10
  float fvalue = 0.f;
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("0", &expected);
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test from_float_to_decimal_11
  float fvalue = -11111111.123123;
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-11111110", &expected);
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test from_float_to_decimal_12
  float fvalue = 11111.123123;
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("11111.12", &expected);
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test from_float_to_decimal_13
  float fvalue = -11111.129123;
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  str_to_decimal("-11111.13", &expected);
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test from_float_to_decimal_14
  float fvalue = 79228162514264337593543950336.f;
  s21_decimal result = (s21_decimal){{0}};
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(err_code == 1);

#test from_float_to_decimal_15
  float fvalue = 1e-29;
  s21_decimal result = (s21_decimal){{0}};
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(err_code == 1);

#test from_float_to_decimal_16
  float fvalue = 792281625142643375935439503351.f;
  s21_decimal result = (s21_decimal){{0}};
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  ck_assert(err_code == 1);

#test from_float_to_decimal_17
  float fvalue = -0.f;
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  int err_code = s21_from_float_to_decimal(fvalue, &result);
  str_to_decimal("-0", &expected);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(err_code == 0);

#test from_decimal_to_float_1
  s21_decimal value_1 = (s21_decimal){{0}};
  float result = 0;
  str_to_decimal("78123", &value_1);
  int err_code = s21_from_decimal_to_float(value_1, &result);
  ck_assert(0 == err_code);
  ck_assert(78123.0 == result);

#test from_decimal_to_float_2
  s21_decimal value_1 = (s21_decimal){{0}};
  float result = 0;
  str_to_decimal("-781865", &value_1);
  int err_code = s21_from_decimal_to_float(value_1, &result);
  ck_assert(0 == err_code);
  ck_assert(-781865.0 == result);

#test from_decimal_to_float_3
  s21_decimal value_1 = (s21_decimal){{0}};
  float result = 0;
  str_to_decimal("-6408.25", &value_1);
  int err_code = s21_from_decimal_to_float(value_1, &result);
  ck_assert(0 == err_code);
  ck_assert(-6408.25 == result);

#test from_decimal_to_float_4
  s21_decimal value_1 = (s21_decimal){{0}};
  float result = 0;
  str_to_decimal("-0", &value_1);
  int err_code = s21_from_decimal_to_float(value_1, &result);
  ck_assert(0 == err_code);
  ck_assert(-0.f == result);

#test from_decimal_to_float_5
  s21_decimal value_1 = (s21_decimal){{0}};
  float result = 0;
  str_to_decimal("0.1234678", &value_1);
  int err_code = s21_from_decimal_to_float(value_1, &result);
  ck_assert(0 == err_code);
  ck_assert(fabs(0.1234678) - fabs(result) < 0.00000001);

#test from_decimal_to_float_6
  s21_decimal value_1 = (s21_decimal){{0}};
  float result = 0;
  str_to_decimal("12345.1234678", &value_1);
  int err_code = s21_from_decimal_to_float(value_1, &result);
  ck_assert(0 == err_code);
  ck_assert(fabs(12345.12) - fabs(result) < 0.00000001);

#test from_decimal_to_float_7
  s21_decimal value_1 = (s21_decimal){{0}};
  float result = 0;
  str_to_decimal("-12345.677734", &value_1);
  int err_code = s21_from_decimal_to_float(value_1, &result);
  ck_assert(0 == err_code);
  // -12345.67 т.к. теряется точность у float. см IEEE-754
  ck_assert(fabs(-12345.67) - fabs(result) < 0.00000001);

  #test from_decimal_to_float_8
  s21_decimal value_1 = (s21_decimal){{0}};
  float result = 0;
  str_to_decimal("-0.123467812345675432", &value_1);
  int err_code = s21_from_decimal_to_float(value_1, &result);
  ck_assert(0 == err_code);
  ck_assert(fabs(-0.1234678) - fabs(result) < 0.00000001);

#test from_int_to_decimal_0
  int src = 6418934;
  s21_decimal value = (s21_decimal){{0}};
  int err_code = s21_from_int_to_decimal(src, &value);
  s21_decimal expected = (s21_decimal){{6418934, 0, 0, 0}};
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);

#test from_int_to_decimal_1
  int src = -6418934;
  s21_decimal value = (s21_decimal){{0}};
  int err_code = s21_from_int_to_decimal(src, &value);
  s21_decimal expected = (s21_decimal){{6418934, 0, 0, 0}};
  set_sign(&expected, 1);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);

#test from_int_to_decimal_2
  int src = 2147483647;
  s21_decimal value = (s21_decimal){{0}};
  int err_code = s21_from_int_to_decimal(src, &value);
  s21_decimal expected = (s21_decimal){{2147483647, 0, 0, 0}};
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);

#test from_int_to_decimal_3
  int src = -2147483648;
  s21_decimal value = (s21_decimal){{0}};
  int err_code = s21_from_int_to_decimal(src, &value);
  s21_decimal expected = (s21_decimal){{2147483648U, 0, 0, 0}};
  set_sign(&expected, 1);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);

#test from_int_to_decimal_4
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  int src = 0;
  str_to_decimal("0", &expected);
  int err_code = s21_from_int_to_decimal(src, &value);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);

#test from_int_to_decimal_5
  s21_decimal value = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  int src = -232432;
  str_to_decimal("-232432", &expected);
  int err_code = s21_from_int_to_decimal(src, &value);
  ck_assert(value.bits[0] == expected.bits[0]);
  ck_assert(value.bits[1] == expected.bits[1]);
  ck_assert(value.bits[2] == expected.bits[2]);
  ck_assert(value.bits[3] == expected.bits[3]);
  ck_assert(err_code == 0);

#test from_decimal_to_int_1
  int src = 0;
  s21_decimal value = (s21_decimal){{2147483647, 1, 0, 0}};
  set_sign(&value, 1);
  int err_code = s21_from_decimal_to_int(value, &src);
  ck_assert(err_code == 1);

#test from_decimal_to_int_2
  int src = 0;
  s21_decimal value = (s21_decimal){{2147483647, 1, 0, 0}};
  int err_code = s21_from_decimal_to_int(value, &src);
  ck_assert(err_code == 1);

#test from_decimal_to_int_3
  int src = 0;
  s21_decimal value = (s21_decimal){{0}};
  set_scale(&value, 3);
  str_to_decimal("0.001", &value);
  int err_code = s21_from_decimal_to_int(value, &src);
  ck_assert(src == 0);
  ck_assert(err_code == 0);

#test from_decimal_to_int_4
  int result = 0;
  s21_decimal value = (s21_decimal){{0}};
  str_to_decimal("-21474836.4", &value);
  int err_code = s21_from_decimal_to_int(value, &result);
  ck_assert(result == -21474836);
  ck_assert(err_code == 0);

#test from_decimal_to_int_5
  int result = 0;
  s21_decimal value = (s21_decimal){{0}};
  str_to_decimal("-21476.41212321121", &value);
  int err_code = s21_from_decimal_to_int(value, &result);
  ck_assert(result == -21476);
  ck_assert(err_code == 0);

#test from_decimal_to_int_6
  int result = 0;
  s21_decimal value = (s21_decimal){{0}};
  str_to_decimal("-214761312312", &value);
  int err_code = s21_from_decimal_to_int(value, &result);
  ck_assert(err_code == 1);

#test from_decimal_to_int_7
  int result = 0;
  s21_decimal value = (s21_decimal){{0}};
  str_to_decimal("214761312312", &value);
  int err_code = s21_from_decimal_to_int(value, &result);
  ck_assert(err_code == 1);

#test from_decimal_to_int_8
  int result = 0;
  s21_decimal value = (s21_decimal){{0}};
  str_to_decimal("-2.147611213123121", &value);
  int err_code = s21_from_decimal_to_int(value, &result);
  ck_assert(result == -2);
  ck_assert(err_code == 0);

#test from_decimal_to_int_9
  int src = 0;
  s21_decimal value = (s21_decimal){{0, 0, 1, 0}};
  int err_code = s21_from_decimal_to_int(value, &src);
  ck_assert(err_code == 1);

#test big_to_decimal_0
  big_decimal value = (big_decimal){{0, 0, 0, 1, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  int err_code = big_to_decimal(value, &result);
  ck_assert(err_code == 1);

#test big_to_decimal_1
  s21_decimal value_1 = (s21_decimal){{1, 0, 0, 0}};
  set_sign(&value_1, 1);
  big_decimal value = (big_decimal){{0}};
  decimal_to_big(value_1, &value);
  value.bits[3] = 1;
  s21_decimal result = (s21_decimal){{0}};
  int err_code = big_to_decimal(value, &result);
  ck_assert(err_code == 2);

#test big_to_decimal_2
  big_decimal value = (big_decimal){{0, 1, 0, 0, 0, 0, 0}};
  s21_decimal result = (s21_decimal){{0}};
  int err_code = big_to_decimal(value, &result);
  ck_assert(result.bits[1] == 1);
  ck_assert(err_code == 0);

#test big_to_int_1
  big_decimal value = (big_decimal){{659865, 0, 0, 0, 0, 0, 0}};
  int result = big_to_int(value);
  int expected = 659865;
  ck_assert(result == expected);

  // Функция s21_add сложение с домножением нулей

#test add_multiplying_zeros
  s21_decimal value_1 = (s21_decimal){{100, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{1, 0, 0, 0}};
  set_scale(&value_2, 2);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{10001, 0, 0, 0}};
  set_scale(&expected, 2);

  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub сложение с домножением нулей

#test sub_multiplying_zeros
  s21_decimal value_1 = (s21_decimal){{100, 0, 0, 0}};
  s21_decimal value_2 = (s21_decimal){{1, 0, 0, 0}};
  set_scale(&value_2, 2);
  s21_decimal result = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{9999, 0, 0, 0}};
  set_scale(&expected, 2);

  int return_code = s21_sub(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub переполнение с округлением

#test sub_overflow_bank_round
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("79228162514264337593543950335", &value_1);
  str_to_decimal("0.6", &value_2);
  str_to_decimal("79228162514264337593543950334", &expected);
  int return_code = s21_sub(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  //  ОКРУГЛЕНИЕ
  //  Функция s21_add сложение двух положительных чисел с большой мантиссой с
  //  ненулевыми разрядами

#test add_positive_float_big_scale_bank_round
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("7.9228162514264337593543950335", &value_1);
  str_to_decimal("79.28162514264337593543950335", &value_2);
  str_to_decimal("87.20444139406980969479389838", &expected);
  int return_code = s21_add(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение двух отрицательных чисел с большой мантиссой с
  // ненулевыми разрядами

#test add_negative_float_big_scale_bank_round
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-7.9228162514264337593543950335", &value_1);
  str_to_decimal("-79.28162514264337593543950335", &value_2);
  str_to_decimal("-87.20444139406980969479389838", &expected);
  int return_code = s21_add(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение отрицательного и положительного с большой
  // мантиссой с ненулевыми разрядами

#test add_negative_and_positive_float_big_scale_bank_round
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-7.9228162514264337593543950335", &value_1);
  str_to_decimal("79.28162514264337593543950335", &value_2);
  str_to_decimal("71.358808891216942176085108316", &expected);
  int return_code = s21_add(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_add сложение положительного и отрицательного с большой
  // мантиссой с ненулевыми разрядами

#test add_positive_and_negative_float_big_scale_bank_round
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("7.9228162514264337593543950335", &value_1);
  str_to_decimal("-79.28162514264337593543950335", &value_2);
  str_to_decimal("-71.358808891216942176085108316", &expected);
  int return_code = s21_add(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  //   Функция s21_sub вычитание двух положительных чисел с большой мантиссой с
  //   ненулевыми разрядами

#test sub_positive_float_big_scale_bank_round
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("7.9228162514264337593543950335", &value_1);
  str_to_decimal("79.28162514264337593543950335", &value_2);
  str_to_decimal("-71.358808891216942176085108316", &expected);
  int return_code = s21_sub(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание двух отрицательных чисел с большой мантиссой с
  // ненулевыми разрядами

#test sub_negative_float_big_scale_bank_round
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-7.9228162514264337593543950335", &value_1);
  str_to_decimal("-79.28162514264337593543950335", &value_2);
  str_to_decimal("71.358808891216942176085108316", &expected);
  int return_code = s21_sub(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание отрицательного и положительного с большой
  // мантиссой с ненулевыми разрядами

#test sub_negative_and_positive_float_big_scale_bank_round
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-7.9228162514264337593543950335", &value_1);
  str_to_decimal("79.28162514264337593543950335", &value_2);
  str_to_decimal("-87.20444139406980969479389838", &expected);
  int return_code = s21_sub(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_sub вычитание положительного и отрицательного с большой
  // мантиссой с ненулевыми разрядами

#test sub_positive_and_negative_float_big_scale_bank_round
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("7.9228162514264337593543950335", &value_1);
  str_to_decimal("-79.28162514264337593543950335", &value_2);
  str_to_decimal("87.20444139406980969479389838", &expected);
  int return_code = s21_sub(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  //   Функция s21_mul умножение двух положительных чисел с большой мантиссой с
  //   ненулевыми разрядами

  // Функция s21_mul умножение отрицательного и положительного с большой
  // мантиссой с ненулевыми разрядами

  // Функция s21_mul умножение положительного и отрицательного с большой
  // мантиссой с ненулевыми разрядами


  // Функция s21_div деление отрицательного и положительного с большой
  // мантиссой с ненулевыми разрядами

  // Функция s21_div деление положительного и отрицательного с большой
  // мантиссой с ненулевыми разрядами


  // Функция s21_div деление двух положительных чисел

#test div_positive_numbers
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("100", &value_1);
  str_to_decimal("20", &value_2);
  str_to_decimal("5", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух больших положительных чисел

#test div_big_positive_numbers
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("79228162514264337593543950335", &value_1);
  str_to_decimal("7928162514264337593543950335", &value_2);
  str_to_decimal("9.993256618001605231407880075", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух больших отрицательных чисел

#test div_big_negative_numbers
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-79228162514264337593543950335", &value_1);
  str_to_decimal("-7928162514264337593543950335", &value_2);
  str_to_decimal("9.993256618001605231407880075", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух больших отрицательныого и положительного чисел
  // должен быть отрицательный результат!!!

#test div_big_negative_positive_numbers
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-79228162514264337593543950335", &value_1);
  str_to_decimal("7928162514264337593543950335", &value_2);
  str_to_decimal("-9.993256618001605231407880075", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух больших положительного и отрицательного чисел
  // должен быть отрицательный результат!!!

#test div_big_positive_negative_numbers
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("79228162514264337593543950335", &value_1);
  str_to_decimal("-7928162514264337593543950335", &value_2);
  str_to_decimal("-9.993256618001605231407880075", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух больших положительных чисел одинаковых

#test div_big_positive_numbers_the_one
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("79228162514264337593543950335", &value_1);
  str_to_decimal("79228162514264337593543950335", &value_2);
  str_to_decimal("1", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух больших отрицательных чисел одинаковых

#test div_big_positive_numbers_the_one_minus
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-79228162514264337593543950335", &value_1);
  str_to_decimal("-79228162514264337593543950335", &value_2);
  str_to_decimal("1", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух больших отрицательных чисел одинаковых

#test div_big_positive_numbers_the_one_minus_plus
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-79228162514264337593543950335", &value_1);
  str_to_decimal("79228162514264337593543950335", &value_2);
  str_to_decimal("-1", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух больших отрицательных чисел одинаковых

#test div_big_positive_numbers_the_one_plus_minus
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("79228162514264337593543950335", &value_1);
  str_to_decimal("-79228162514264337593543950335", &value_2);
  str_to_decimal("-1", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух отрицательных чисел

#test div_negative_numbers
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-100", &value_1);
  str_to_decimal("-20", &value_2);
  str_to_decimal("5", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление положительного и отрицательного чисел

#test div_positive_and_negative
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("100", &value_1);
  str_to_decimal("-20", &value_2);
  str_to_decimal("-5", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление отрицательного и положительного чисел

#test div_negative_and_positive
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-100", &value_1);
  str_to_decimal("20", &value_2);
  str_to_decimal("-5", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух положительных дробных

#test div_positive_float
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("150.18", &value_1);
  str_to_decimal("1.2", &value_2);
  str_to_decimal("125.15", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух отрицательных дробных

#test div_negative_float
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-150.18", &value_1);
  str_to_decimal("-1.2", &value_2);
  str_to_decimal("125.15", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление негативного и положительного дробных

#test div_negative_positive_float
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-150.18", &value_1);
  str_to_decimal("1.2", &value_2);
  str_to_decimal("-125.15", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление положительного и отрицательного дробных

#test div_positive_negative_float
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("150.18", &value_1);
  str_to_decimal("-1.2", &value_2);
  str_to_decimal("-125.15", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление положительного дробного и целого

#test div_positive_float_int
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("150.18", &value_1);
  str_to_decimal("2", &value_2);
  str_to_decimal("75.09", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление отрицательного дробного и целого

#test div_negative_float_int
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-150.18", &value_1);
  str_to_decimal("2", &value_2);
  str_to_decimal("-75.09", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление дробного и отрицательного целого

#test div_negative_float_positive_int
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("150.18", &value_1);
  str_to_decimal("-2", &value_2);
  str_to_decimal("-75.09", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление положительного целого отрицательного дробного

#test div_positive_int_negative_float
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("150", &value_1);
  str_to_decimal("-2.56", &value_2);
  str_to_decimal("-58.59375", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление отрицательного целого положительного дробного

#test div_negative_int_positive_float
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-150", &value_1);
  str_to_decimal("2.56", &value_2);
  str_to_decimal("-58.59375", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div очень большое число и маленькое

#test div_max_and_min
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("79228162514264337593543950335", &value_1);
  str_to_decimal("2", &value_2);
  str_to_decimal("39614081257132168796771975168", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление отрицательных очень большое число и маленькое

#test div_max_and_min2
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-79228162514264337593543950335", &value_1);
  str_to_decimal("-2", &value_2);
  str_to_decimal("39614081257132168796771975168", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление отрицательных очень большое число и маленькое
  // неправильный знак!!!

#test div_max_and_min3
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-79228162514264337593543950335", &value_1);
  str_to_decimal("2", &value_2);
  str_to_decimal("-39614081257132168796771975168", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление отрицательных очень большое число и маленькое
  // неправильный знак!!!

#test div_max_and_min4
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("79228162514264337593543950335", &value_1);
  str_to_decimal("-2", &value_2);
  str_to_decimal("-39614081257132168796771975168", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div очень маленькое число и большое

#test div_min_and_max
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("2", &value_1);
  str_to_decimal("79228162514264337593543950335", &value_2);
  str_to_decimal("0", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);
  // 0.0000000000000000000000000000

  // Функция s21_div очень маленькое число и большое

#test div_min_and_max2
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-2", &value_1);
  str_to_decimal("-79228162514264337593543950335", &value_2);
  str_to_decimal("0", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);
  // 0.0000000000000000000000000000

  // Функция s21_div очень маленькое число и большое
  // должен быть отрицательный ноль!!!

#test div_min_and_max3
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("2", &value_1);
  str_to_decimal("-79228162514264337593543950335", &value_2);
  str_to_decimal("-0", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);
  // 0.0000000000000000000000000000

  // Функция s21_div очень маленькое число и большое
  // должен быть отрицательный ноль!!!

#test div_min_and_max4
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-2", &value_1);
  str_to_decimal("79228162514264337593543950335", &value_2);
  str_to_decimal("-0", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);
  // 0.0000000000000000000000000000

  // Функция s21_div деление двух нулей

#test div_positive_numbers_zero
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("0", &value_1);
  str_to_decimal("0", &value_2);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(return_code == 3);

  // Функция s21_div деление положительного и отрицательного нуля

#test div_positive_and_negative_zero
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("0", &value_1);
  str_to_decimal("-0", &value_2);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(return_code == 3);

  // Функция s21_div деление отрицательного и положительного нуля

#test div_negative_and_positive_zero
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-0", &value_1);
  str_to_decimal("0", &value_2);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(return_code == 3);

  // Функция s21_div деление отрицательных нулей

#test div_negative_numbers_zero
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("79228162514264337593543950335", &value_1);
  str_to_decimal("0", &value_2);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(return_code == 3);

  // Функция s21_div деление положительного числа и нуля

#test div_positive_numbers_and_zero
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("79228162514264337593543950335", &value_1);
  str_to_decimal("0", &value_2);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(return_code == 3);

  // Функция s21_div деление нуля и положительного числа

#test div_zero_and_positive_numbers
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("0", &value_1);
  str_to_decimal("79228162514264337593543950335", &value_2);
  str_to_decimal("0", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление положительного дробного и нуля

#test div_positive_float_and_zero
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("792281625142643375.93543950335", &value_1);
  str_to_decimal("0", &value_2);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(return_code == 3);

  // Функция s21_div деление нуля и положительного дробного

#test div_zero_and_positive_float
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("0", &value_1);
  str_to_decimal("7922816251426.4337593543950335", &value_2);
  str_to_decimal("0", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление отрицательного числа и нуля

#test div_negative_numbers_and_zero
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-79228162514264337593543950335", &value_1);
  str_to_decimal("0", &value_2);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(return_code == 3);

  // Функция s21_div деление нуля и отрицательного числа

#test div_zero_and_negative_numbers
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("0", &value_1);
  str_to_decimal("-79228162514264337593543950335", &value_2);
  str_to_decimal("-0", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление отрицательного дробного и нуля

#test div_negative_float_and_zero
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-792281625142643375.93543950335", &value_1);
  str_to_decimal("0", &value_2);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(return_code == 3);

  // Функция s21_div деление нуля и отрицательного дробного

#test div_zero_and_negative_float
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("0", &value_1);
  str_to_decimal("-792281625142643.37593543950335", &value_2);
  str_to_decimal("-0", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух положительных чисел с большой мантиссой

#test div_positive_float_big_scale
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("0.0000000000000000000000000001", &value_1);
  str_to_decimal("0.0000000000000000000000000002", &value_2);
  str_to_decimal("0.5", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление двух отрицательных чисел с большой мантиссой

#test div_negative_float_big_scale_
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-0.0000000000000000000000000001", &value_1);
  str_to_decimal("-0.0000000000000000000000000002", &value_2);
  str_to_decimal("0.5", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление отрицательного и положительного с большой
  // мантиссой

#test div_negative_and_positive_float_big_scale_
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("-0.0000000000000000000000000001", &value_1);
  str_to_decimal("0.0000000000000000000000000002", &value_2);
  str_to_decimal("-0.5", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

  // Функция s21_div деление положительного и отрицательного с большой
  // мантиссой

#test div_positive_and_negative_float_big_scale
  s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  s21_decimal expected = (s21_decimal){{0}};
  s21_decimal result = (s21_decimal){{0}};
  str_to_decimal("0.0000000000000000000000000001", &value_1);
  str_to_decimal("-0.0000000000000000000000000002", &value_2);
  str_to_decimal("-0.5", &expected);
  int return_code = s21_div(value_1, value_2, &result);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

#test is_less_two_negative_numbers_2
 s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  str_to_decimal("-0.000000000000000000000000005", &value_1);
  str_to_decimal("-0.000000000000000000000000004", &value_2);
  int result = s21_is_less(value_1, value_2);
  ck_assert(result == 1);

#test is_greater_two_negative_numbers_0
 s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  str_to_decimal("-12", &value_1);
  str_to_decimal("-11", &value_2);
  int result = s21_is_greater(value_1, value_2);
  ck_assert(result == 0);

#test is_greater_two_negative_numbers_1
 s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  str_to_decimal("-12.4652948675", &value_1);
  str_to_decimal("-11.46548", &value_2);
  int result = s21_is_greater(value_1, value_2);
  ck_assert(result == 0);

#test is_less_two_negative_numbers_1
 s21_decimal value_1 = (s21_decimal){{0}};
  s21_decimal value_2 = (s21_decimal){{0}};
  str_to_decimal("-12.4652948675", &value_1);
  str_to_decimal("-11.46548", &value_2);
  int result = s21_is_less(value_1, value_2);
  ck_assert(result == 1);

// #test div
//   s21_decimal value_1 = (s21_decimal){{0}};
//   s21_decimal value_2 = (s21_decimal){{0}};
//   s21_decimal expected = (s21_decimal){{0}};
//   s21_decimal result = (s21_decimal){{0}};
//   str_to_decimal("+184467440822994.86213", &value_1);
//   str_to_decimal("-128849018.9", &value_2);
//   str_to_decimal("-1431655.7657777777780968419931", &expected);
//   int return_code = s21_div(value_1, value_2, &result);
//   ck_assert(s21_is_equal(result, expected) == 1);
//   ck_assert(return_code == 0);
