#include <check.h>
#include <stdio.h>

#include "../s21_decimal.h"
#include "debug_helper.h"

// set_sign
// Функция set_sign поставить знак плюс
#test set_sign_positive
big_decimal value = {0};
Bset_sign(&value, plus);

ck_assert(((value.bits[3] >> 31) & 1) == plus);

// Функция set_sign поставить знак минус
#test set_sign_negative
big_decimal value = {0};
Bset_sign(&value, minus);

ck_assert(((value.bits[6] >> 31) & 1) == minus);

// get_sign
//  Функция get_sign проверить знак плюс
#test get_sign_positive
big_decimal value = {0};
Bset_sign(&value, plus);

ck_assert(Bget_sign(value) == plus);

// Функция get_sign проверить знак плюс
#test get_sign_negative
big_decimal value = {0};
Bset_sign(&value, minus);

ck_assert(Bget_sign(value) == minus);

// set_bit
//  Функция set_bit поменять бит 0 на бит 0 индекс 0
#test set_bit_zero_false
big_decimal value = (big_decimal){{0}};
Bset_bit(&value, 0, false);

ck_assert(Bget_bit(value, 0) == false);

// Функция set_bit поменять бит 0 на бит 1 индекс 0
#test set_bit_zero_true
big_decimal value = (big_decimal){{0}};
Bset_bit(&value, 0, true);

ck_assert(Bget_bit(value, 0) == true);

// Функция set_bit поменять бит 1 на бит 0 индекс 0
#test set_bit_one_false
big_decimal value = (big_decimal){{1}};
Bset_bit(&value, 0, false);

ck_assert(Bget_bit(value, 0) == false);

// Функция set_bit поменять бит 1 на бит 1 индекс 0
#test set_bit_one_true
big_decimal value = (big_decimal){{1}};
Bset_bit(&value, 0, true);

ck_assert(Bget_bit(value, 0) == true);

// Функция set_bit поменять бит 0 на бит 0 индекс 16
#test set_bit_middle_false
big_decimal value = (big_decimal){{0}};
Bset_bit(&value, 16, false);

ck_assert(Bget_bit(value, 16) == false);

// Функция set_bit поменять бит 0 на бит 1 индекс 16
#test set_bit_middle_true
big_decimal value = (big_decimal){{0}};
Bset_bit(&value, 16, true);

ck_assert(Bget_bit(value, 16) == true);

// Функция set_bit поменять бит 1 на бит 0 индекс 16
#test set_bit_middle_false_one
big_decimal value = (big_decimal){{1}};
Bset_bit(&value, 16, false);

ck_assert(Bget_bit(value, 16) == false);

// Функция set_bit поменять бит 1 на бит 1 индекс 16
#test set_bit_middle_true_one
big_decimal value = (big_decimal){{1}};
Bset_bit(&value, 16, true);

ck_assert(Bget_bit(value, 16) == true);

// Функция set_bit поменять бит 1 на бит 0 индекс 96
#test set_bit_overflow_false_one
big_decimal value = (big_decimal){{1}};
Bset_bit(&value, 96, false);

ck_assert(Bget_bit(value, 96) == false);

// s21_add
// Функция s21_add сложение двух положительных чисел
#test add_positive_numbers
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{30, 0, 0, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// s21_add
// Функция s21_add сложение двух больших положительных чисел
#test add_big_positive_numbers
s21_decimal value_1 = {{10, 30, 60000, 0}};
s21_decimal value_2 = {{20, 30, 60000, 0}};
s21_decimal result;
s21_decimal expected = {{30, 60, 120000, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);


// Функция s21_add сложение двух отрицательных чисел
#test add_negative_numbers
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
s21_decimal result;
s21_decimal expected = {{30, 0, 0, 0x80000000}};

int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение положительного и отрицательного чисел
#test add_positive_and_negative
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
s21_decimal result;
s21_decimal expected = {{10, 0, 0, 0x80000000}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного и положительного чисел
#test add_negative_and_positive
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{10, 0, 0, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение двух положительных дробных
#test add_positive_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result;
s21_decimal expected = {{200001, 0, 0, 0}};
set_scale(&expected, 9);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение двух больших положительных дробных
//#test add_big_positive_float
//s21_decimal value_1 = {1, 0, 565264864, 0};
//s21_decimal value_2 = {{0}};
//str_to_decimal("50000000")
//s21_decimal result;
//s21_decimal expected = {{200001, 0, 0, 0}};
//set_scale(&expected, 9);
//int return_code = s21_add(value_1, value_2, &result);

//ck_assert(s21_is_equal(result, expected) == 1);
//ck_assert(return_code == 0); 

// Функция s21_add сложение двух отрицательных дробных
#test add_negative_float
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result;
s21_decimal expected = {{200001, 0, 0, 0x80000000}};
set_scale(&expected, 9);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение положительного и отрицательного дробных
#test add_positive_and_negative_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result;
s21_decimal expected = {{199999, 0, 0, 0x80000000}};
set_scale(&expected, 9);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного и положительного дробных
#test add_negative_and_positive_float
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result;
s21_decimal expected = {{199999, 0, 0, 0}};
set_scale(&expected, 9);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);
// Функция s21_add сложение положительного дробного и целого
#test add_positive_float_int
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_scale(&value_1, 10);
s21_decimal result;
s21_decimal expected = {{2820130817, 4, 0, 0}};
set_scale(&expected, 9);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного дробного и целого
#test add_negative_float_int
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
set_scale(&value_1, 10);
s21_decimal result;
s21_decimal expected = {{2820130817, 4, 0, 0x80000000}};
set_scale(&expected, 9);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного дробного и положительного целого
#test add_negative_float_positive_int
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_scale(&value_1, 10);
s21_decimal result;
s21_decimal expected = {{2820130815, 4, 0, 0}};
set_scale(&expected, 9);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение положительного дробного и отрицательного целого
#test add_positive_float_negative_int
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
set_scale(&value_1, 10);
s21_decimal result;
s21_decimal expected = {{2820130815, 4, 0, 0x80000000}};
set_scale(&expected, 9);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение положительного целого отрицательного дробного
#test add_positive_int_negative_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
set_scale(&value_2, 5);
s21_decimal result;
s21_decimal expected = {{99998, 0, 0, 0}};
set_scale(&expected, 4);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);
//
//// Функция s21_add сложение отрицательного целого положительного дробного
#test add_negative_int_positive_float
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_scale(&value_2, 5);
s21_decimal result;
s21_decimal expected = {{99998, 0, 0, 0x80000000}};
set_scale(&expected, 4);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add очень большое число и маленькое - переполнение
#test add_overflow
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{1, 0, 0, 0}};
s21_decimal result;

int return_code = s21_add(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_add сложение очень маленького и очень большого - переполнение
#test add_overflow_two
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal result;

int return_code = s21_add(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_add сложение двух очень больших - переполнение ????
// 79228162514264337593543950335+79228162514264337593543950335=79228162514264337593543950334
#test add_overflow_three
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal result;

int return_code = s21_add(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_add сложение отрицательных очень большое число и маленькое -
// переполнение отрицательная бесконечность
#test add_overflow_negative
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal value_2 = {{1, 0, 0, 0x80000000}};
s21_decimal result;

int return_code = s21_add(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_add сложение отрицательных очень маленького и очень большого -
// переполнение отрицательная бесконечность
#test add_overflow_negative_two
s21_decimal value_1 = {{1, 0, 0, 0x80000000}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal result;

int return_code = s21_add(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_add сложение отрицательных двух очень больших - переполнение ???
//-79228162514264337593543950335-79228162514264337593543950335=-79228162514264337593543950334
#test add_overflow_negative_three
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal result;

int return_code = s21_add(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_add сложение двух нулей
#test add_positive_numbers_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение положительного и отрицательного нуля
#test add_positive_and_negative_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0x80000000}};
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного и положительного нуля
#test add_negative_and_positive_zero
s21_decimal value_1 = {{0, 0, 0, 0x80000000}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение отрицательных нулей
#test add_negative_numbers_zero
s21_decimal value_1 = {{0, 0, 0, 0x80000000}};
s21_decimal value_2 = {{0, 0, 0, 0x80000000}};
s21_decimal expected = {{0, 0, 0, 0}};
s21_decimal result;
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение положительного числа и нуля
#test add_positive_numbers_and_zero
s21_decimal value_1 = {{15, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение нуля и положительного числа
#test add_zero_and_positive_numbers
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение положительного дробного и нуля
#test add_positive_float_and_zero
s21_decimal value_1 = {{15, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_scale(&value_1, 7);
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0}};
set_scale(&expected, 7);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение нуля и положительного дробного
#test add_zero_and_positive_float
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0}};
set_scale(&value_2, 7);
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0}};
set_scale(&expected, 7);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного числа и нуля
#test add_negative_numbers_and_zero
s21_decimal value_1 = {{15, 0, 0, 0x80000000}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0x80000000}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение нуля и отрицательного числа
#test add_zero_and_negative_numbers
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0x80000000}};
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0x80000000}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного дробного и нуля
#test add_negative_float_and_zero
s21_decimal value_1 = {{15, 0, 0, 0x80000000}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_scale(&value_1, 7);
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0x80000000}};
set_scale(&expected, 7);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение нуля и отрицательного дробного
#test add_zero_and_negative_float
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0x80000000}};
set_scale(&value_2, 7);
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0x80000000}};
set_scale(&expected, 7);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение двух положительных чисел с большой мантиссой
#test add_positive_float_big_scale
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{2, 0, 0, 0}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result;
s21_decimal expected = {{21, 0, 0, 0}};
set_scale(&expected, 28);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение двух отрицательных чисел с большой мантиссой
#test add_negative_float_big_scale_
s21_decimal value_1 = {{1, 0, 0, 0x80000000}};
s21_decimal value_2 = {{2, 0, 0, 0x80000000}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result;
s21_decimal expected = {{21, 0, 0, 0x80000000}};
set_scale(&expected, 28);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного и положительного с большой
//мантиссой
#test add_negative_and_positive_float_big_scale_
s21_decimal value_1 = {{1, 0, 0, 0x80000000}};
s21_decimal value_2 = {{2, 0, 0, 0}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result;
s21_decimal expected = {{19, 0, 0, 0}};
set_scale(&expected, 28);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение положительного и отрицательного с большой
//мантиссой
#test add_positive_and_negative_float_big_scale
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{2, 0, 0, 0x80000000}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result;
s21_decimal expected = {{19, 0, 0, 0x80000000}};
set_scale(&expected, 28);
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

//
//  ОКРУГЛЕНИЕ - поменять название тестов
//   Функция s21_add сложение двух положительных чисел с большой мантиссой с
//   ненулевыми разрядами
// #test add_positive_float_big_scale
//  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
//  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
//  set_scale(&value_1, MAX_SCALE);
//  set_scale(&value_2, 27);
//  s21_decimal result;
//  s21_decimal expected = ???;
//  set_scale(&expected, ???);
//  int return_code = s21_add(value_1, value_2, &result);
//
//  ck_assert(s21_is_equal(result, expected) == 1);
//  ck_assert(return_code == 0);
//
//// Функция s21_add сложение двух отрицательных чисел с большой мантиссой с
/// ненулевыми разрядами
//#test add_negative_float_big_scale
// s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// set_scale(&value_1, MAX_SCALE);
// set_scale(&value_2, 27);
// s21_decimal result;
// s21_decimal expected = ???;
// set_scale(&expected, ???);
// int return_code = s21_add(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);
//
//// Функция s21_add сложение отрицательного и положительного с большой
/// мантиссой с ненулевыми разрядами
//#test add_negative_and_positive_float_big_scale
// s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
// set_scale(&value_1, MAX_SCALE);
// set_scale(&value_2, 27);
// s21_decimal result;
// s21_decimal expected = ???;
// set_scale(&expected, ???);
// int return_code = s21_add(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);
//
//// Функция s21_add сложение положительного и отрицательного с большой
/// мантиссой с ненулевыми разрядами
//#test add_positive_and_negative_float_big_scale
// s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
// s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// set_scale(&value_1, MAX_SCALE);
// set_scale(&value_2, 27);
// s21_decimal result;
// s21_decimal expected = ???;
// set_scale(&expected, ???);
// int return_code = s21_add(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);

// s21_sub
// Функция s21_sub вычитание двух положительных целых чисел
#test sub_positive_numbers
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{10, 0, 0, 0x80000000}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание двух отрицательных целых чисел
#test sub_negative_numbers
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_sign(&value_1, minus);
set_sign(&value_2, minus);
s21_decimal expected = {{10, 0, 0, 0}};
s21_decimal result;
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание позитивного и отрицательного целых чисел
#test sub_positive_and_negative
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_sign(&value_2, minus);
s21_decimal result;
s21_decimal expected = {{30, 0, 0, 0}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательного и позитивного целых чисел
#test sub_negative_and_positive
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_sign(&value_1, minus);
s21_decimal result;
s21_decimal expected = {{30, 0, 0, 0x80000000}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание двух положительных дробных чисел
#test sub_positive_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result;
s21_decimal expected = {{199999, 0, 0, 0x80000000}};
set_scale(&expected, 9);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание двух отрицательных дробных чисел
#test sub_negative_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_sign(&value_1, minus);
set_sign(&value_2, minus);
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result;
s21_decimal expected = {{199999, 0, 0, 0}};
set_scale(&expected, 9);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание положительного и отрицательного дробных чисел
#test sub_positive_and_negative_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_sign(&value_2, minus);
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result;
s21_decimal expected = {{200001, 0, 0, 0}};
set_scale(&expected, 9);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательного и положительного дробных чисел
#test sub_negative_and_positive_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_sign(&value_1, minus);
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result;
s21_decimal expected = {{200001, 0, 0, 0x80000000}};
set_scale(&expected, 9);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание положительных дробного и целого
#test sub_positive_float_int
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_scale(&value_1, 10);
s21_decimal result;
s21_decimal expected = {{2820130815, 4, 0, 0x80000000}};
set_scale(&expected, 9);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательных дробного и целого
#test sub_negative_float_int
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_sign(&value_1, minus);
set_sign(&value_2, minus);
set_scale(&value_1, 10);
s21_decimal result;
s21_decimal expected = {{2820130815, 4, 0, 0}};
set_scale(&expected, 9);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательного дробного и положительного целого
#test sub_negative_float_positive_int
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_sign(&value_1, minus);
set_scale(&value_1, 10);
s21_decimal result;
s21_decimal expected = {{2820130817, 4, 0, 0x80000000}};
set_scale(&expected, 9);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание положительного дробного и отрицательного целого
#test sub_positive_float_negative_int
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_scale(&value_1, 10);
set_sign(&value_2, minus);
s21_decimal result;
s21_decimal expected = {{2820130817, 4, 0, 0}};
set_scale(&expected, 9);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание положительного целого и отрицательного дробного
#test sub_positive_int_negative_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_sign(&value_2, minus);
set_scale(&value_2, 5);
s21_decimal result;
s21_decimal expected = {{100002, 0, 0, 0}};
set_scale(&expected, 4);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательного целого и положительного дробного
#test sub_negative_int_positive_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_sign(&value_1, minus);
set_scale(&value_2, 5);
s21_decimal result;
s21_decimal expected = {{100002, 0, 0, 0x80000000}};
set_scale(&expected, 4);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание максимального отрицательного из максимального
// положительного
#test sub_overflow
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
set_sign(&value_1, minus);
s21_decimal result;

int return_code = s21_sub(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_sub вычитание минимального отрицательного и максимального
// положительного
#test sub_overflow_two
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
set_sign(&value_1, minus);
s21_decimal result;

int return_code = s21_sub(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_sub вычитание максимального отрицательного и минимального
// положительного
#test sub_overflow_negative
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{1, 0, 0, 0}};
set_sign(&value_1, minus);
s21_decimal result;

int return_code = s21_sub(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_sub вычитание нулей
#test sub_positive_numbers_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание нулей
#test sub_positive_and_negative_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_sign(&value_2, minus);
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание нулей
#test sub_negative_and_positive_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_sign(&value_1, minus);
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание нулей
#test sub_negative_numbers_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_sign(&value_1, minus);
set_sign(&value_2, minus);
s21_decimal expected = {{0, 0, 0, 0}};
s21_decimal result;
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание положительных чисел с большим скейлом
#test sub_positive_float_big_scale
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{2, 0, 0, 0}};
set_scale(&value_1, MAX_SCALE);
set_scale(&value_2, 27);
s21_decimal result;
s21_decimal expected = {{19, 0, 0, 0x80000000}};
set_scale(&expected, 28);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательных чисел с большим скейлом
#test sub_negative_float_big_scale
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{2, 0, 0, 0}};
set_sign(&value_1, minus);
set_sign(&value_2, minus);
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result;
s21_decimal expected = {{19, 0, 0, 0}};
set_scale(&expected, 28);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательного и положительного чисел с большим
// скейлом
#test sub_negative_and_positive_float_big_scale
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{2, 0, 0, 0}};
set_sign(&value_1, minus);
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result;
s21_decimal expected = {{21, 0, 0, 0x80000000}};
set_scale(&expected, 28);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание полоижтельного и отрицательного чисел с большим
// скейлом
#test sub_positive_and_negative_float_big_scale
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{2, 0, 0, 0}};
set_sign(&value_2, minus);
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result;
s21_decimal expected = {{21, 0, 0, 0}};
set_scale(&expected, 28);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание положительного числа и нуля
#test sub_positive_numbers_and_zero
s21_decimal value_1 = {{15, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание нуля и положительного числа
#test sub_zero_and_positive_numbers
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0}};
set_sign(&expected, minus);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание положительного дробного и нуля
#test sub_positive_float_and_zero
s21_decimal value_1 = {{15, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_scale(&value_1, 7);
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0}};
set_scale(&expected, 7);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание нуля и положительного дробного
#test sub_zero_and_positive_float
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0}};
set_scale(&value_2, 7);
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0}};
set_scale(&expected, 7);
set_sign(&expected, minus);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательного числа и нуля
#test sub_negative_numbers_and_zero
s21_decimal value_1 = {{15, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_sign(&value_1, minus);
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0}};
set_sign(&expected, minus);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание нуля и отрицательного числа
#test sub_zero_and_negative_numbers
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0}};
set_sign(&value_2, minus);
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательного дробного и нуля
#test sub_negative_float_and_zero
s21_decimal value_1 = {{15, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_scale(&value_1, 7);
set_sign(&value_1, minus);

s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0x80000000}};
set_scale(&expected, 7);
set_sign(&value_1, minus);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание нуля и отрицательного дробного
#test sub_zero_and_negative_float
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0}};
set_scale(&value_2, 7);
set_sign(&value_2, minus);
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0}};
set_scale(&expected, 7);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

//  ОКРУГЛЕНИЕ
//  Функция s21_sub сложение двух положительных чисел с большой мантиссой с
//  ненулевыми разрядами
// #test sub_positive_float_big_scale
//  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
//  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
//  set_scale(&value_1, MAX_SCALE);
//  set_scale(&value_2, 27);
//  s21_decimal result;
//  int return_code = s21_sub(value_1, value_2, &result);
//
//  ck_assert(s21_is_equal(result, expected) == 1);
//  ck_assert(return_code == 0);

//// Функция s21_sub сложение двух отрицательных чисел с большой мантиссой с
/// ненулевыми разрядами
//#test sub_negative_float_big_scale
// s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// set_scale(&value_1, MAX_SCALE);
// set_scale(&value_2, 27);
// s21_decimal result;
// s21_decimal expected = ???;
// set_scale(&expected, ???);
// int return_code = s21_sub(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);
//
//// Функция s21_sub сложение отрицательного и положительного с большой
/// мантиссой с ненулевыми разрядами
//#test sub_negative_and_positive_float_big_scale
// s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
// set_scale(&value_1, MAX_SCALE);
// set_scale(&value_2, 27);
// s21_decimal result;
// s21_decimal expected = ???;
// set_scale(&expected, ???);
// int return_code = s21_sub(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);
//
//// Функция s21_sub сложение положительного и отрицательного с большой
/// мантиссой с ненулевыми разрядами
//#test sub_positive_and_negative_float_big_scale
// s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
// s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// set_scale(&value_1, MAX_SCALE);
// set_scale(&value_2, 27);
// s21_decimal result;
// s21_decimal expected = ???;
// set_scale(&expected, ???);
// int return_code = s21_sub(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);

// s21_mul
// s21_mul
// Функция s21_mul умножение двух положительных чисел
#test mul_positive_numbers
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{200, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение двух отрицательных чисел
#test mul_negative_numbers
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
s21_decimal result;
s21_decimal expected = {{200, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение положительного и отрицательного чисел
#test mul_positive_and_negative
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
s21_decimal result;
s21_decimal expected = {{200, 0, 0, 0x80000000}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного и положительного чисел
#test mul_negative_and_positive
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{200, 0, 0, 0x80000000}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение двух положительных дробных
#test mul_positive_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result;
s21_decimal expected = {{2, 0, 0, 0}};
set_scale(&expected, 13);
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение двух отрицательных дробных
#test mul_negative_float
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result;
s21_decimal expected = {{2, 0, 0, 0}};
set_scale(&expected, 13);
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

//// Функция s21_mul умножение положительного и отрицательного дробных
#test mul_positive_and_negative_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result;
s21_decimal expected = {{2, 0, 0, 0x80000000}};
set_scale(&expected, 13);
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного и положительного дробных
#test mul_negative_and_positive_float
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_scale(&value_1, 10);
set_scale(&value_2, 5);
s21_decimal result;
s21_decimal expected = {{2, 0, 0, 0x80000000}};
set_scale(&expected, 13);
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение положительного дробного и целого
#test mul_positive_float_int
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_scale(&value_1, 10);
s21_decimal result;
s21_decimal expected = {{2, 0, 0, 0}};
set_scale(&expected, 8);
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного дробного и целого
#test mul_negative_float_int
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
set_scale(&value_1, 10);
s21_decimal result;
s21_decimal expected = {{2, 0, 0, 0}};
set_scale(&expected, 8);
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного дробного и положительного целого
#test mul_negative_float_positive_int
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_scale(&value_1, 10);
s21_decimal result;
s21_decimal expected = {{2, 0, 0, 0x80000000}};
set_scale(&expected, 8);
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение положительного дробного и отрицательного целого
#test mul_positive_float_negative_int
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
set_scale(&value_1, 10);
s21_decimal result;
s21_decimal expected = {{2, 0, 0, 0x80000000}};
set_scale(&expected, 8);
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение положительного целого отрицательного дробного
#test mul_positive_int_negative_float
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
set_scale(&value_2, 5);
s21_decimal result;
s21_decimal expected = {{2, 0, 0, 0x80000000}};
set_scale(&expected, 3);
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного целого положительного дробного
#test mul_negative_int_positive_float
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_scale(&value_2, 5);
s21_decimal result;
s21_decimal expected = {{2, 0, 0, 0x80000000}};
int return_code = s21_mul(value_1, value_2, &result);
set_scale(&expected, 3);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul очень большое число и маленькое - переполнение
#test mul_overflow
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{2, 0, 0, 0}};
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_mul умножение очень маленького и очень большого - переполнение
#test mul_overflow_two
s21_decimal value_1 = {{2, 0, 0, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);
ck_assert(return_code == 1);

// Функция s21_mul умножение двух очень больших - переполнение
#test mul_overflow_three
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_mul умножение двух очень больших отрицательное и положительное -
// переполнение
#test mul_overflow_four
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_mul умножение двух очень больших положительное и отрицательное -
// переполнение
#test mul_overflow_five
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_mul умножение отрицательных очень большое число и маленькое -
// переполнение
#test mul_overflow_negative
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal value_2 = {{2, 0, 0, 0x80000000}};
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_mul умножение отрицательных очень маленького и очень большого -
// переполнение
#test mul_overflow_negative_two
s21_decimal value_1 = {{2, 0, 0, 0x80000000}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_mul умножение отрицательных двух очень больших - переполнение
#test mul_overflow_negative_three
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_mul умножение двух нулей
#test mul_positive_numbers_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение положительного и отрицательного нуля
#test mul_positive_and_negative_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0x80000000}};
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0x80000000}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного и положительного нуля
#test mul_negative_and_positive_zero
s21_decimal value_1 = {{0, 0, 0, 0x80000000}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0x80000000}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательных нулей
#test mul_negative_numbers_zero
s21_decimal value_1 = {{0, 0, 0, 0x80000000}};
s21_decimal value_2 = {{0, 0, 0, 0x80000000}};
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 0);

// Функция s21_mul умножение положительного числа и нуля
#test mul_positive_numbers_and_zero
s21_decimal value_1 = {{15, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение нуля и положительного числа
#test mul_zero_and_positive_numbers
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение положительного дробного и нуля
#test mul_positive_float_and_zero
s21_decimal value_1 = {{15, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_scale(&value_1, 7);
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение нуля и положительного дробного
#test mul_zero_and_positive_float
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0}};
set_scale(&value_2, 7);
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного числа и нуля
#test mul_negative_numbers_and_zero
s21_decimal value_1 = {{15, 0, 0, 0x80000000}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0x80000000}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение нуля и отрицательного числа
#test mul_zero_and_negative_numbers
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0x80000000}};
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0x80000000}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного дробного и нуля
#test mul_negative_float_and_zero
s21_decimal value_1 = {{15, 0, 0, 0x80000000}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_scale(&value_1, 7);
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение нуля и отрицательного дробного
#test mul_zero_and_negative_float
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0x80000000}};
set_scale(&value_2, 7);
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение двух положительных чисел с большой мантиссой
#test mul_positive_float_big_scale
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{2, 0, 0, 0}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_mul умножение двух отрицательных чисел с большой мантиссой
#test mul_negative_float_big_scale
s21_decimal value_1 = {{1, 0, 0, 0x80000000}};
s21_decimal value_2 = {{2, 0, 0, 0x80000000}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_mul умножение отрицательного и положительного с большой
///мантиссой
#test mul_negative_and_positive_float_big_scale
s21_decimal value_1 = {{1, 0, 0, 0x80000000}};
s21_decimal value_2 = {{2, 0, 0, 0}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_mul умножение положительного и отрицательного с большой
///мантиссой
#test mul_positive_and_negative_float_big_scale
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{2, 0, 0, 0x80000000}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_mul умножение двух положительных чисел с большой мантиссой с
// ненулевыми разрядами
#test mul_positive_float_big_scale_not_zero
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_mul умножение двух отрицательных чисел с большой мантиссой с
// ненулевыми разрядами
#test mul_negative_float_big_scale_not_zero
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_mul умножение отрицательного и положительного с большой
// мантиссой / с ненулевыми разрядами
#test mul_negative_and_positive_float_big_scale_not_zero
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_mul умножение положительного и отрицательного с большой
// мантиссой / с ненулевыми разрядами
#test mul_positive_and_negative_float_big_scale_not_zero
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_mul умножение целые большие числа с нулями
// Функция s21_mul очень большое целое число на очень маленькое число с
// плавающей точкой (отриц и положит)

// Функция s21_mul умножение двух положительных дробных результат 5
#test mul_positive_float__
s21_decimal value_1 = {{50, 0, 0, 0}};
s21_decimal value_2 = {{10, 0, 0, 0}};
set_scale(&value_2, 2);
s21_decimal result;
s21_decimal expected = {{5, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение двух положительных дробных результат 5
#test mul_positive_float____
s21_decimal value_1 = {{5, 0, 0, 0}};
s21_decimal value_2 = {{10, 0, 0, 0}};
set_scale(&value_2, 1);
s21_decimal result;
s21_decimal expected = {{5, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция void alignment
#test alignment_both_zero_with_scale
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_scale(&value_1, MAX_SCALE);
set_scale(&value_2, 27);
alignment(&value_1, &value_2, 1);

s21_decimal expected1 = {{0, 0, 0, 0}};
s21_decimal expected2 = {{0, 0, 0, 0}};
set_scale(&expected1, 0);
set_scale(&expected2, 0);

ck_assert(s21_is_equal(value_1, expected1) == 1);
ck_assert(s21_is_equal(value_2, expected2) == 1);

// Функция void alignment
#test alignment_both_zero_without_scale
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};

alignment(&value_1, &value_2, 1);

s21_decimal expected1 = {{0, 0, 0, 0}};
s21_decimal expected2 = {{0, 0, 0, 0}};

ck_assert(s21_is_equal(value_1, expected1) == 1);
ck_assert(s21_is_equal(value_2, expected2) == 1);

// Функция void alignment
#test alignment_both_zero_without_scale_and_with_scale
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_scale(&value_2, MAX_SCALE);

alignment(&value_1, &value_2, 1);

s21_decimal expected1 = {{0, 0, 0, 0}};
s21_decimal expected2 = {{0, 0, 0, 0}};
set_scale(&expected2, 0);

ck_assert(s21_is_equal(value_1, expected1) == 1);
ck_assert(s21_is_equal(value_2, expected2) == 1);

// Функция void alignment
#test alignment_both_zero_with_scale_and_without_scale
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_scale(&value_1, MAX_SCALE);

alignment(&value_1, &value_2, 1);

s21_decimal expected1 = {{0, 0, 0, 0}};
s21_decimal expected2 = {{0, 0, 0, 0}};
set_scale(&expected1, 0);

ck_assert(s21_is_equal(value_1, expected1) == 1);
ck_assert(s21_is_equal(value_2, expected2) == 1);

// Функция void alignment
#test alignment_float_with_zero_and_int
s21_decimal value_1 = {{1234000, 0, 0, 0}};
s21_decimal value_2 = {{5678, 0, 0, 0}};
set_scale(&value_1, 7);
set_scale(&value_2, 0);

alignment(&value_1, &value_2, 1);

s21_decimal expected1 = {{1234, 0, 0, 0}};
s21_decimal expected2 = {{56780000, 0, 0, 0}};
set_scale(&expected1, 4);
set_scale(&expected2, 4);

ck_assert(s21_is_equal(value_1, expected1) == 1);
ck_assert(s21_is_equal(value_2, expected2) == 1);

// Функция void alignment
#test alignment_int_and_float_with_zero
s21_decimal value_1 = {{1234, 0, 0, 0}};
s21_decimal value_2 = {{5678000, 0, 0, 0}};
set_scale(&value_1, 0);
set_scale(&value_2, 7);

alignment(&value_1, &value_2, 1);

s21_decimal expected1 = {{12340000, 0, 0, 0}};
s21_decimal expected2 = {{5678, 0, 0, 0}};
set_scale(&expected1, 4);
set_scale(&expected2, 4);

ck_assert(s21_is_equal(value_1, expected1) == 1);
ck_assert(s21_is_equal(value_2, expected2) == 1);

// Функция void alignment
#test alignment_big_float_big_scale_and_min_scale_
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
set_scale(&value_1, MAX_SCALE);
set_scale(&value_2, 1);
alignment(&value_1, &value_2, 1);

s21_decimal expected1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal expected2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
set_scale(&expected1, 28);
set_scale(&expected2, 28);

ck_assert(s21_is_equal(value_1, expected1) == 1);
ck_assert(s21_is_equal(value_2, expected2) == 1);

// Функция void alignment
#test alignment_big_float_min_scale_and_big_scale
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
set_scale(&value_1, 1);
set_scale(&value_2, MAX_SCALE);
alignment(&value_1, &value_2, 1);

s21_decimal expected1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal expected2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
set_scale(&expected1, 28);
set_scale(&expected2, 28);

ck_assert(s21_is_equal(value_1, expected1) == 1);
ck_assert(s21_is_equal(value_2, expected2) == 1);

// Функция void alignment
#test alignment_min_float_big_scale_and_min_scale_
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{1, 0, 0, 0}};
set_scale(&value_1, MAX_SCALE);
set_scale(&value_2, 1);
alignment(&value_1, &value_2, 1);

s21_decimal expected1 = {{1, 0, 0, 0}};
s21_decimal expected2 = {{1, 0, 0, 0}};
set_scale(&expected1, 28);
set_scale(&expected2, 28);

ck_assert(s21_is_equal(value_1, expected1) == 1);
ck_assert(s21_is_equal(value_2, expected2) == 1);

// Функция void alignment
#test alignment_min_float_min_scale_and_big_scale
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{1, 0, 0, 0}};
set_scale(&value_1, 1);
set_scale(&value_2, MAX_SCALE);
alignment(&value_1, &value_2, 1);

s21_decimal expected1 = {{1, 0, 0, 0}};
s21_decimal expected2 = {{1, 0, 0, 0}};
set_scale(&expected1, 28);
set_scale(&expected2, 28);

ck_assert(s21_is_equal(value_1, expected1) == 1);
ck_assert(s21_is_equal(value_2, expected2) == 1);

#test positive_s21_is_equal_00
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
bool result = s21_is_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_equal_01
s21_decimal value_1 = {{0, 500, 1, 0}};
s21_decimal value_2 = {{0, 500, 1, 0}};
set_sign(&value_1, minus);
set_sign(&value_2, minus);
set_scale(&value_1, 27);
set_scale(&value_2, 27);
bool result = s21_is_equal(value_1, value_2);
ck_assert(result == 1);

#test negative_s21_is_equal_00
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
bool result = s21_is_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_equal_01
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{1, 0, 0, 0}};
set_sign(&value_1, minus);
bool result = s21_is_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_equal_02
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{1, 0, 0, 0}};
set_scale(&value_1, 27);
bool result = s21_is_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_equal_03
s21_decimal value_1 = {{0, 1, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
bool result = s21_is_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_not_equal_00
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
bool result = s21_is_not_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_not_equal_01
s21_decimal value_1 = {{0, 500, 1, 0}};
s21_decimal value_2 = {{0, 500, 1, 0}};
set_sign(&value_1, minus);
set_sign(&value_2, minus);
set_scale(&value_1, 27);
set_scale(&value_2, 27);
bool result = s21_is_not_equal(value_1, value_2);
ck_assert(result == 0);

#test positive_s21_is_not_equal_00
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
bool result = s21_is_not_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_not_equal_01
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{1, 0, 0, 0}};
set_sign(&value_1, minus);
bool result = s21_is_not_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_not_equal_02
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{1, 0, 0, 0}};
set_scale(&value_1, 27);
bool result = s21_is_not_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_not_equal_03
s21_decimal value_1 = {{0, 1, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
bool result = s21_is_not_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_less_00
s21_decimal value_1 = {{0, 1, 0, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
bool result = s21_is_less(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_less_01
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
bool result = s21_is_less(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_less_02
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
set_sign(&value_1, minus);
bool result = s21_is_less(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_less_03
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
set_scale(&value_1, 27);
set_scale(&value_2, 26);
bool result = s21_is_less(value_1, value_2);
ck_assert(result == 1);

#test negative_s21_is_less_00
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 1, 0, 0}};
bool result = s21_is_less(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_less_01
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
bool result = s21_is_less(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_less_02
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
set_sign(&value_2, minus);
bool result = s21_is_less(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_less_03
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
set_scale(&value_1, 25);
set_scale(&value_2, 26);
bool result = s21_is_less(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_less_04
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
bool result = s21_is_less(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_greater_00
s21_decimal value_1 = {{0, 1, 0, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
bool result = s21_is_greater(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_greater_01
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
bool result = s21_is_greater(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_greater_02
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
set_sign(&value_1, minus);
bool result = s21_is_greater(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_greater_03
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
set_scale(&value_1, 27);
set_scale(&value_2, 26);
bool result = s21_is_greater(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_greater_04
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
bool result = s21_is_greater(value_1, value_2);
ck_assert(result == 0);

#test positive_s21_is_greater_00
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 1, 0, 0}};
bool result = s21_is_greater(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_greater_01
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
bool result = s21_is_greater(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_greater_02
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
set_sign(&value_2, minus);
bool result = s21_is_greater(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_greater_03
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
set_scale(&value_1, 25);
set_scale(&value_2, 26);
bool result = s21_is_greater(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_less_or_equal_000
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
bool result = s21_is_less_or_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_less_or_equal_00
s21_decimal value_1 = {{0, 1, 0, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
bool result = s21_is_less_or_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_less_or_equal_01
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
bool result = s21_is_less_or_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_less_or_equal_02
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
set_sign(&value_1, minus);
bool result = s21_is_less_or_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_less_or_equal_03
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
set_scale(&value_1, 27);
set_scale(&value_2, 26);
bool result = s21_is_less_or_equal(value_1, value_2);
ck_assert(result == 1);

#test negative_s21_is_less_or_equal_00
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 1, 0, 0}};
bool result = s21_is_less_or_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_less_or_equal_01
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
bool result = s21_is_less_or_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_less_or_equal_02
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
set_sign(&value_2, minus);
bool result = s21_is_less_or_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_less_or_equal_03
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
set_scale(&value_1, 25);
set_scale(&value_2, 26);
bool result = s21_is_less_or_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_greater_or_equal_00
s21_decimal value_1 = {{0, 1, 0, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
bool result = s21_is_greater_or_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_greater__or_equal01
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
bool result = s21_is_greater_or_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_greater__or_equal02
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
set_sign(&value_1, minus);
bool result = s21_is_greater_or_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_greater_or_equal_03
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
set_scale(&value_1, 27);
set_scale(&value_2, 26);
bool result = s21_is_greater_or_equal(value_1, value_2);
ck_assert(result == 0);

#test positive_s21_is_greater_or_equal_000
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
bool result = s21_is_greater_or_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_greater_or_equal_00
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 1, 0, 0}};
bool result = s21_is_greater_or_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_greater_or_equal_01
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
bool result = s21_is_greater_or_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_greater_or_equal_02
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
set_sign(&value_2, minus);
bool result = s21_is_greater_or_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_greater_or_equal_03
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
set_scale(&value_1, 25);
set_scale(&value_2, 26);
bool result = s21_is_greater_or_equal(value_1, value_2);
ck_assert(result == 1);

#test truncate_1
s21_decimal value = {{25, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{2, 0, 0, 0}};
set_scale(&value, 1);
set_scale(&expected, 0);
s21_truncate(value, &result);
int err_code = s21_is_equal(result, expected);
ck_assert(err_code == 1);

#test truncate_2
s21_decimal value = {{12345, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{123, 0, 0, 0}};
set_scale(&value, 2);
set_scale(&expected, 0);
s21_truncate(value, &result);
int err_code = s21_is_equal(result, expected);
ck_assert(err_code == 1);

#test truncate_3
s21_decimal value = {{98765, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{987, 0, 0, 0}};
set_scale(&value, 2);
set_scale(&expected, 0);
s21_truncate(value, &result);
int err_code = s21_is_equal(result, expected);
ck_assert(err_code == 1);

#test truncate_4
s21_decimal value = {{1000, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{10, 0, 0, 0}};
set_scale(&value, 2);
set_scale(&expected, 0);
s21_truncate(value, &result);
int err_code = s21_is_equal(result, expected);
ck_assert(err_code == 1);

#test truncate_5
s21_decimal value = {{250, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{25, 0, 0, 0}};
set_sign(&value, minus);
set_sign(&expected, minus);
set_scale(&value, 1);
set_scale(&expected, 0);
s21_truncate(value, &result);
int err_code = s21_is_equal(result, expected);
ck_assert(err_code == 1);

#test truncate_6
s21_decimal value = {{123456789, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{1234567, 0, 0, 0}};
set_sign(&value, minus);
set_sign(&expected, minus);
set_scale(&value, 2);
set_scale(&expected, 0);
s21_truncate(value, &result);
int err_code = s21_is_equal(result, expected);
ck_assert(err_code == 1);

#test truncate_7
s21_decimal value = {{0, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{0, 0, 0, 0}};
set_scale(&value, 3);
set_scale(&expected, 0);
s21_truncate(value, &result);
int err_code = s21_is_equal(result, expected);
ck_assert(err_code == 1);

#test truncate_8
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-171701", &value);
str_to_decimal("-171701", &expected);
int err_code = s21_truncate(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test truncate_9
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-0", &value);
str_to_decimal("-0", &expected);
int err_code = s21_truncate(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test truncate_10
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-0.1412132131231", &value);
str_to_decimal("-0", &expected);
int err_code = s21_truncate(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test truncate_11
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-4213213.21312", &value);
str_to_decimal("-4213213", &expected);
int err_code = s21_truncate(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test truncate_12
s21_decimal value;
s21_decimal result;
set_scale(&value, 29);
int err_code = s21_truncate(value, &result);
ck_assert(err_code == 1);

#test truncate_13
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("79228162514264337593543950335", &value);
str_to_decimal("79228162514264337593543950335", &expected);
int err_code = s21_truncate(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test truncate_14
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-79228162514264337593543950335", &value);
str_to_decimal("-79228162514264337593543950335", &expected);
int err_code = s21_truncate(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test round_1
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-4213213.21312", &value);
str_to_decimal("-4213213", &expected);
int err_code = s21_round(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test round_2
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-4213213.71312", &value);
str_to_decimal("-4213214", &expected);
int err_code = s21_round(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test round_3
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-4213213.51312", &value);
str_to_decimal("-4213214", &expected);
int err_code = s21_round(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test round_4
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("0", &value);
set_scale(&value, 29);
int err_code = s21_round(value, &result);
ck_assert(err_code == 1);

#test round_5
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-0", &value);
str_to_decimal("-0", &expected);
int err_code = s21_round(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test round_6
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-0.4", &value);
str_to_decimal("-0", &expected);
int err_code = s21_round(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test round_7
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("79228162514264337593543950335", &value);
str_to_decimal("79228162514264337593543950335", &expected);
int err_code = s21_round(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test round_8
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-79228162514264337593543950335", &value);
str_to_decimal("-79228162514264337593543950335", &expected);
int err_code = s21_round(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test floor_1
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("4213213.21312", &value);
str_to_decimal("4213213", &expected);
int err_code = s21_floor(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test floor_2
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-4213213.71312", &value);
str_to_decimal("-4213214", &expected);
int err_code = s21_floor(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test floor_3
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-4213213.51312", &value);
str_to_decimal("-4213214", &expected);
int err_code = s21_floor(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test floor_4
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("0", &value);
set_scale(&value, 29);
int err_code = s21_floor(value, &result);
ck_assert(err_code == 1);

#test floor_5
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-0", &value);
str_to_decimal("-0", &expected);
int err_code = s21_floor(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test floor_6
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-0.4", &value);
str_to_decimal("-1", &expected);
int err_code = s21_floor(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test floor_7
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("79228162514264337593543950335", &value);
str_to_decimal("79228162514264337593543950335", &expected);
int err_code = s21_floor(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test floor_8
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-79228162514264337593543950335", &value);
str_to_decimal("-79228162514264337593543950335", &expected);
int err_code = s21_floor(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test floor_9
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-7922816251426433759354395033.5", &value);
str_to_decimal("-7922816251426433759354395034", &expected);
int err_code = s21_floor(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test floor_10
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-4213213.001", &value);
str_to_decimal("-4213214", &expected);
int err_code = s21_floor(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);


#test bank_round_1
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("4213213.21312", &value);
str_to_decimal("4213213", &expected);
int err_code = bank_round(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test bank_round_2
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-4213213.71312", &value);
str_to_decimal("-4213214", &expected);
int err_code = bank_round(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test bank_round_3
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-4213213.51312", &value);
str_to_decimal("-4213214", &expected);
int err_code = bank_round(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test bank_round_4
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("0", &value);
set_scale(&value, 29);
int err_code = bank_round(value, &result);
ck_assert(err_code == 1);

#test bank_round_5
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-0", &value);
str_to_decimal("-0", &expected);
int err_code = bank_round(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test bank_round_6
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-0.4", &value);
str_to_decimal("-0", &expected);
int err_code = bank_round(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test bank_round_7
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("79228162514264337593543950335", &value);
str_to_decimal("79228162514264337593543950335", &expected);
int err_code = bank_round(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test bank_round_8
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-79228162514264337593543950335", &value);
str_to_decimal("-79228162514264337593543950335", &expected);
int err_code = bank_round(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test bank_round_9
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-7922816251426433759354395033.5", &value);
str_to_decimal("-7922816251426433759354395034", &expected);
int err_code = bank_round(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test bank_round_10
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-4213213.001", &value);
str_to_decimal("-4213213", &expected);
int err_code = bank_round(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test bank_round_11
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-4213213.51", &value);
str_to_decimal("-4213214", &expected);
int err_code = bank_round(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test bank_round_12
s21_decimal value;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-4213214.5", &value);
str_to_decimal("-4213214", &expected);
int err_code = bank_round(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test truncate_positive_float
s21_decimal value = {{12345, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{123, 0, 0, 0}};
set_scale(&value, 2);
set_scale(&expected, 0);
int return_code = s21_truncate(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_div - деление двух положительных дробных
#test div_positive_float
s21_decimal value_1 = {{100, 0, 0, 0}};
s21_decimal value_2 = {{25, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{4, 0, 0, 0}};
set_scale(&value_1, 2);
set_scale(&value_2, 2);
set_scale(&expected, 0);
int return_code = s21_div(value_1, value_2, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_div - деление двух отрицательных дробных
#test div_negative_float
s21_decimal value_1 = {{100, 0, 0, 0x80000000}};
s21_decimal value_2 = {{25, 0, 0, 0x80000000}};
s21_decimal result;
s21_decimal expected = {{4, 0, 0, 0}};
set_scale(&value_1, 2);
set_scale(&value_2, 2);
set_scale(&expected, 0);
int return_code = s21_div(value_1, value_2, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_div - деление положительного на отрицательное
#test div_positive_negative
s21_decimal value_1 = {{100, 0, 0, 0}};
s21_decimal value_2 = {{25, 0, 0, 0x80000000}};
s21_decimal result;
s21_decimal expected = {{4, 0, 0, 0}};
set_scale(&value_1, 2);
set_scale(&value_2, 2);
set_scale(&expected, 0);
set_sign(&expected, minus);
int return_code = s21_div(value_1, value_2, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_div - деление отрицательного на положительное
#test div_negative_positive
s21_decimal value_1 = {{100, 0, 0, 0x80000000}};
s21_decimal value_2 = {{25, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{4, 0, 0, 0x80000000}};
set_scale(&value_1, 2);
set_scale(&value_2, 2);
set_scale(&expected, 0);
int return_code = s21_div(value_1, value_2, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

#test div_by_zero
s21_decimal value_1 = {{100, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result;
int return_code = s21_div(value_1, value_2, &result);
ck_assert(return_code == 3);

#test s21_negate1
s21_decimal value;
s21_decimal expected;
str_to_decimal("171701", &value);
str_to_decimal("-171701", &expected);
int err_code = s21_negate(value, &value);
ck_assert(value.bits[0] == expected.bits[0]);
ck_assert(value.bits[1] == expected.bits[1]);
ck_assert(value.bits[2] == expected.bits[2]);
ck_assert(value.bits[3] == expected.bits[3]);
ck_assert(err_code == 0);

#test s21_negate2
s21_decimal value;
s21_decimal expected;
str_to_decimal("-171701", &value);
str_to_decimal("171701", &expected);
int err_code = s21_negate(value, &value);
ck_assert(value.bits[0] == expected.bits[0]);
ck_assert(value.bits[1] == expected.bits[1]);
ck_assert(value.bits[2] == expected.bits[2]);
ck_assert(value.bits[3] == expected.bits[3]);
ck_assert(err_code == 0);

#test s21_negate3
s21_decimal value;
s21_decimal expected;
str_to_decimal("-171701.31231213", &value);
str_to_decimal("171701.31231213", &expected);
int err_code = s21_negate(value, &value);
ck_assert(value.bits[0] == expected.bits[0]);
ck_assert(value.bits[1] == expected.bits[1]);
ck_assert(value.bits[2] == expected.bits[2]);
ck_assert(value.bits[3] == expected.bits[3]);
ck_assert(err_code == 0);

#test s21_negate4
// negate есть умножение на -1
s21_decimal value;
s21_decimal expected;
str_to_decimal("-0", &value);
str_to_decimal("0", &expected);
int err_code = s21_negate(value, &value);
ck_assert(value.bits[0] == expected.bits[0]);
ck_assert(value.bits[1] == expected.bits[1]);
ck_assert(value.bits[2] == expected.bits[2]);
ck_assert(value.bits[3] == expected.bits[3]);
ck_assert(err_code == 0);

#test s21_negate5
s21_decimal value;
s21_decimal expected;
str_to_decimal("0", &value);
str_to_decimal("-0", &expected);
int err_code = s21_negate(value, &value);
ck_assert(value.bits[0] == expected.bits[0]);
ck_assert(value.bits[1] == expected.bits[1]);
ck_assert(value.bits[2] == expected.bits[2]);
ck_assert(value.bits[3] == expected.bits[3]);
ck_assert(err_code == 0);

#test s21_negate6
s21_decimal value;
s21_decimal expected;
str_to_decimal("79228162514264337593543950335", &value);
str_to_decimal("-79228162514264337593543950335", &expected);
int err_code = s21_negate(value, &value);
ck_assert(value.bits[0] == expected.bits[0]);
ck_assert(value.bits[1] == expected.bits[1]);
ck_assert(value.bits[2] == expected.bits[2]);
ck_assert(value.bits[3] == expected.bits[3]);
ck_assert(err_code == 0);

#test s21_negate7
s21_decimal value;
s21_decimal expected;
str_to_decimal("-79228162514264337593543950335", &value);
str_to_decimal("79228162514264337593543950335", &expected);
int err_code = s21_negate(value, &value);
ck_assert(value.bits[0] == expected.bits[0]);
ck_assert(value.bits[1] == expected.bits[1]);
ck_assert(value.bits[2] == expected.bits[2]);
ck_assert(value.bits[3] == expected.bits[3]);
ck_assert(err_code == 0);

#test s21_negate8
s21_decimal value;
s21_decimal expected;
str_to_decimal("-7922816251426.4337593543950335", &value);
str_to_decimal("7922816251426.4337593543950335", &expected);
int err_code = s21_negate(value, &value);
ck_assert(value.bits[0] == expected.bits[0]);
ck_assert(value.bits[1] == expected.bits[1]);
ck_assert(value.bits[2] == expected.bits[2]);
ck_assert(value.bits[3] == expected.bits[3]);
ck_assert(err_code == 0);

#test s21_negate9
s21_decimal value;
s21_decimal expected;
str_to_decimal("79228162514264337593543950.335", &value);
str_to_decimal("-79228162514264337593543950.335", &expected);
int err_code = s21_negate(value, &value);
ck_assert(value.bits[0] == expected.bits[0]);
ck_assert(value.bits[1] == expected.bits[1]);
ck_assert(value.bits[2] == expected.bits[2]);
ck_assert(value.bits[3] == expected.bits[3]);
ck_assert(err_code == 0);


#test inf_div
s21_decimal value_1;
s21_decimal value_2;
s21_decimal expected;
s21_decimal result;
str_to_decimal("20", &value_1);
str_to_decimal("7", &value_1);
str_to_decimal("2.8571428571428571428571428571", &expected);
int return_code = s21_div(value_1, value_2, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

#test neginf_div
s21_decimal value_1;
s21_decimal value_2;
s21_decimal expected;
s21_decimal result;
str_to_decimal("-20", &value_1);
str_to_decimal("7", &value_1);
str_to_decimal("-2.8571428571428571428571428571", &expected);
int return_code = s21_div(value_1, value_2, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

#test div2
s21_decimal value_1;
s21_decimal value_2;
s21_decimal result;
s21_decimal expected;
str_to_decimal("171701", &value_1);
str_to_decimal("200000", &value_2);
str_to_decimal("858505", &expected);
set_scale(&expected, 6);
int return_code = s21_div(value_1, value_2, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

#test div3
s21_decimal value_1;
s21_decimal value_2;
s21_decimal result;
s21_decimal expected;
str_to_decimal(MAX_DECIMAL, &value_1);
str_to_decimal("1000000000", &value_2);
str_to_decimal(MAX_DECIMAL, &expected);
set_scale(&expected, 9);
int return_code = s21_div(value_1, value_2, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

#test div4
s21_decimal value_1;
s21_decimal value_2;
s21_decimal result;
s21_decimal expected;
str_to_decimal("1432345362332124431467430", &value_1);
str_to_decimal("320", &value_2);
str_to_decimal("447607925728788884833571875", &expected);
set_scale(&expected, 5);
int return_code = s21_div(value_1, value_2, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

#test from_float_to_decimal_1
float fvalue = -79228157791897854723898736640.f;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-79228160000000000000000000000", &expected);
int err_code = s21_from_float_to_decimal(fvalue, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 1);


#test from_float_to_decimal_2
float fvalue = 0.123456f;
s21_decimal result;
s21_decimal expected;
str_to_decimal("0.123456", &expected);
int err_code = s21_from_float_to_decimal(fvalue, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test from_float_to_decimal_3
float fvalue_inf = INFINITY;
s21_decimal result_inf;
s21_decimal expected_inf;
str_to_decimal("0", &expected_inf);
int err_code = s21_from_float_to_decimal(fvalue_inf, &result_inf);
ck_assert(err_code == 1);

#test from_float_to_decimal_4
float fvalue_neg_inf = -INFINITY;
s21_decimal result_neg_inf;
s21_decimal expected_neg_inf;
str_to_decimal("0", &expected_neg_inf);
int err_code = s21_from_float_to_decimal(fvalue_neg_inf, &result_neg_inf);
ck_assert(err_code == 1);

#test from_float_to_decimal_5
float fvalue_nan = NAN;
s21_decimal result_nan;
s21_decimal expected_nan;
str_to_decimal("0", &expected_nan);
int err_code = s21_from_float_to_decimal(fvalue_nan, &result_nan);
ck_assert(err_code == 1);

#test from_float_to_decimal_6
float fvalue = 12345;
s21_decimal result;
s21_decimal expected;
str_to_decimal("12345", &expected);
int err_code = s21_from_float_to_decimal(fvalue, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test from_float_to_decimal_7
float fvalue = 0.12345678;
s21_decimal result;
s21_decimal expected;
str_to_decimal("0.1234568", &expected);
int err_code = s21_from_float_to_decimal(fvalue, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test from_float_to_decimal_8
float fvalue = 0.12345671;
s21_decimal result;
s21_decimal expected;
str_to_decimal("0.1234567", &expected);
int err_code = s21_from_float_to_decimal(fvalue, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test from_float_to_decimal_9
float fvalue = 0.12345;
s21_decimal result;
s21_decimal expected;
str_to_decimal("0.12345", &expected);
int err_code = s21_from_float_to_decimal(fvalue, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test from_float_to_decimal_10
float fvalue = 0.f;
s21_decimal result;
s21_decimal expected;
str_to_decimal("0", &expected);
int err_code = s21_from_float_to_decimal(fvalue, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test from_float_to_decimal_11
float fvalue = -11111111.123123;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-11111110", &expected);
int err_code = s21_from_float_to_decimal(fvalue, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test from_float_to_decimal_12
float fvalue = 11111.123123;
s21_decimal result;
s21_decimal expected;
str_to_decimal("11111.12", &expected);
int err_code = s21_from_float_to_decimal(fvalue, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test from_float_to_decimal_13
float fvalue = -11111.129123;
s21_decimal result;
s21_decimal expected;
str_to_decimal("-11111.13", &expected);
int err_code = s21_from_float_to_decimal(fvalue, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test from_float_to_decimal_14
float fvalue = 79228162514264337593543950336.f;
s21_decimal result;
int err_code = s21_from_float_to_decimal(fvalue, &result);
ck_assert(err_code == 1);

#test from_float_to_decimal_15
float fvalue = 1e-29;
s21_decimal result;
int err_code = s21_from_float_to_decimal(fvalue, &result);
ck_assert(err_code == 1);

#test from_float_to_decimal_16
float fvalue = 792281625142643375935439503351.f;
s21_decimal result;
int err_code = s21_from_float_to_decimal(fvalue, &result);
ck_assert(err_code == 1);

#test from_float_to_decimal_17
float fvalue = -0.f;
s21_decimal result;
s21_decimal expected;
int err_code = s21_from_float_to_decimal(fvalue, &result);
str_to_decimal("-0", &expected);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(err_code == 0);

#test from_decimal_to_float_1
s21_decimal value_1 = {{0}};
float result = 0;
str_to_decimal("78123", &value_1);
int err_code = s21_from_decimal_to_float(value_1, &result);
ck_assert(0 == err_code);
ck_assert(78123.0 == result);

#test from_decimal_to_float_2
s21_decimal value_1 = {{0}};
float result = 0;
str_to_decimal("781865", &value_1);
set_sign(&value_1, 1);
int err_code = s21_from_decimal_to_float(value_1, &result);
ck_assert(0 == err_code);
ck_assert(-781865.0 == result);

#test from_decimal_to_float_3
s21_decimal value_1 = {{0}};
float result = 0;
str_to_decimal("6408.25", &value_1);
set_sign(&value_1, 1);
int err_code = s21_from_decimal_to_float(value_1, &result);
ck_assert(0 == err_code);
ck_assert(-6408.25 == result);

#test from_decimal_to_float_4
s21_decimal value_1;
float result = 0;
str_to_decimal("-0", &value_1);
int err_code = s21_from_decimal_to_float(value_1, &result);
ck_assert(0 == err_code);
ck_assert(-0.f == result);

#test from_decimal_to_float_5
s21_decimal value_1;
float result = 0;
str_to_decimal("0", &value_1);
int err_code = s21_from_decimal_to_float(value_1, &result);
ck_assert(0 == err_code);
ck_assert(0.f == result);

#test from_decimal_to_float_6
s21_decimal value_1;
float result = 0;
str_to_decimal("0", &value_1);
int err_code = s21_from_decimal_to_float(value_1, &result);
ck_assert(0 == err_code);
ck_assert(0.f == result);


#test from_int_to_decimal_0
int src = 6418934;
s21_decimal value = {{0}};
int err_code = s21_from_int_to_decimal(src, &value);
s21_decimal expected = {6418934, 0, 0, 0};
ck_assert(value.bits[0] == expected.bits[0]);
ck_assert(value.bits[1] == expected.bits[1]);
ck_assert(value.bits[2] == expected.bits[2]);
ck_assert(value.bits[3] == expected.bits[3]);
ck_assert(err_code == 0);

#test from_int_to_decimal_1
int src = -6418934;
s21_decimal value = {{0}};
int err_code = s21_from_int_to_decimal(src, &value);
s21_decimal expected = {6418934, 0, 0, 0};
set_sign(&expected, 1);
ck_assert(value.bits[0] == expected.bits[0]);
ck_assert(value.bits[1] == expected.bits[1]);
ck_assert(value.bits[2] == expected.bits[2]);
ck_assert(value.bits[3] == expected.bits[3]);
ck_assert(err_code == 0);

#test from_int_to_decimal_2
int src = 2147483647;
s21_decimal value = {{0}};
int err_code = s21_from_int_to_decimal(src, &value);
s21_decimal expected = {2147483647, 0, 0, 0};
ck_assert(value.bits[0] == expected.bits[0]);
ck_assert(value.bits[1] == expected.bits[1]);
ck_assert(value.bits[2] == expected.bits[2]);
ck_assert(value.bits[3] == expected.bits[3]);
ck_assert(err_code == 0);

#test from_int_to_decimal_3
int src = -2147483648;
s21_decimal value = {{0}};
int err_code = s21_from_int_to_decimal(src, &value);
s21_decimal expected = {2147483648, 0, 0, 0};
set_sign(&expected, 1);
ck_assert(value.bits[0] == expected.bits[0]);
ck_assert(value.bits[1] == expected.bits[1]);
ck_assert(value.bits[2] == expected.bits[2]);
ck_assert(value.bits[3] == expected.bits[3]);
ck_assert(err_code == 0);

#test from_int_to_decimal_4
s21_decimal value;
s21_decimal expected;
int src = 0;
str_to_decimal("0", &expected);
int err_code = s21_from_int_to_decimal(src, &value);
ck_assert(value.bits[0] == expected.bits[0]);
ck_assert(value.bits[1] == expected.bits[1]);
ck_assert(value.bits[2] == expected.bits[2]);
ck_assert(value.bits[3] == expected.bits[3]);
ck_assert(err_code == 0);

#test from_int_to_decimal_5
s21_decimal value;
s21_decimal expected;
int src = -232432;
str_to_decimal("-232432", &expected);
int err_code = s21_from_int_to_decimal(src, &value);
ck_assert(value.bits[0] == expected.bits[0]);
ck_assert(value.bits[1] == expected.bits[1]);
ck_assert(value.bits[2] == expected.bits[2]);
ck_assert(value.bits[3] == expected.bits[3]);
ck_assert(err_code == 0);

#test from_decimal_to_int_1
int src = 0;
s21_decimal value = {2147483647, 1, 0, 0};
set_sign(&value, 1);
int err_code = s21_from_decimal_to_int(value, &src);
ck_assert(err_code == 1);

#test from_decimal_to_int_2
int src = 0;
s21_decimal value = {2147483647, 1, 0, 0};
int err_code = s21_from_decimal_to_int(value, &src);
ck_assert(err_code == 1);

#test from_decimal_to_int_3
int src = 0;
s21_decimal value;
set_scale(&value, 3);
str_to_decimal("0.001", &value);
int err_code = s21_from_decimal_to_int(value, &src);
ck_assert(src == 0);
ck_assert(err_code == 0);

#test from_decimal_to_int_4
int result = 0;
s21_decimal value;
str_to_decimal("-21474836.4", &value);
int err_code = s21_from_decimal_to_int(value, &result);
ck_assert(result == -21474836);
ck_assert(err_code == 0);

#test from_decimal_to_int_5
int result = 0;
s21_decimal value;
str_to_decimal("-21476.41212321121", &value);
int err_code = s21_from_decimal_to_int(value, &result);
ck_assert(result == -21476);
ck_assert(err_code == 0);

#test from_decimal_to_int_6
int result = 0;
s21_decimal value;
str_to_decimal("-214761312312", &value);
int err_code = s21_from_decimal_to_int(value, &result);
ck_assert(err_code == 1);

#test from_decimal_to_int_7
int result = 0;
s21_decimal value;
str_to_decimal("214761312312", &value);
int err_code = s21_from_decimal_to_int(value, &result);
ck_assert(err_code == 1);

#test from_decimal_to_int_8
int result = 0;
s21_decimal value;
str_to_decimal("-2.147611213123121", &value);
int err_code = s21_from_decimal_to_int(value, &result);
ck_assert(result == -2);
ck_assert(err_code == 0);

#test from_decimal_to_int_9
int src = 0;
s21_decimal value = {0, 0, 1, 0};
int err_code = s21_from_decimal_to_int(value, &src);
ck_assert(err_code == 1);

#test big_to_decimal_0
big_decimal value = {0, 0, 0, 1, 0, 0, 0};
s21_decimal result = {{0}};
int err_code = big_to_decimal(value, &result);
ck_assert(err_code == 1);

#test big_to_decimal_1
s21_decimal value_1 = {1, 0, 0, 0};
set_sign(&value_1, 1);
big_decimal value = {{0}};
decimal_to_big(value_1, &value);
value.bits[3] = 1;
s21_decimal result = {{0}};
int err_code = big_to_decimal(value, &result);
ck_assert(err_code == 2);

#test big_to_decimal_2
big_decimal value = {0, 1, 0, 0, 0, 0, 0};
s21_decimal result = {{0}};
int err_code = big_to_decimal(value, &result);
ck_assert(result.bits[1] == 1);

#test big_to_int_1
big_decimal value = {659865, 0, 0, 0, 0, 0, 0};
int result = big_to_int(value);
int expected = 659865;
ck_assert(result == expected);
