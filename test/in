#include <check.h>
#include <stdio.h>

#include "../decimal/s21_decimal.h"
#include "debug_helper.h"

// set_sign
// Функция set_sign поставить знак плюс
#test set_sign_positive
big_decimal value = {0};
Bset_sign(&value, plus);

ck_assert(((value.bits[3] >> 31) & 1) == plus);

// Функция set_sign поставить знак минус
#test set_sign_negative
big_decimal value = {0};
Bset_sign(&value, minus);

ck_assert(((value.bits[6] >> 31) & 1) == minus);

// get_sign
//  Функция get_sign проверить знак плюс
#test get_sign_positive
big_decimal value = {0};
Bset_sign(&value, plus);

ck_assert(Bget_sign(value) == plus);

// Функция get_sign проверить знак плюс
#test get_sign_negative
big_decimal value = {0};
Bset_sign(&value, minus);

ck_assert(Bget_sign(value) == minus);

// set_bit
//  Функция set_bit поменять бит 0 на бит 0 индекс 0
#test set_bit_zero_false
big_decimal value = (big_decimal){{0}};
Bset_bit(&value, 0, false);

ck_assert(Bget_bit(value, 0) == false);

// Функция set_bit поменять бит 0 на бит 1 индекс 0
#test set_bit_zero_true
big_decimal value = (big_decimal){{0}};
Bset_bit(&value, 0, true);

ck_assert(Bget_bit(value, 0) == true);

// Функция set_bit поменять бит 1 на бит 0 индекс 0
#test set_bit_one_false
big_decimal value = (big_decimal){{1}};
Bset_bit(&value, 0, false);

ck_assert(Bget_bit(value, 0) == false);

// Функция set_bit поменять бит 1 на бит 1 индекс 0
#test set_bit_one_true
big_decimal value = (big_decimal){{1}};
Bset_bit(&value, 0, true);

ck_assert(Bget_bit(value, 0) == true);

// Функция set_bit поменять бит 0 на бит 0 индекс 16
#test set_bit_middle_false
big_decimal value = (big_decimal){{0}};
Bset_bit(&value, 16, false);

ck_assert(Bget_bit(value, 16) == false);

// Функция set_bit поменять бит 0 на бит 1 индекс 16
#test set_bit_middle_true
big_decimal value = (big_decimal){{0}};
Bset_bit(&value, 16, true);

ck_assert(Bget_bit(value, 16) == true);

// Функция set_bit поменять бит 1 на бит 0 индекс 16
#test set_bit_middle_false_one
big_decimal value = (big_decimal){{1}};
Bset_bit(&value, 16, false);

ck_assert(Bget_bit(value, 16) == false);

// Функция set_bit поменять бит 1 на бит 1 индекс 16
#test set_bit_middle_true_one
big_decimal value = (big_decimal){{1}};
Bset_bit(&value, 16, true);

ck_assert(Bget_bit(value, 16) == true);

// Функция set_bit поменять бит 1 на бит 0 индекс 96
#test set_bit_overflow_false_one
big_decimal value = (big_decimal){{1}};
Bset_bit(&value, 96, false);

ck_assert(Bget_bit(value, 96) == false);

// s21_add
// Функция s21_add сложение двух положительных чисел
#test add_positive_numbers
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{30, 0, 0, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение двух отрицательных чисел
#test add_negative_numbers
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
s21_decimal result;
s21_decimal expected = {{30, 0, 0, 0x80000000}};

int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение положительного и отрицательного чисел
#test add_positive_and_negative
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
s21_decimal result;
s21_decimal expected = {{10, 0, 0, 0x80000000}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного и положительного чисел
#test add_negative_and_positive
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{10, 0, 0, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение двух положительных дробных
#test add_positive_float
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  set_scale(&value_2, 5);
  s21_decimal result;
  s21_decimal expected = {{200001, 0, 0, 0}};
  set_scale(&expected, 9);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

// Функция s21_add сложение двух отрицательных дробных
#test add_negative_float
 s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
 s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
 set_scale(&value_1, 10);
 set_scale(&value_2, 5);
 s21_decimal result;
 s21_decimal expected = {{200001, 0, 0, 0x80000000}};
 set_scale(&expected, 9);
 int return_code = s21_add(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_add сложение положительного и отрицательного дробных
#test add_positive_and_negative_float
 s21_decimal value_1 = {{10, 0, 0, 0}};
 s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
 set_scale(&value_1, 10);
 set_scale(&value_2, 5);
 s21_decimal result;
 s21_decimal expected = {{199999, 0, 0, 0x80000000}};
 set_scale(&expected, 9);
 int return_code = s21_add(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного и положительного дробных
#test add_negative_and_positive_float
 s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
 s21_decimal value_2 = {{20, 0, 0, 0}};
 set_scale(&value_1, 10);
 set_scale(&value_2, 5);
 s21_decimal result;
 s21_decimal expected = {{199999, 0, 0, 0}};
 set_scale(&expected, 9);
 int return_code = s21_add(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);
// Функция s21_add сложение положительного дробного и целого
 #test add_positive_float_int
  s21_decimal value_1 = {{10, 0, 0, 0}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_scale(&value_1, 10);
  s21_decimal result;
  s21_decimal expected = {{2820130817, 4, 0, 0}};
  set_scale(&expected, 9);
  int return_code = s21_add(value_1, value_2, &result);

  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного дробного и целого
#test add_negative_float_int
 s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
 s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
 set_scale(&value_1, 10);
 s21_decimal result;
 s21_decimal expected = {{2820130817, 4, 0, 0x80000000}};
 set_scale(&expected, 9);
 int return_code = s21_add(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного дробного и положительного целого
#test add_negative_float_positive_int
 s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
 s21_decimal value_2 = {{20, 0, 0, 0}};
 set_scale(&value_1, 10);
 s21_decimal result;
 s21_decimal expected = {{2820130815, 4, 0, 0}};
 set_scale(&expected, 9);
 int return_code = s21_add(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_add сложение положительного дробного и отрицательного целого
#test add_positive_float_negative_int
 s21_decimal value_1 = {{10, 0, 0, 0}};
 s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
 set_scale(&value_1, 10);
 s21_decimal result;
 s21_decimal expected = {{2820130815, 4, 0, 0x80000000}};
 set_scale(&expected, 9);
 int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение положительного целого отрицательного дробного
#test add_positive_int_negative_float
 s21_decimal value_1 = {{10, 0, 0, 0}};
 s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
 set_scale(&value_2, 5);
 s21_decimal result;
 s21_decimal expected = {{99998, 0, 0, 0}};
 set_scale(&expected, 4);
 int return_code = s21_add(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);
//
//// Функция s21_add сложение отрицательного целого положительного дробного
#test add_negative_int_positive_float
 s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
 s21_decimal value_2 = {{20, 0, 0, 0}};
 set_scale(&value_2, 5);
 s21_decimal result;
 s21_decimal expected = {{99998, 0, 0, 0x80000000}};
 set_scale(&expected, 4);
 int return_code = s21_add(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_add очень большое число и маленькое - переполнение
#test add_overflow
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{1, 0, 0, 0}};
s21_decimal result;

int return_code = s21_add(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_add сложение очень маленького и очень большого - переполнение
#test add_overflow_two
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal result;

int return_code = s21_add(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_add сложение двух очень больших - переполнение ????
// 79228162514264337593543950335+79228162514264337593543950335=79228162514264337593543950334
#test add_overflow_three
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal result;

int return_code = s21_add(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_add сложение отрицательных очень большое число и маленькое -
// переполнение отрицательная бесконечность
#test add_overflow_negative
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal value_2 = {{1, 0, 0, 0x80000000}};
s21_decimal result;

int return_code = s21_add(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_add сложение отрицательных очень маленького и очень большого -
// переполнение отрицательная бесконечность
#test add_overflow_negative_two
s21_decimal value_1 = {{1, 0, 0, 0x80000000}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal result;

int return_code = s21_add(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_add сложение отрицательных двух очень больших - переполнение ???
//-79228162514264337593543950335-79228162514264337593543950335=-79228162514264337593543950334
#test add_overflow_negative_three
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal result;

int return_code = s21_add(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_add сложение двух нулей
#test add_positive_numbers_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение положительного и отрицательного нуля
#test add_positive_and_negative_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0x80000000}};
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного и положительного нуля
#test add_negative_and_positive_zero
s21_decimal value_1 = {{0, 0, 0, 0x80000000}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение отрицательных нулей
#test add_negative_numbers_zero
s21_decimal value_1 = {{0, 0, 0, 0x80000000}};
s21_decimal value_2 = {{0, 0, 0, 0x80000000}};
s21_decimal expected = {{0, 0, 0, 0}};
s21_decimal result;
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение положительного числа и нуля
#test add_positive_numbers_and_zero
s21_decimal value_1 = {{15, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение нуля и положительного числа
#test add_zero_and_positive_numbers
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение положительного дробного и нуля
#test add_positive_float_and_zero
 s21_decimal value_1 = {{15, 0, 0, 0}};
 s21_decimal value_2 = {{0, 0, 0, 0}};
 set_scale(&value_1, 7);
 s21_decimal result;
 s21_decimal expected = {{15, 0, 0, 0}};
 set_scale(&expected, 7);
 int return_code = s21_add(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_add сложение нуля и положительного дробного
#test add_zero_and_positive_float
 s21_decimal value_1 = {{0, 0, 0, 0}};
 s21_decimal value_2 = {{15, 0, 0, 0}};
 set_scale(&value_2, 7);
 s21_decimal result;
 s21_decimal expected = {{15, 0, 0, 0}};
 set_scale(&expected, 7);
 int return_code = s21_add(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного числа и нуля
#test add_negative_numbers_and_zero
s21_decimal value_1 = {{15, 0, 0, 0x80000000}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0x80000000}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение нуля и отрицательного числа
#test add_zero_and_negative_numbers
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0x80000000}};
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0x80000000}};
int return_code = s21_add(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного дробного и нуля
#test add_negative_float_and_zero
 s21_decimal value_1 = {{15, 0, 0, 0x80000000}};
 s21_decimal value_2 = {{0, 0, 0, 0}};
 set_scale(&value_1, 7);
 s21_decimal result;
 s21_decimal expected = {{15, 0, 0, 0x80000000}};
 set_scale(&expected, 7);
 int return_code = s21_add(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_add сложение нуля и отрицательного дробного
#test add_zero_and_negative_float
 s21_decimal value_1 = {{0, 0, 0, 0}};
 s21_decimal value_2 = {{15, 0, 0, 0x80000000}};
 set_scale(&value_2, 7);
 s21_decimal result;
 s21_decimal expected = {{15, 0, 0, 0x80000000}};
 set_scale(&expected, 7);
 int return_code = s21_add(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_add сложение двух положительных чисел с большой мантиссой
#test add_positive_float_big_scale
 s21_decimal value_1 = {{1, 0, 0, 0}};
 s21_decimal value_2 = {{2, 0, 0, 0}};
 set_scale(&value_1, 28);
 set_scale(&value_2, 27);
 s21_decimal result;
 s21_decimal expected = {{21, 0, 0, 0}};
 set_scale(&expected, 28);
 int return_code = s21_add(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_add сложение двух отрицательных чисел с большой мантиссой
#test add_negative_float_big_scale_
 s21_decimal value_1 = {{1, 0, 0, 0x80000000}};
 s21_decimal value_2 = {{2, 0, 0, 0x80000000}};
 set_scale(&value_1, 28);
 set_scale(&value_2, 27);
 s21_decimal result;
 s21_decimal expected = {{21, 0, 0, 0x80000000}};
 set_scale(&expected, 28);
 int return_code = s21_add(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_add сложение отрицательного и положительного с большой
//мантиссой
#test add_negative_and_positive_float_big_scale_
 s21_decimal value_1 = {{1, 0, 0, 0x80000000}};
 s21_decimal value_2 = {{2, 0, 0, 0}};
 set_scale(&value_1, 28);
 set_scale(&value_2, 27);
 s21_decimal result;
 s21_decimal expected = {{19, 0, 0, 0}};
 set_scale(&expected, 28);
 int return_code = s21_add(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_add сложение положительного и отрицательного с большой
//мантиссой
#test add_positive_and_negative_float_big_scale
 s21_decimal value_1 = {{1, 0, 0, 0}};
 s21_decimal value_2 = {{2, 0, 0, 0x80000000}};
 set_scale(&value_1, 28);
 set_scale(&value_2, 27);
 s21_decimal result;
 s21_decimal expected = {{19, 0, 0, 0x80000000}};
 set_scale(&expected, 28);
 int return_code = s21_add(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);
//
//  ОКРУГЛЕНИЕ - поменять название тестов
//   Функция s21_add сложение двух положительных чисел с большой мантиссой с
//   ненулевыми разрядами
// #test add_positive_float_big_scale
//  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
//  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
//  set_scale(&value_1, 28);
//  set_scale(&value_2, 27);
//  s21_decimal result;
//  s21_decimal expected = ???;
//  set_scale(&expected, ???);
//  int return_code = s21_add(value_1, value_2, &result);
//
//  ck_assert(s21_is_equal(result, expected) == 1);
//  ck_assert(return_code == 0);
//
//// Функция s21_add сложение двух отрицательных чисел с большой мантиссой с
/// ненулевыми разрядами
//#test add_negative_float_big_scale
// s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// set_scale(&value_1, 28);
// set_scale(&value_2, 27);
// s21_decimal result;
// s21_decimal expected = ???;
// set_scale(&expected, ???);
// int return_code = s21_add(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);
//
//// Функция s21_add сложение отрицательного и положительного с большой
/// мантиссой с ненулевыми разрядами
//#test add_negative_and_positive_float_big_scale
// s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
// set_scale(&value_1, 28);
// set_scale(&value_2, 27);
// s21_decimal result;
// s21_decimal expected = ???;
// set_scale(&expected, ???);
// int return_code = s21_add(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);
//
//// Функция s21_add сложение положительного и отрицательного с большой
/// мантиссой с ненулевыми разрядами
//#test add_positive_and_negative_float_big_scale
// s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
// s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// set_scale(&value_1, 28);
// set_scale(&value_2, 27);
// s21_decimal result;
// s21_decimal expected = ???;
// set_scale(&expected, ???);
// int return_code = s21_add(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);

// s21_sub
// Функция s21_sub вычитание двух положительных целых чисел
#test sub_positive_numbers
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{10, 0, 0, 0x80000000}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание двух отрицательных целых чисел
#test sub_negative_numbers
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_sign(&value_1, minus);
set_sign(&value_2, minus);
s21_decimal expected = {{10, 0, 0, 0}};
s21_decimal result;
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание позитивного и отрицательного целых чисел
#test sub_positive_and_negative
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_sign(&value_2, minus);
s21_decimal result;
s21_decimal expected = {{30, 0, 0, 0}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательного и позитивного целых чисел
#test sub_negative_and_positive
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
set_sign(&value_1, minus);
s21_decimal result;
s21_decimal expected = {{30, 0, 0, 0x80000000}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание двух положительных дробных чисел
#test sub_positive_float
 s21_decimal value_1 = {{10, 0, 0, 0}};
 s21_decimal value_2 = {{20, 0, 0, 0}};
 set_scale(&value_1, 10);
 set_scale(&value_2, 5);
 s21_decimal result;
 s21_decimal expected = {{199999, 0, 0, 0x80000000}};
 set_scale(&expected, 9);
 int return_code = s21_sub(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_sub вычитание двух отрицательных дробных чисел
#test sub_negative_float
 s21_decimal value_1 = {{10, 0, 0, 0}};
 s21_decimal value_2 = {{20, 0, 0, 0}};
 set_sign(&value_1, minus);
 set_sign(&value_2, minus);
 set_scale(&value_1, 10);
 set_scale(&value_2, 5);
 s21_decimal result;
 s21_decimal expected = {{199999, 0, 0, 0}};
 set_scale(&expected, 9);
 int return_code = s21_sub(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_sub вычитание положительного и отрицательного дробных чисел
#test sub_positive_and_negative_float
 s21_decimal value_1 = {{10, 0, 0, 0}};
 s21_decimal value_2 = {{20, 0, 0, 0}};
 set_sign(&value_2, minus);
 set_scale(&value_1, 10);
 set_scale(&value_2, 5);
 s21_decimal result;
 s21_decimal expected = {{200001, 0, 0, 0}};
 set_scale(&expected, 9);
 int return_code = s21_sub(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательного и положительного дробных чисел
#test sub_negative_and_positive_float
 s21_decimal value_1 = {{10, 0, 0, 0}};
 s21_decimal value_2 = {{20, 0, 0, 0}};
 set_sign(&value_1, minus);
 set_scale(&value_1, 10);
 set_scale(&value_2, 5);
 s21_decimal result;
 s21_decimal expected = {{200001, 0, 0, 0x80000000}};
 set_scale(&expected, 9);
 int return_code = s21_sub(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_sub вычитание положительных дробного и целого
#test sub_positive_float_int
 s21_decimal value_1 = {{10, 0, 0, 0}};
 s21_decimal value_2 = {{20, 0, 0, 0}};
 set_scale(&value_1, 10);
 s21_decimal result;
 s21_decimal expected = {{2820130815, 4, 0, 0x80000000}};
 set_scale(&expected, 9);
 int return_code = s21_sub(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательных дробного и целого
#test sub_negative_float_int
 s21_decimal value_1 = {{10, 0, 0, 0}};
 s21_decimal value_2 = {{20, 0, 0, 0}};
 set_sign(&value_1, minus);
 set_sign(&value_2, minus);
 set_scale(&value_1, 10);
 s21_decimal result;
 s21_decimal expected = {{2820130815, 4, 0, 0}};
 set_scale(&expected, 9);
 int return_code = s21_sub(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательного дробного и положительного целого
#test sub_negative_float_positive_int
 s21_decimal value_1 = {{10, 0, 0, 0}};
 s21_decimal value_2 = {{20, 0, 0, 0}};
 set_sign(&value_1, minus);
 set_scale(&value_1, 10);
 s21_decimal result;
 s21_decimal expected = {{2820130817, 4, 0, 0x80000000}};
 set_scale(&expected, 9);
 int return_code = s21_sub(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_sub вычитание положительного дробного и отрицательного целого
#test sub_positive_float_negative_int
 s21_decimal value_1 = {{10, 0, 0, 0}};
 s21_decimal value_2 = {{20, 0, 0, 0}};
 set_scale(&value_1, 10);
 set_sign(&value_2, minus);
 s21_decimal result;
 s21_decimal expected = {{2820130817, 4, 0, 0}};
 set_scale(&expected, 9);
 int return_code = s21_sub(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_sub вычитание положительного целого и отрицательного дробного
#test sub_positive_int_negative_float
 s21_decimal value_1 = {{10, 0, 0, 0}};
 s21_decimal value_2 = {{20, 0, 0, 0}};
 set_sign(&value_2, minus);
 set_scale(&value_2, 5);
 s21_decimal result;
 s21_decimal expected = {{100002, 0, 0, 0}};
 set_scale(&expected, 4);
 int return_code = s21_sub(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательного целого и положительного дробного
#test sub_negative_int_positive_float
 s21_decimal value_1 = {{10, 0, 0, 0}};
 s21_decimal value_2 = {{20, 0, 0, 0}};
 set_sign(&value_1, minus);
 set_scale(&value_2, 5);
 s21_decimal result;
 s21_decimal expected = {{100002, 0, 0, 0x80000000}};
 set_scale(&expected, 4);
 int return_code = s21_sub(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_sub вычитание максимального отрицательного из максимального
// положительного
#test sub_overflow
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
set_sign(&value_1, minus);
s21_decimal result;

int return_code = s21_sub(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_sub вычитание минимального отрицательного и максимального
// положительного
#test sub_overflow_two
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
set_sign(&value_1, minus);
s21_decimal result;

int return_code = s21_sub(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_sub вычитание максимального отрицательного и минимального
// положительного
#test sub_overflow_negative
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{1, 0, 0, 0}};
set_sign(&value_1, minus);
s21_decimal result;

int return_code = s21_sub(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_sub вычитание нулей
#test sub_positive_numbers_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание нулей
#test sub_positive_and_negative_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_sign(&value_2, minus);
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание нулей
#test sub_negative_and_positive_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_sign(&value_1, minus);
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание нулей
#test sub_negative_numbers_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_sign(&value_1, minus);
set_sign(&value_2, minus);
s21_decimal expected = {{0, 0, 0, 0}};
s21_decimal result;
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание положительных чисел с большим скейлом
#test sub_positive_float_big_scale
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{2, 0, 0, 0}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
s21_decimal result;
s21_decimal expected = {{19, 0, 0, 0x80000000}};
set_scale(&expected, 28);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательных чисел с большим скейлом
#test sub_negative_float_big_scale
 s21_decimal value_1 = {{1, 0, 0, 0}};
 s21_decimal value_2 = {{2, 0, 0, 0}};
 set_sign(&value_1, minus);
 set_sign(&value_2, minus);
 set_scale(&value_1, 28);
 set_scale(&value_2, 27);
 s21_decimal result;
 s21_decimal expected = {{19, 0, 0, 0}};
 set_scale(&expected, 28);
 int return_code = s21_sub(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательного и положительного чисел с большим
// скейлом
#test sub_negative_and_positive_float_big_scale
 s21_decimal value_1 = {{1, 0, 0, 0}};
 s21_decimal value_2 = {{2, 0, 0, 0}};
 set_sign(&value_1, minus);
 set_scale(&value_1, 28);
 set_scale(&value_2, 27);
 s21_decimal result;
 s21_decimal expected = {{21, 0, 0, 0x80000000}};
 set_scale(&expected, 28);
 int return_code = s21_sub(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_sub вычитание полоижтельного и отрицательного чисел с большим
// скейлом
#test sub_positive_and_negative_float_big_scale
 s21_decimal value_1 = {{1, 0, 0, 0}};
 s21_decimal value_2 = {{2, 0, 0, 0}};
 set_sign(&value_2, minus);
 set_scale(&value_1, 28);
 set_scale(&value_2, 27);
 s21_decimal result;
 s21_decimal expected = {{21, 0, 0, 0}};
 set_scale(&expected, 28);
 int return_code = s21_sub(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_sub вычитание положительного числа и нуля
#test sub_positive_numbers_and_zero
s21_decimal value_1 = {{15, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание нуля и положительного числа
#test sub_zero_and_positive_numbers
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0}};
set_sign(&expected, minus);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание положительного дробного и нуля
#test sub_positive_float_and_zero
 s21_decimal value_1 = {{15, 0, 0, 0}};
 s21_decimal value_2 = {{0, 0, 0, 0}};
 set_scale(&value_1, 7);
 s21_decimal result;
 s21_decimal expected = {{15, 0, 0, 0}};
 set_scale(&expected, 7);
 int return_code = s21_sub(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_sub вычитание нуля и положительного дробного
#test sub_zero_and_positive_float
 s21_decimal value_1 = {{0, 0, 0, 0}};
 s21_decimal value_2 = {{15, 0, 0, 0}};
 set_scale(&value_2, 7);
 s21_decimal result;
 s21_decimal expected = {{15, 0, 0, 0}};
 set_scale(&expected, 7);
 set_sign(&expected, minus);
 int return_code = s21_sub(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательного числа и нуля
#test sub_negative_numbers_and_zero
s21_decimal value_1 = {{15, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_sign(&value_1, minus);
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0}};
set_sign(&expected, minus);
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание нуля и отрицательного числа
#test sub_zero_and_negative_numbers
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0}};
set_sign(&value_2, minus);
s21_decimal result;
s21_decimal expected = {{15, 0, 0, 0}};
int return_code = s21_sub(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_sub вычитание отрицательного дробного и нуля
#test sub_negative_float_and_zero
 s21_decimal value_1 = {{15, 0, 0, 0}};
 s21_decimal value_2 = {{0, 0, 0, 0}};
 set_scale(&value_1, 7);
 set_sign(&value_1, minus);

 s21_decimal result;
 s21_decimal expected = {{15, 0, 0, 0x80000000}};
 set_scale(&expected, 7);
 set_sign(&value_1, minus);
 int return_code = s21_sub(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_sub вычитание нуля и отрицательного дробного
#test sub_zero_and_negative_float
 s21_decimal value_1 = {{0, 0, 0, 0}};
 s21_decimal value_2 = {{15, 0, 0, 0}};
 set_scale(&value_2, 7);
 set_sign(&value_2, minus);
 s21_decimal result;
 s21_decimal expected = {{15, 0, 0, 0}};
 set_scale(&expected, 7);
 int return_code = s21_sub(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

//  ОКРУГЛЕНИЕ
//  Функция s21_sub сложение двух положительных чисел с большой мантиссой с
//  ненулевыми разрядами
// #test sub_positive_float_big_scale
//  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
//  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
//  set_scale(&value_1, 28);
//  set_scale(&value_2, 27);
//  s21_decimal result;
//  int return_code = s21_sub(value_1, value_2, &result);
// 
//  ck_assert(s21_is_equal(result, expected) == 1);
//  ck_assert(return_code == 0);

//// Функция s21_sub сложение двух отрицательных чисел с большой мантиссой с
/// ненулевыми разрядами
//#test sub_negative_float_big_scale
// s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// set_scale(&value_1, 28);
// set_scale(&value_2, 27);
// s21_decimal result;
// s21_decimal expected = ???;
// set_scale(&expected, ???);
// int return_code = s21_sub(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);
//
//// Функция s21_sub сложение отрицательного и положительного с большой
/// мантиссой с ненулевыми разрядами
//#test sub_negative_and_positive_float_big_scale
// s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
// set_scale(&value_1, 28);
// set_scale(&value_2, 27);
// s21_decimal result;
// s21_decimal expected = ???;
// set_scale(&expected, ???);
// int return_code = s21_sub(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);
//
//// Функция s21_sub сложение положительного и отрицательного с большой
/// мантиссой с ненулевыми разрядами
//#test sub_positive_and_negative_float_big_scale
// s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
// s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
// set_scale(&value_1, 28);
// set_scale(&value_2, 27);
// s21_decimal result;
// s21_decimal expected = ???;
// set_scale(&expected, ???);
// int return_code = s21_sub(value_1, value_2, &result);
//
// ck_assert(s21_is_equal(result, expected) == 1);
// ck_assert(return_code == 0);

// s21_mul
// s21_mul
// Функция s21_mul умножение двух положительных чисел
#test mul_positive_numbers
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{200, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение двух отрицательных чисел
#test mul_negative_numbers
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
s21_decimal result;
s21_decimal expected = {{200, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение положительного и отрицательного чисел
#test mul_positive_and_negative
s21_decimal value_1 = {{10, 0, 0, 0}};
s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
s21_decimal result;
s21_decimal expected = {{200, 0, 0, 0x80000000}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного и положительного чисел
#test mul_negative_and_positive
s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
s21_decimal value_2 = {{20, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{200, 0, 0, 0x80000000}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение двух положительных дробных
 #test mul_positive_float
 s21_decimal value_1 = {{10, 0, 0, 0}};
 s21_decimal value_2 = {{20, 0, 0, 0}};
 set_scale(&value_1, 10);
 set_scale(&value_2, 5);
 s21_decimal result;
 s21_decimal expected = {{2, 0, 0, 0}};
 set_scale(&expected, 13);
 int return_code = s21_mul(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_mul умножение двух отрицательных дробных
#test mul_negative_float
 s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
 s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
 set_scale(&value_1, 10);
 set_scale(&value_2, 5);
 s21_decimal result;
 s21_decimal expected = {{2, 0, 0, 0}};
 set_scale(&expected, 13);
 int return_code = s21_mul(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

//// Функция s21_mul умножение положительного и отрицательного дробных
#test mul_positive_and_negative_float
 s21_decimal value_1 = {{10, 0, 0, 0}};
 s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
 set_scale(&value_1, 10);
 set_scale(&value_2, 5);
 s21_decimal result;
 s21_decimal expected = {{2, 0, 0, 0x80000000}};
 set_scale(&expected, 13);
 int return_code = s21_mul(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного и положительного дробных
#test mul_negative_and_positive_float
 s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
 s21_decimal value_2 = {{20, 0, 0, 0}};
 set_scale(&value_1, 10);
 set_scale(&value_2, 5);
 s21_decimal result;
 s21_decimal expected = {{2, 0, 0, 0x80000000}};
 set_scale(&expected, 13);
 int return_code = s21_mul(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_mul умножение положительного дробного и целого
#test mul_positive_float_int
 s21_decimal value_1 = {{10, 0, 0, 0}};
 s21_decimal value_2 = {{20, 0, 0, 0}};
 set_scale(&value_1, 10);
 s21_decimal result;
 s21_decimal expected = {{2, 0, 0, 0}};
 set_scale(&expected, 8);
 int return_code = s21_mul(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного дробного и целого
#test mul_negative_float_int
 s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
 s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
 set_scale(&value_1, 10);
 s21_decimal result;
 s21_decimal expected = {{2, 0, 0, 0}};
 set_scale(&expected, 8);
 int return_code = s21_mul(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного дробного и положительного целого
#test mul_negative_float_positive_int
 s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
 s21_decimal value_2 = {{20, 0, 0, 0}};
 set_scale(&value_1, 10);
 s21_decimal result;
 s21_decimal expected = {{2, 0, 0, 0x80000000}};
 set_scale(&expected, 8);
 int return_code = s21_mul(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_mul умножение положительного дробного и отрицательного целого
#test mul_positive_float_negative_int
 s21_decimal value_1 = {{10, 0, 0, 0}};
 s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
 set_scale(&value_1, 10);
 s21_decimal result;
 s21_decimal expected = {{2, 0, 0, 0x80000000}};
 set_scale(&expected, 8);
 int return_code = s21_mul(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_mul умножение положительного целого отрицательного дробного
#test mul_positive_int_negative_float
 s21_decimal value_1 = {{10, 0, 0, 0}};
 s21_decimal value_2 = {{20, 0, 0, 0x80000000}};
 set_scale(&value_2, 5);
 s21_decimal result;
 s21_decimal expected = {{2, 0, 0, 0x80000000}};
 set_scale(&expected, 3);
 int return_code = s21_mul(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного целого положительного дробного
#test mul_negative_int_positive_float
  s21_decimal value_1 = {{10, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{20, 0, 0, 0}};
  set_scale(&value_2, 5);
  s21_decimal result;
  s21_decimal expected = {{2, 0, 0, 0x80000000}};
  int return_code = s21_mul(value_1, value_2, &result);
  set_scale(&expected, 3);
  ck_assert(s21_is_equal(result, expected) == 1);
  ck_assert(return_code == 0);

// Функция s21_mul очень большое число и маленькое - переполнение
#test mul_overflow
  s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal value_2 = {{2, 0, 0, 0}};
  s21_decimal result;

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 1);

// Функция s21_mul умножение очень маленького и очень большого - переполнение
#test mul_overflow_two
  s21_decimal value_1 = {{2, 0, 0, 0}};
  s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
  s21_decimal result;

  int return_code = s21_mul(value_1, value_2, &result);
  ck_assert(return_code == 1);

// Функция s21_mul умножение двух очень больших - переполнение
#test mul_overflow_three
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_mul умножение двух очень больших отрицательное и положительное -
// переполнение
#test mul_overflow_four
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_mul умножение двух очень больших положительное и отрицательное -
// переполнение
#test mul_overflow_five
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 2);

// Функция s21_mul умножение отрицательных очень большое число и маленькое -
// переполнение
#test mul_overflow_negative
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal value_2 = {{2, 0, 0, 0x80000000}};
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_mul умножение отрицательных очень маленького и очень большого -
// переполнение
#test mul_overflow_negative_two
s21_decimal value_1 = {{2, 0, 0, 0x80000000}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_mul умножение отрицательных двух очень больших - переполнение
#test mul_overflow_negative_three
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 1);

// Функция s21_mul умножение двух нулей
#test mul_positive_numbers_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение положительного и отрицательного нуля
#test mul_positive_and_negative_zero
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0x80000000}};
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного и положительного нуля
#test mul_negative_and_positive_zero
s21_decimal value_1 = {{0, 0, 0, 0x80000000}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательных нулей
#test mul_negative_numbers_zero
s21_decimal value_1 = {{0, 0, 0, 0x80000000}};
s21_decimal value_2 = {{0, 0, 0, 0x80000000}};
s21_decimal result;

int return_code = s21_mul(value_1, value_2, &result);

ck_assert(return_code == 0);

// Функция s21_mul умножение положительного числа и нуля
#test mul_positive_numbers_and_zero
s21_decimal value_1 = {{15, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение нуля и положительного числа
#test mul_zero_and_positive_numbers
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение положительного дробного и нуля
#test mul_positive_float_and_zero
 s21_decimal value_1 = {{15, 0, 0, 0}};
 s21_decimal value_2 = {{0, 0, 0, 0}};
 set_scale(&value_1, 7);
 s21_decimal result;
 s21_decimal expected = {{0, 0, 0, 0}};
 int return_code = s21_mul(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_mul умножение нуля и положительного дробного
#test mul_zero_and_positive_float
 s21_decimal value_1 = {{0, 0, 0, 0}};
 s21_decimal value_2 = {{15, 0, 0, 0}};
 set_scale(&value_2, 7);
 s21_decimal result;
 s21_decimal expected = {{0, 0, 0, 0}};
 int return_code = s21_mul(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного числа и нуля
#test mul_negative_numbers_and_zero
s21_decimal value_1 = {{15, 0, 0, 0x80000000}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение нуля и отрицательного числа
#test mul_zero_and_negative_numbers
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{15, 0, 0, 0x80000000}};
s21_decimal result;
s21_decimal expected = {{0, 0, 0, 0}};
int return_code = s21_mul(value_1, value_2, &result);

ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_mul умножение отрицательного дробного и нуля
#test mul_negative_float_and_zero
 s21_decimal value_1 = {{15, 0, 0, 0x80000000}};
 s21_decimal value_2 = {{0, 0, 0, 0}};
 set_scale(&value_1, 7);
 s21_decimal result;
 s21_decimal expected = {{0, 0, 0, 0}};
 int return_code = s21_mul(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_mul умножение нуля и отрицательного дробного
#test mul_zero_and_negative_float
 s21_decimal value_1 = {{0, 0, 0, 0}};
 s21_decimal value_2 = {{15, 0, 0, 0x80000000}};
 set_scale(&value_2, 7);
 s21_decimal result;
 s21_decimal expected = {{0, 0, 0, 0}};
 int return_code = s21_mul(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_mul умножение двух положительных чисел с большой мантиссой
#test mul_positive_float_big_scale
  s21_decimal value_1 = {{1, 0, 0, 0}};
  s21_decimal value_2 = {{2, 0, 0, 0}};
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result;

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 1);

// Функция s21_mul умножение двух отрицательных чисел с большой мантиссой
#test mul_negative_float_big_scale
  s21_decimal value_1 = {{1, 0, 0, 0x80000000}};
  s21_decimal value_2 = {{2, 0, 0, 0x80000000}};
  set_scale(&value_1, 28);
  set_scale(&value_2, 27);
  s21_decimal result;

  int return_code = s21_mul(value_1, value_2, &result);

  ck_assert(return_code == 1);

// Функция s21_mul умножение отрицательного и положительного с большой
///мантиссой
#test mul_negative_and_positive_float_big_scale
 s21_decimal value_1 = {{1, 0, 0, 0x80000000}};
 s21_decimal value_2 = {{2, 0, 0, 0}};
 set_scale(&value_1, 28);
 set_scale(&value_2, 27);
 s21_decimal result;

 int return_code = s21_mul(value_1, value_2, &result);

 ck_assert(return_code == 2);

// Функция s21_mul умножение положительного и отрицательного с большой
///мантиссой
#test mul_positive_and_negative_float_big_scale
 s21_decimal value_1 = {{1, 0, 0, 0}};
 s21_decimal value_2 = {{2, 0, 0, 0x80000000}};
 set_scale(&value_1, 28);
 set_scale(&value_2, 27);
 s21_decimal result;

 int return_code = s21_mul(value_1, value_2, &result);

 ck_assert(return_code == 2);

// Функция s21_mul умножение двух положительных чисел с большой мантиссой с
// ненулевыми разрядами
#test mul_positive_float_big_scale_not_zero
 s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
 s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
 set_scale(&value_1, 28);
 set_scale(&value_2, 27);
 s21_decimal result;

 int return_code = s21_mul(value_1, value_2, &result);

 ck_assert(return_code == 1);

// Функция s21_mul умножение двух отрицательных чисел с большой мантиссой с
// ненулевыми разрядами
#test mul_negative_float_big_scale_not_zero
 s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
 s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
 set_scale(&value_1, 28);
 set_scale(&value_2, 27);
 s21_decimal result;

 int return_code = s21_mul(value_1, value_2, &result);

 ck_assert(return_code == 1);

// Функция s21_mul умножение отрицательного и положительного с большой
// мантиссой / с ненулевыми разрядами
#test mul_negative_and_positive_float_big_scale_not_zero
 s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
 s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
 set_scale(&value_1, 28);
 set_scale(&value_2, 27);
 s21_decimal result;

 int return_code = s21_mul(value_1, value_2, &result);

 ck_assert(return_code == 2);

// Функция s21_mul умножение положительного и отрицательного с большой
// мантиссой / с ненулевыми разрядами
#test mul_positive_and_negative_float_big_scale_not_zero
 s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
 s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0x80000000}};
 set_scale(&value_1, 28);
 set_scale(&value_2, 27);
 s21_decimal result;

 int return_code = s21_mul(value_1, value_2, &result);

 ck_assert(return_code == 2);

// Функция s21_mul умножение целые большие числа с нулями
// Функция s21_mul очень большое целое число на очень маленькое число с
// плавающей точкой (отриц и положит)

// Функция s21_mul умножение двух положительных дробных результат 5
#test mul_positive_float__
 s21_decimal value_1 = {{50, 0, 0, 0}};
 s21_decimal value_2 = {{10, 0, 0, 0}};
 set_scale(&value_2, 2);
 s21_decimal result;
 s21_decimal expected = {{5, 0, 0, 0}};
 int return_code = s21_mul(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция s21_mul умножение двух положительных дробных результат 5
#test mul_positive_float____
 s21_decimal value_1 = {{5, 0, 0, 0}};
 s21_decimal value_2 = {{10, 0, 0, 0}};
 set_scale(&value_2, 1);
 s21_decimal result;
 s21_decimal expected = {{5, 0, 0, 0}};
 int return_code = s21_mul(value_1, value_2, &result);

 ck_assert(s21_is_equal(result, expected) == 1);
 ck_assert(return_code == 0);

// Функция void alignment
#test alignment_both_zero_with_scale
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_scale(&value_1, 28);
set_scale(&value_2, 27);
alignment(&value_1, &value_2, 1);

s21_decimal expected1 = {{0, 0, 0, 0}};
s21_decimal expected2 = {{0, 0, 0, 0}};
set_scale(&expected1, 0);
set_scale(&expected2, 0);

ck_assert(s21_is_equal(value_1, expected1) == 1);
ck_assert(s21_is_equal(value_2, expected2) == 1);

// Функция void alignment
#test alignment_both_zero_without_scale
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};

alignment(&value_1, &value_2, 1);

s21_decimal expected1 = {{0, 0, 0, 0}};
s21_decimal expected2 = {{0, 0, 0, 0}};

ck_assert(s21_is_equal(value_1, expected1) == 1);
ck_assert(s21_is_equal(value_2, expected2) == 1);

// Функция void alignment
#test alignment_both_zero_without_scale_and_with_scale
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_scale(&value_2, 28);

alignment(&value_1, &value_2, 1);

s21_decimal expected1 = {{0, 0, 0, 0}};
s21_decimal expected2 = {{0, 0, 0, 0}};
set_scale(&expected2, 0);

ck_assert(s21_is_equal(value_1, expected1) == 1);
ck_assert(s21_is_equal(value_2, expected2) == 1);

// Функция void alignment
#test alignment_both_zero_with_scale_and_without_scale
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
set_scale(&value_1, 28);

alignment(&value_1, &value_2, 1);

s21_decimal expected1 = {{0, 0, 0, 0}};
s21_decimal expected2 = {{0, 0, 0, 0}};
set_scale(&expected1, 0);

ck_assert(s21_is_equal(value_1, expected1) == 1);
ck_assert(s21_is_equal(value_2, expected2) == 1);

// Функция void alignment
#test alignment_float_with_zero_and_int
s21_decimal value_1 = {{1234000, 0, 0, 0}};
s21_decimal value_2 = {{5678, 0, 0, 0}};
set_scale(&value_1, 7);
set_scale(&value_2, 0);

alignment(&value_1, &value_2, 1);

s21_decimal expected1 = {{1234, 0, 0, 0}};
s21_decimal expected2 = {{56780000, 0, 0, 0}};
set_scale(&expected1, 4);
set_scale(&expected2, 4);

ck_assert(s21_is_equal(value_1, expected1) == 1);
ck_assert(s21_is_equal(value_2, expected2) == 1);

// Функция void alignment
#test alignment_int_and_float_with_zero
s21_decimal value_1 = {{1234, 0, 0, 0}};
s21_decimal value_2 = {{5678000, 0, 0, 0}};
set_scale(&value_1, 0);
set_scale(&value_2, 7);

alignment(&value_1, &value_2, 1);

s21_decimal expected1 = {{12340000, 0, 0, 0}};
s21_decimal expected2 = {{5678, 0, 0, 0}};
set_scale(&expected1, 4);
set_scale(&expected2, 4);

ck_assert(s21_is_equal(value_1, expected1) == 1);
ck_assert(s21_is_equal(value_2, expected2) == 1);

// Функция void alignment
#test alignment_big_float_big_scale_and_min_scale_
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
set_scale(&value_1, 28);
set_scale(&value_2, 1);
alignment(&value_1, &value_2, 1);

s21_decimal expected1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal expected2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
set_scale(&expected1, 28);
set_scale(&expected2, 28);

ck_assert(s21_is_equal(value_1, expected1) == 1);
ck_assert(s21_is_equal(value_2, expected2) == 1);

// Функция void alignment
#test alignment_big_float_min_scale_and_big_scale
s21_decimal value_1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal value_2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
set_scale(&value_1, 1);
set_scale(&value_2, 28);
alignment(&value_1, &value_2, 1);

s21_decimal expected1 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal expected2 = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
set_scale(&expected1, 28);
set_scale(&expected2, 28);

ck_assert(s21_is_equal(value_1, expected1) == 1);
ck_assert(s21_is_equal(value_2, expected2) == 1);

// Функция void alignment
#test alignment_min_float_big_scale_and_min_scale_
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{1, 0, 0, 0}};
set_scale(&value_1, 28);
set_scale(&value_2, 1);
alignment(&value_1, &value_2, 1);

s21_decimal expected1 = {{1, 0, 0, 0}};
s21_decimal expected2 = {{1, 0, 0, 0}};
set_scale(&expected1, 28);
set_scale(&expected2, 28);

ck_assert(s21_is_equal(value_1, expected1) == 1);
ck_assert(s21_is_equal(value_2, expected2) == 1);

// Функция void alignment
#test alignment_min_float_min_scale_and_big_scale
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{1, 0, 0, 0}};
set_scale(&value_1, 1);
set_scale(&value_2, 28);
alignment(&value_1, &value_2, 1);

s21_decimal expected1 = {{1, 0, 0, 0}};
s21_decimal expected2 = {{1, 0, 0, 0}};
set_scale(&expected1, 28);
set_scale(&expected2, 28);

ck_assert(s21_is_equal(value_1, expected1) == 1);
ck_assert(s21_is_equal(value_2, expected2) == 1);

#test positive_s21_is_equal_00
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
bool result = s21_is_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_equal_01
s21_decimal value_1 = {{0, 500, 1, 0}};
s21_decimal value_2 = {{0, 500, 1, 0}};
set_sign(&value_1, minus);
set_sign(&value_2, minus);
set_scale(&value_1, 27);
set_scale(&value_2, 27);
bool result = s21_is_equal(value_1, value_2);
ck_assert(result == 1);

#test negative_s21_is_equal_00
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
bool result = s21_is_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_equal_01
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{1, 0, 0, 0}};
set_sign(&value_1, minus);
bool result = s21_is_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_equal_02
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{1, 0, 0, 0}};
set_scale(&value_1, 27);
bool result = s21_is_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_equal_03
s21_decimal value_1 = {{0, 1, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
bool result = s21_is_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_not_equal_00
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
bool result = s21_is_not_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_not_equal_01
s21_decimal value_1 = {{0, 500, 1, 0}};
s21_decimal value_2 = {{0, 500, 1, 0}};
set_sign(&value_1, minus);
set_sign(&value_2, minus);
set_scale(&value_1, 27);
set_scale(&value_2, 27);
bool result = s21_is_not_equal(value_1, value_2);
ck_assert(result == 0);

#test positive_s21_is_not_equal_00
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
bool result = s21_is_not_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_not_equal_01
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{1, 0, 0, 0}};
set_sign(&value_1, minus);
bool result = s21_is_not_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_not_equal_02
s21_decimal value_1 = {{1, 0, 0, 0}};
s21_decimal value_2 = {{1, 0, 0, 0}};
set_scale(&value_1, 27);
bool result = s21_is_not_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_not_equal_03
s21_decimal value_1 = {{0, 1, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
bool result = s21_is_not_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_less_00
s21_decimal value_1 = {{0, 1, 0, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
bool result = s21_is_less(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_less_01
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
bool result = s21_is_less(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_less_02
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
set_sign(&value_1, minus);
bool result = s21_is_less(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_less_03
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
set_scale(&value_1, 27);
set_scale(&value_2, 26);
bool result = s21_is_less(value_1, value_2);
ck_assert(result == 1);

#test negative_s21_is_less_00
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 1, 0, 0}};
bool result = s21_is_less(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_less_01
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
bool result = s21_is_less(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_less_02
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
set_sign(&value_2, minus);
bool result = s21_is_less(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_less_03
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
set_scale(&value_1, 25);
set_scale(&value_2, 26);
bool result = s21_is_less(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_less_04
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
bool result = s21_is_less(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_greater_00
s21_decimal value_1 = {{0, 1, 0, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
bool result = s21_is_greater(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_greater_01
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
bool result = s21_is_greater(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_greater_02
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
set_sign(&value_1, minus);
bool result = s21_is_greater(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_greater_03
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
set_scale(&value_1, 27);
set_scale(&value_2, 26);
bool result = s21_is_greater(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_greater_04
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
bool result = s21_is_greater(value_1, value_2);
ck_assert(result == 0);

#test positive_s21_is_greater_00
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 1, 0, 0}};
bool result = s21_is_greater(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_greater_01
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
bool result = s21_is_greater(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_greater_02
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
set_sign(&value_2, minus);
bool result = s21_is_greater(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_greater_03
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
set_scale(&value_1, 25);
set_scale(&value_2, 26);
bool result = s21_is_greater(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_less_or_equal_000
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
bool result = s21_is_less_or_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_less_or_equal_00
s21_decimal value_1 = {{0, 1, 0, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
bool result = s21_is_less_or_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_less_or_equal_01
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
bool result = s21_is_less_or_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_less_or_equal_02
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
set_sign(&value_1, minus);
bool result = s21_is_less_or_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_less_or_equal_03
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
set_scale(&value_1, 27);
set_scale(&value_2, 26);
bool result = s21_is_less_or_equal(value_1, value_2);
ck_assert(result == 1);

#test negative_s21_is_less_or_equal_00
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 1, 0, 0}};
bool result = s21_is_less_or_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_less_or_equal_01
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
bool result = s21_is_less_or_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_less_or_equal_02
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
set_sign(&value_2, minus);
bool result = s21_is_less_or_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_less_or_equal_03
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
set_scale(&value_1, 25);
set_scale(&value_2, 26);
bool result = s21_is_less_or_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_greater_or_equal_00
s21_decimal value_1 = {{0, 1, 0, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
bool result = s21_is_greater_or_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_greater__or_equal01
s21_decimal value_1 = {{0, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
bool result = s21_is_greater_or_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_greater__or_equal02
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
set_sign(&value_1, minus);
bool result = s21_is_greater_or_equal(value_1, value_2);
ck_assert(result == 0);

#test negative_s21_is_greater_or_equal_03
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
set_scale(&value_1, 27);
set_scale(&value_2, 26);
bool result = s21_is_greater_or_equal(value_1, value_2);
ck_assert(result == 0);

#test positive_s21_is_greater_or_equal_000
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
bool result = s21_is_greater_or_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_greater_or_equal_00
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 1, 0, 0}};
bool result = s21_is_greater_or_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_greater_or_equal_01
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
bool result = s21_is_greater_or_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_greater_or_equal_02
s21_decimal value_1 = {{0, 0, 1, 0}};
s21_decimal value_2 = {{0, 0, 1, 0}};
set_sign(&value_2, minus);
bool result = s21_is_greater_or_equal(value_1, value_2);
ck_assert(result == 1);

#test positive_s21_is_greater_or_equal_03
s21_decimal value_1 = {{1, 0, 1, 0}};
s21_decimal value_2 = {{1, 0, 1, 0}};
set_scale(&value_1, 25);
set_scale(&value_2, 26);
bool result = s21_is_greater_or_equal(value_1, value_2);
ck_assert(result == 1);

#test truncate_1
s21_decimal value = {{25, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{2, 0, 0, 0}};
set_scale(&value, 1);
set_scale(&expected, 0);
s21_truncate(value, &result);
int eq = s21_is_equal(result, expected);
ck_assert(eq == 1);

#test truncate_2
s21_decimal value = {{12345, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{123, 0, 0, 0}};
set_scale(&value, 2);
set_scale(&expected, 0);
s21_truncate(value, &result);
int eq = s21_is_equal(result, expected);
ck_assert(eq == 1);

#test truncate_3
s21_decimal value = {{98765, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{987, 0, 0, 0}};
set_scale(&value, 2);
set_scale(&expected, 0);
s21_truncate(value, &result);
int eq = s21_is_equal(result, expected);
ck_assert(eq == 1);

#test truncate_4
s21_decimal value = {{1000, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{10, 0, 0, 0}};
set_scale(&value, 2);
set_scale(&expected, 0);
s21_truncate(value, &result);
int eq = s21_is_equal(result, expected);
ck_assert(eq == 1);

#test truncate_5
s21_decimal value = {{250, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{25, 0, 0, 0}};
set_sign(&value, minus);
set_sign(&expected, minus);
set_scale(&value, 1);
set_scale(&expected, 0);
s21_truncate(value, &result);
int eq = s21_is_equal(result, expected);
ck_assert(eq == 1);

#test truncate_6
s21_decimal value = {{123456789, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{1234567, 0, 0, 0}};
set_sign(&value, minus);
set_sign(&expected, minus);
set_scale(&value, 2);
set_scale(&expected, 0);
s21_truncate(value, &result);
int eq = s21_is_equal(result, expected);
ck_assert(eq == 1);

#test truncate_7
s21_decimal value = {{0, 0, 0, 0}};
s21_decimal result = {{0, 0, 0, 0}};
s21_decimal expected = {{0, 0, 0, 0}};
set_scale(&value, 3);
set_scale(&expected, 0);
s21_truncate(value, &result);
int eq = s21_is_equal(result, expected);
ck_assert(eq == 1);

#test truncate_overflow
s21_decimal value = {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}};
s21_decimal result;
set_scale(&value, 1);
int return_code = s21_truncate(value, &result);

#test truncate_positive_float
s21_decimal value = {{12345, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{123, 0, 0, 0}};
set_scale(&value, 2);
set_scale(&expected, 0);
int return_code = s21_truncate(value, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_div - деление двух положительных дробных
#test div_positive_float
s21_decimal value_1 = {{100, 0, 0, 0}};
s21_decimal value_2 = {{25, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{4, 0, 0, 0}};
set_scale(&value_1, 2);
set_scale(&value_2, 2);
set_scale(&expected, 0);
int return_code = s21_div(value_1, value_2, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_div - деление двух отрицательных дробных
#test div_negative_float
s21_decimal value_1 = {{100, 0, 0, 0x80000000}};
s21_decimal value_2 = {{25, 0, 0, 0x80000000}};
s21_decimal result;
s21_decimal expected = {{4, 0, 0, 0}};
set_scale(&value_1, 2);
set_scale(&value_2, 2);
set_scale(&expected, 0);
int return_code = s21_div(value_1, value_2, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_div - деление положительного на отрицательное
#test div_positive_negative
s21_decimal value_1 = {{100, 0, 0, 0}};
s21_decimal value_2 = {{25, 0, 0, 0x80000000}};
s21_decimal result;
s21_decimal expected = {{4, 0, 0, 0}};
set_scale(&value_1, 2);
set_scale(&value_2, 2);
set_scale(&expected, 0);
set_sign(&expected, minus);
int return_code = s21_div(value_1, value_2, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

// Функция s21_div - деление отрицательного на положительное
#test div_negative_positive
s21_decimal value_1 = {{100, 0, 0, 0x80000000}};
s21_decimal value_2 = {{25, 0, 0, 0}};
s21_decimal result;
s21_decimal expected = {{4, 0, 0, 0x80000000}};
set_scale(&value_1, 2);
set_scale(&value_2, 2);
set_scale(&expected, 0);
int return_code = s21_div(value_1, value_2, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

#test div_by_zero
s21_decimal value_1 = {{100, 0, 0, 0}};
s21_decimal value_2 = {{0, 0, 0, 0}};
s21_decimal result;
int return_code = s21_div(value_1, value_2, &result);
ck_assert(return_code == 3);

#test inf_div
s21_decimal value_1 = {{20, 0, 0, 0}};
s21_decimal value_2 = {{7, 0, 0, 0}};
s21_decimal result;
int return_code = s21_div(value_1, value_2, &result);
ck_assert(return_code == 1);

#test neginf_div
s21_decimal value_1 = {{22, 0, 0, 0}};
s21_decimal value_2 = {{7, 0, 0, 0}};
set_sign(&value_1, minus);
s21_decimal result;
int return_code = s21_div(value_1, value_2, &result);
ck_assert(return_code == 2);

#test div2
s21_decimal value_1;
s21_decimal value_2;
s21_decimal result;
s21_decimal expected;
str_2decimal("171701", &value_1);
str_2decimal("200000", &value_2);
str_2decimal("858505", &expected);
set_scale(&expected, 6);
int return_code = s21_div(value_1, value_2, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

#test div3
s21_decimal value_1;
s21_decimal value_2;
s21_decimal result;
s21_decimal expected;
str_2decimal(MAX_DECIMAL, &value_1);
str_2decimal("1000000000", &value_2);
str_2decimal(MAX_DECIMAL, &expected);
set_scale(&expected, 9);
int return_code = s21_div(value_1, value_2, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);

#test div4
s21_decimal value_1;
s21_decimal value_2;
s21_decimal result;
s21_decimal expected;
str_2decimal("1432345362332124431467430", &value_1);
str_2decimal("320", &value_2);
str_2decimal("447607925728788884833571875", &expected);
set_scale(&expected, 5);
int return_code = s21_div(value_1, value_2, &result);
ck_assert(s21_is_equal(result, expected) == 1);
ck_assert(return_code == 0);